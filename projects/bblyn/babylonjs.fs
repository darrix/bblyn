// ts2fable 0.6.0-build.320
module rec babylonjs
open System
open Fable.Core
open Fable.Import.JS
open Fable.Import.Browser

let [<Import("*","babylonjs")>] bABYLON: BABYLON.IExports = jsNative
let [<Import("*","babylonjs")>] VRDisplay: obj = jsNative
let [<Import("*","babylonjs")>] safePostMessage: obj option = jsNative
let [<Import("*","babylonjs")>] WebGLQuery: obj = jsNative
let [<Import("*","babylonjs")>] WebGLSampler: obj = jsNative
let [<Import("*","babylonjs")>] WebGLSync: obj = jsNative
let [<Import("*","babylonjs")>] WebGLTransformFeedback: obj = jsNative
let [<Import("*","babylonjs")>] WebGLVertexArrayObject: obj = jsNative
let [<Import("*","babylonjs")>] DracoDecoderModule: obj option = jsNative
let [<Import("*","babylonjs")>] WebAssembly: obj option = jsNative

type [<AllowNullLiteral>] IExports =
    abstract importScripts: [<ParamArray>] urls: ResizeArray<string> -> unit

module BABYLON =
    let [<Import("Debug","babylonjs/BABYLON")>] debug: Debug.IExports = jsNative

    type [<AllowNullLiteral>] IExports =
        abstract KeepAssets: KeepAssetsStatic
        abstract AssetContainer: AssetContainerStatic
        abstract Node: NodeStatic
        abstract RenderingGroupInfo: RenderingGroupInfoStatic
        abstract Scene: SceneStatic
        abstract Action: ActionStatic
        abstract ActionEvent: ActionEventStatic
        abstract ActionManager: ActionManagerStatic
        abstract Condition: ConditionStatic
        abstract ValueCondition: ValueConditionStatic
        abstract PredicateCondition: PredicateConditionStatic
        abstract StateCondition: StateConditionStatic
        abstract SwitchBooleanAction: SwitchBooleanActionStatic
        abstract SetStateAction: SetStateActionStatic
        abstract SetValueAction: SetValueActionStatic
        abstract IncrementValueAction: IncrementValueActionStatic
        abstract PlayAnimationAction: PlayAnimationActionStatic
        abstract StopAnimationAction: StopAnimationActionStatic
        abstract DoNothingAction: DoNothingActionStatic
        abstract CombineAction: CombineActionStatic
        abstract ExecuteCodeAction: ExecuteCodeActionStatic
        abstract SetParentAction: SetParentActionStatic
        abstract PlaySoundAction: PlaySoundActionStatic
        abstract StopSoundAction: StopSoundActionStatic
        abstract InterpolateValueAction: InterpolateValueActionStatic
        abstract Animatable: AnimatableStatic
        abstract AnimationRange: AnimationRangeStatic
        abstract AnimationEvent: AnimationEventStatic
        abstract PathCursor: PathCursorStatic
        abstract Animation: AnimationStatic
        abstract TargetedAnimation: TargetedAnimationStatic
        abstract AnimationGroup: AnimationGroupStatic
        abstract AnimationPropertiesOverride: AnimationPropertiesOverrideStatic
        abstract EasingFunction: EasingFunctionStatic
        abstract CircleEase: CircleEaseStatic
        abstract BackEase: BackEaseStatic
        abstract BounceEase: BounceEaseStatic
        abstract CubicEase: CubicEaseStatic
        abstract ElasticEase: ElasticEaseStatic
        abstract ExponentialEase: ExponentialEaseStatic
        abstract PowerEase: PowerEaseStatic
        abstract QuadraticEase: QuadraticEaseStatic
        abstract QuarticEase: QuarticEaseStatic
        abstract QuinticEase: QuinticEaseStatic
        abstract SineEase: SineEaseStatic
        abstract BezierCurveEase: BezierCurveEaseStatic
        abstract RuntimeAnimation: RuntimeAnimationStatic
        abstract Analyser: AnalyserStatic
        abstract AudioEngine: AudioEngineStatic
        abstract Sound: SoundStatic
        abstract SoundTrack: SoundTrackStatic
        abstract Bone: BoneStatic
        abstract BoneIKController: BoneIKControllerStatic
        abstract BoneLookController: BoneLookControllerStatic
        abstract Skeleton: SkeletonStatic
        abstract ArcRotateCamera: ArcRotateCameraStatic
        abstract ArcRotateCameraInputsManager: ArcRotateCameraInputsManagerStatic
        abstract Camera: CameraStatic
        abstract CameraInputTypes: obj
        abstract CameraInputsManager: CameraInputsManagerStatic
        abstract DeviceOrientationCamera: DeviceOrientationCameraStatic
        abstract FollowCamera: FollowCameraStatic
        abstract ArcFollowCamera: ArcFollowCameraStatic
        abstract FreeCamera: FreeCameraStatic
        abstract FreeCameraInputsManager: FreeCameraInputsManagerStatic
        abstract GamepadCamera: GamepadCameraStatic
        abstract AnaglyphFreeCamera: AnaglyphFreeCameraStatic
        abstract AnaglyphArcRotateCamera: AnaglyphArcRotateCameraStatic
        abstract AnaglyphGamepadCamera: AnaglyphGamepadCameraStatic
        abstract AnaglyphUniversalCamera: AnaglyphUniversalCameraStatic
        abstract StereoscopicFreeCamera: StereoscopicFreeCameraStatic
        abstract StereoscopicArcRotateCamera: StereoscopicArcRotateCameraStatic
        abstract StereoscopicGamepadCamera: StereoscopicGamepadCameraStatic
        abstract StereoscopicUniversalCamera: StereoscopicUniversalCameraStatic
        abstract TargetCamera: TargetCameraStatic
        abstract TouchCamera: TouchCameraStatic
        abstract UniversalCamera: UniversalCameraStatic
        abstract VirtualJoysticksCamera: VirtualJoysticksCameraStatic
        abstract DebugLayer: DebugLayerStatic
        abstract RayHelper: RayHelperStatic
        abstract Collider: ColliderStatic
        abstract CollisionWorker: string
        abstract CollisionCoordinatorWorker: CollisionCoordinatorWorkerStatic
        abstract CollisionCoordinatorLegacy: CollisionCoordinatorLegacyStatic
        abstract WorkerIncluded: bool
        abstract CollisionCache: CollisionCacheStatic
        abstract CollideWorker: CollideWorkerStatic
        abstract CollisionDetectorTransferable: CollisionDetectorTransferableStatic
        abstract IntersectionInfo: IntersectionInfoStatic
        abstract PickingInfo: PickingInfoStatic
        abstract BoundingBox: BoundingBoxStatic
        abstract BoundingInfo: BoundingInfoStatic
        abstract BoundingSphere: BoundingSphereStatic
        abstract Ray: RayStatic
        abstract InstancingAttributeInfo: InstancingAttributeInfoStatic
        abstract RenderTargetCreationOptions: RenderTargetCreationOptionsStatic
        abstract DepthTextureCreationOptions: DepthTextureCreationOptionsStatic
        abstract EngineCapabilities: EngineCapabilitiesStatic
        abstract Engine: EngineStatic
        abstract NullEngineOptions: NullEngineOptionsStatic
        abstract NullEngine: NullEngineStatic
        abstract KeyboardEventTypes: KeyboardEventTypesStatic
        abstract KeyboardInfo: KeyboardInfoStatic
        abstract KeyboardInfoPre: KeyboardInfoPreStatic
        abstract PointerEventTypes: PointerEventTypesStatic
        abstract PointerInfoBase: PointerInfoBaseStatic
        abstract PointerInfoPre: PointerInfoPreStatic
        abstract PointerInfo: PointerInfoStatic
        abstract EnvironmentHelper: EnvironmentHelperStatic
        abstract VideoDome: VideoDomeStatic
        abstract StickValues: StickValuesStatic
        abstract Gamepad: GamepadStatic
        abstract GenericPad: GenericPadStatic
        abstract GamepadManager: GamepadManagerStatic
        abstract Xbox360Pad: Xbox360PadStatic
        abstract EngineInstrumentation: EngineInstrumentationStatic
        abstract SceneInstrumentation: SceneInstrumentationStatic
        abstract _TimeToken: _TimeTokenStatic
        abstract EffectLayer: EffectLayerStatic
        abstract GlowLayer: GlowLayerStatic
        abstract HighlightLayer: HighlightLayerStatic
        abstract Layer: LayerStatic
        abstract DefaultLoadingScreen: DefaultLoadingScreenStatic
        abstract SceneLoaderProgressEvent: SceneLoaderProgressEventStatic
        abstract SceneLoader: SceneLoaderStatic
        abstract LensFlare: LensFlareStatic
        abstract LensFlareSystem: LensFlareSystemStatic
        abstract DirectionalLight: DirectionalLightStatic
        abstract HemisphericLight: HemisphericLightStatic
        abstract Light: LightStatic
        abstract PointLight: PointLightStatic
        abstract ShadowLight: ShadowLightStatic
        abstract SpotLight: SpotLightStatic
        abstract ColorCurves: ColorCurvesStatic
        abstract EffectFallbacks: EffectFallbacksStatic
        abstract EffectCreationOptions: EffectCreationOptionsStatic
        abstract Effect: EffectStatic
        abstract FresnelParameters: FresnelParametersStatic
        abstract ImageProcessingConfiguration: ImageProcessingConfigurationStatic
        abstract MaterialDefines: MaterialDefinesStatic
        abstract Material: MaterialStatic
        abstract MaterialHelper: MaterialHelperStatic
        abstract MultiMaterial: MultiMaterialStatic
        abstract PushMaterial: PushMaterialStatic
        abstract ShaderMaterial: ShaderMaterialStatic
        abstract StandardMaterialDefines: StandardMaterialDefinesStatic
        abstract StandardMaterial: StandardMaterialStatic
        abstract UniformBuffer: UniformBufferStatic
        abstract Scalar: ScalarStatic
        abstract ToGammaSpace: float
        abstract ToLinearSpace: obj
        abstract Epsilon: obj
        abstract Color3: Color3Static
        abstract Color4: Color4Static
        abstract Vector2: Vector2Static
        abstract Vector3: Vector3Static
        abstract Vector4: Vector4Static
        abstract Size: SizeStatic
        abstract Quaternion: QuaternionStatic
        abstract Matrix: MatrixStatic
        abstract Plane: PlaneStatic
        abstract Viewport: ViewportStatic
        abstract Frustum: FrustumStatic
        abstract Axis: AxisStatic
        abstract BezierCurve: BezierCurveStatic
        abstract Angle: AngleStatic
        abstract Arc2: Arc2Static
        abstract Path2: Path2Static
        abstract Path3D: Path3DStatic
        abstract Curve3: Curve3Static
        abstract PositionNormalVertex: PositionNormalVertexStatic
        abstract PositionNormalTextureVertex: PositionNormalTextureVertexStatic
        abstract Tmp: TmpStatic
        abstract SphericalPolynomial: SphericalPolynomialStatic
        abstract SphericalHarmonics: SphericalHarmonicsStatic
        abstract MorphTarget: MorphTargetStatic
        abstract MorphTargetManager: MorphTargetManagerStatic
        abstract GPUParticleSystem: GPUParticleSystemStatic
        abstract Particle: ParticleStatic
        abstract ParticleSystem: ParticleSystemStatic
        abstract SolidParticle: SolidParticleStatic
        abstract ModelShape: ModelShapeStatic
        abstract DepthSortedParticle: DepthSortedParticleStatic
        abstract SolidParticleSystem: SolidParticleSystemStatic
        abstract PhysicsEngine: PhysicsEngineStatic
        abstract PhysicsHelper: PhysicsHelperStatic
        abstract PhysicsRadialExplosionEvent: PhysicsRadialExplosionEventStatic
        abstract PhysicsGravitationalFieldEvent: PhysicsGravitationalFieldEventStatic
        abstract PhysicsUpdraftEvent: PhysicsUpdraftEventStatic
        abstract PhysicsVortexEvent: PhysicsVortexEventStatic
        abstract PhysicsImpostor: PhysicsImpostorStatic
        abstract PhysicsJoint: PhysicsJointStatic
        abstract DistanceJoint: DistanceJointStatic
        abstract MotorEnabledJoint: MotorEnabledJointStatic
        abstract HingeJoint: HingeJointStatic
        abstract Hinge2Joint: Hinge2JointStatic
        abstract AbstractMesh: AbstractMeshStatic
        abstract Buffer: BufferStatic
        abstract CSG: CSGStatic
        abstract Geometry: GeometryStatic
        abstract _PrimitiveGeometry: _PrimitiveGeometryStatic
        abstract RibbonGeometry: RibbonGeometryStatic
        abstract BoxGeometry: BoxGeometryStatic
        abstract SphereGeometry: SphereGeometryStatic
        abstract DiscGeometry: DiscGeometryStatic
        abstract CylinderGeometry: CylinderGeometryStatic
        abstract TorusGeometry: TorusGeometryStatic
        abstract GroundGeometry: GroundGeometryStatic
        abstract TiledGroundGeometry: TiledGroundGeometryStatic
        abstract PlaneGeometry: PlaneGeometryStatic
        abstract TorusKnotGeometry: TorusKnotGeometryStatic
        abstract GroundMesh: GroundMeshStatic
        abstract InstancedMesh: InstancedMeshStatic
        abstract LinesMesh: LinesMeshStatic
        abstract _InstancesBatch: _InstancesBatchStatic
        abstract Mesh: MeshStatic
        abstract VertexData: VertexDataStatic
        abstract MeshBuilder: MeshBuilderStatic
        abstract MeshLODLevel: MeshLODLevelStatic
        abstract SimplificationSettings: SimplificationSettingsStatic
        abstract SimplificationQueue: SimplificationQueueStatic
        abstract DecimationTriangle: DecimationTriangleStatic
        abstract DecimationVertex: DecimationVertexStatic
        abstract QuadraticMatrix: QuadraticMatrixStatic
        abstract Reference: ReferenceStatic
        abstract QuadraticErrorSimplification: QuadraticErrorSimplificationStatic
        abstract Polygon: PolygonStatic
        abstract PolygonMeshBuilder: PolygonMeshBuilderStatic
        abstract BaseSubMesh: BaseSubMeshStatic
        abstract SubMesh: SubMeshStatic
        abstract TransformNode: TransformNodeStatic
        abstract VertexBuffer: VertexBufferStatic
        abstract ReflectionProbe: ReflectionProbeStatic
        abstract BoundingBoxRenderer: BoundingBoxRendererStatic
        abstract DepthRenderer: DepthRendererStatic
        abstract EdgesRenderer: EdgesRendererStatic
        abstract GeometryBufferRenderer: GeometryBufferRendererStatic
        abstract OutlineRenderer: OutlineRendererStatic
        abstract RenderingGroup: RenderingGroupStatic
        abstract RenderingManager: RenderingManagerStatic
        abstract Sprite: SpriteStatic
        abstract SpriteManager: SpriteManagerStatic
        abstract _AlphaState: _AlphaStateStatic
        abstract _DepthCullingState: _DepthCullingStateStatic
        abstract _StencilState: _StencilStateStatic
        abstract AnaglyphPostProcess: AnaglyphPostProcessStatic
        abstract BlackAndWhitePostProcess: BlackAndWhitePostProcessStatic
        abstract BloomEffect: BloomEffectStatic
        abstract BloomMergePostProcess: BloomMergePostProcessStatic
        abstract BlurPostProcess: BlurPostProcessStatic
        abstract ChromaticAberrationPostProcess: ChromaticAberrationPostProcessStatic
        abstract CircleOfConfusionPostProcess: CircleOfConfusionPostProcessStatic
        abstract ColorCorrectionPostProcess: ColorCorrectionPostProcessStatic
        abstract ConvolutionPostProcess: ConvolutionPostProcessStatic
        abstract DepthOfFieldBlurPostProcess: DepthOfFieldBlurPostProcessStatic
        abstract DepthOfFieldEffect: DepthOfFieldEffectStatic
        abstract DepthOfFieldMergePostProcessOptions: DepthOfFieldMergePostProcessOptionsStatic
        abstract DepthOfFieldMergePostProcess: DepthOfFieldMergePostProcessStatic
        abstract DisplayPassPostProcess: DisplayPassPostProcessStatic
        abstract ExtractHighlightsPostProcess: ExtractHighlightsPostProcessStatic
        abstract FilterPostProcess: FilterPostProcessStatic
        abstract FxaaPostProcess: FxaaPostProcessStatic
        abstract GrainPostProcess: GrainPostProcessStatic
        abstract HighlightsPostProcess: HighlightsPostProcessStatic
        abstract ImageProcessingPostProcess: ImageProcessingPostProcessStatic
        abstract PassPostProcess: PassPostProcessStatic
        abstract PostProcess: PostProcessStatic
        abstract PostProcessManager: PostProcessManagerStatic
        abstract RefractionPostProcess: RefractionPostProcessStatic
        abstract SharpenPostProcess: SharpenPostProcessStatic
        abstract StereoscopicInterlacePostProcess: StereoscopicInterlacePostProcessStatic
        abstract TonemapPostProcess: TonemapPostProcessStatic
        abstract VolumetricLightScatteringPostProcess: VolumetricLightScatteringPostProcessStatic
        abstract VRDistortionCorrectionPostProcess: VRDistortionCorrectionPostProcessStatic
        abstract AndOrNotEvaluator: AndOrNotEvaluatorStatic
        abstract AbstractAssetTask: AbstractAssetTaskStatic
        abstract AssetsProgressEvent: AssetsProgressEventStatic
        abstract MeshAssetTask: MeshAssetTaskStatic
        abstract TextFileAssetTask: TextFileAssetTaskStatic
        abstract BinaryFileAssetTask: BinaryFileAssetTaskStatic
        abstract ImageAssetTask: ImageAssetTaskStatic
        abstract TextureAssetTask: TextureAssetTaskStatic
        abstract CubeTextureAssetTask: CubeTextureAssetTaskStatic
        abstract HDRCubeTextureAssetTask: HDRCubeTextureAssetTaskStatic
        abstract AssetsManager: AssetsManagerStatic
        abstract Database: DatabaseStatic
        abstract DDSTools: DDSToolsStatic
        abstract expandToProperty: callback: string * ?targetKey: Nullable<string> -> (obj option -> string -> unit)
        abstract serialize: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsTexture: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsColor3: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsFresnelParameters: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsVector2: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsVector3: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsMeshReference: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsColorCurves: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsColor4: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsImageProcessingConfiguration: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract serializeAsQuaternion: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        /// <summary>Decorator used to define property that can be serialized as reference to a camera</summary>
        /// <param name="sourceName">defines the name of the property to decorate</param>
        abstract serializeAsCameraReference: ?sourceName: string -> (obj option -> U2<string, Symbol> -> unit)
        abstract SerializationHelper: SerializationHelperStatic
        abstract Deferred: DeferredStatic
        abstract FilesInput: FilesInputStatic
        abstract KhronosTextureContainer: KhronosTextureContainerStatic
        abstract EventState: EventStateStatic
        abstract Observer: ObserverStatic
        abstract MultiObserver: MultiObserverStatic
        abstract Observable: ObservableStatic
        abstract PerformanceMonitor: PerformanceMonitorStatic
        abstract RollingAverage: RollingAverageStatic
        abstract PromisePolyfill: PromisePolyfillStatic
        abstract SceneOptimization: SceneOptimizationStatic
        abstract TextureOptimization: TextureOptimizationStatic
        abstract HardwareScalingOptimization: HardwareScalingOptimizationStatic
        abstract ShadowsOptimization: ShadowsOptimizationStatic
        abstract PostProcessesOptimization: PostProcessesOptimizationStatic
        abstract LensFlaresOptimization: LensFlaresOptimizationStatic
        abstract CustomOptimization: CustomOptimizationStatic
        abstract ParticlesOptimization: ParticlesOptimizationStatic
        abstract RenderTargetsOptimization: RenderTargetsOptimizationStatic
        abstract MergeMeshesOptimization: MergeMeshesOptimizationStatic
        abstract SceneOptimizerOptions: SceneOptimizerOptionsStatic
        abstract SceneOptimizer: SceneOptimizerStatic
        abstract SceneSerializer: SceneSerializerStatic
        abstract SmartArray: SmartArrayStatic
        abstract SmartArrayNoDuplicate: SmartArrayNoDuplicateStatic
        abstract StringDictionary: StringDictionaryStatic
        abstract Tags: TagsStatic
        abstract TextureTools: TextureToolsStatic
        abstract TGATools: TGAToolsStatic
        abstract LoadFileError: LoadFileErrorStatic
        abstract RetryStrategy: RetryStrategyStatic
        abstract Tools: ToolsStatic
        abstract PerfCounter: PerfCounterStatic
        /// <summary>Use this className as a decorator on a given class definition to add it a name and optionally its module.
        /// You can then use the Tools.getClassName(obj) on an instance to retrieve its class name.
        /// This method is the only way to get it done in all cases, even if the .js file declaring the class is minified</summary>
        /// <param name="name">The name of the class, case should be preserved</param>
        /// <param name="module">The name of the Module hosting the class, optional, but strongly recommended to specify if possible. Case should be preserved.</param>
        abstract className: name: string * ?``module``: string -> (Object -> unit)
        abstract AsyncLoop: AsyncLoopStatic
        abstract VirtualJoystick: VirtualJoystickStatic
        abstract WorkerPool: WorkerPoolStatic
        abstract AutoRotationBehavior: AutoRotationBehaviorStatic
        abstract BouncingBehavior: BouncingBehaviorStatic
        abstract FramingBehavior: FramingBehaviorStatic
        abstract ArcRotateCameraGamepadInput: ArcRotateCameraGamepadInputStatic
        abstract ArcRotateCameraKeyboardMoveInput: ArcRotateCameraKeyboardMoveInputStatic
        abstract ArcRotateCameraMouseWheelInput: ArcRotateCameraMouseWheelInputStatic
        abstract ArcRotateCameraPointersInput: ArcRotateCameraPointersInputStatic
        abstract ArcRotateCameraVRDeviceOrientationInput: ArcRotateCameraVRDeviceOrientationInputStatic
        abstract FreeCameraDeviceOrientationInput: FreeCameraDeviceOrientationInputStatic
        abstract FreeCameraGamepadInput: FreeCameraGamepadInputStatic
        abstract FreeCameraKeyboardMoveInput: FreeCameraKeyboardMoveInputStatic
        abstract FreeCameraMouseInput: FreeCameraMouseInputStatic
        abstract FreeCameraTouchInput: FreeCameraTouchInputStatic
        abstract FreeCameraVirtualJoystickInput: FreeCameraVirtualJoystickInputStatic
        abstract VRCameraMetrics: VRCameraMetricsStatic
        abstract VRDeviceOrientationFreeCamera: VRDeviceOrientationFreeCameraStatic
        abstract VRDeviceOrientationGamepadCamera: VRDeviceOrientationGamepadCameraStatic
        abstract VRDeviceOrientationArcRotateCamera: VRDeviceOrientationArcRotateCameraStatic
        abstract VRExperienceHelper: VRExperienceHelperStatic
        abstract WebVRFreeCamera: WebVRFreeCameraStatic
        abstract Octree: OctreeStatic
        abstract OctreeBlock: OctreeBlockStatic
        abstract DaydreamController: DaydreamControllerStatic
        abstract GearVRController: GearVRControllerStatic
        abstract GenericController: GenericControllerStatic
        abstract OculusTouchController: OculusTouchControllerStatic
        abstract PoseEnabledControllerHelper: PoseEnabledControllerHelperStatic
        abstract PoseEnabledController: PoseEnabledControllerStatic
        abstract ViveController: ViveControllerStatic
        abstract WebVRController: WebVRControllerStatic
        abstract WindowsMotionController: WindowsMotionControllerStatic
        abstract ShadowGenerator: ShadowGeneratorStatic
        abstract BackgroundMaterial: BackgroundMaterialStatic
        abstract PBRBaseMaterial: PBRBaseMaterialStatic
        abstract PBRBaseSimpleMaterial: PBRBaseSimpleMaterialStatic
        abstract PBRMaterial: PBRMaterialStatic
        abstract PBRMetallicRoughnessMaterial: PBRMetallicRoughnessMaterialStatic
        abstract PBRSpecularGlossinessMaterial: PBRSpecularGlossinessMaterialStatic
        abstract BaseTexture: BaseTextureStatic
        abstract ColorGradingTexture: ColorGradingTextureStatic
        abstract CubeTexture: CubeTextureStatic
        abstract DynamicTexture: DynamicTextureStatic
        abstract HDRCubeTexture: HDRCubeTextureStatic
        abstract InternalTexture: InternalTextureStatic
        abstract DummyInternalTextureTracker: DummyInternalTextureTrackerStatic
        abstract MirrorTexture: MirrorTextureStatic
        abstract MultiRenderTarget: MultiRenderTargetStatic
        abstract RawTexture: RawTextureStatic
        abstract RawTexture3D: RawTexture3DStatic
        abstract RefractionTexture: RefractionTextureStatic
        abstract RenderTargetTexture: RenderTargetTextureStatic
        abstract Texture: TextureStatic
        abstract VideoTexture: VideoTextureStatic
        abstract BoxParticleEmitter: BoxParticleEmitterStatic
        abstract ConeParticleEmitter: ConeParticleEmitterStatic
        abstract SphereParticleEmitter: SphereParticleEmitterStatic
        abstract SphereDirectedParticleEmitter: SphereDirectedParticleEmitterStatic
        abstract CannonJSPlugin: CannonJSPluginStatic
        abstract OimoJSPlugin: OimoJSPluginStatic
        abstract DracoCompression: DracoCompressionStatic
        abstract PostProcessRenderEffect: PostProcessRenderEffectStatic
        abstract PostProcessRenderPipeline: PostProcessRenderPipelineStatic
        abstract PostProcessRenderPipelineManager: PostProcessRenderPipelineManagerStatic
        abstract CubeMapToSphericalPolynomialTools: CubeMapToSphericalPolynomialToolsStatic
        abstract HDRTools: HDRToolsStatic
        abstract PanoramaToCubeMapTools: PanoramaToCubeMapToolsStatic
        abstract CustomProceduralTexture: CustomProceduralTextureStatic
        abstract ProceduralTexture: ProceduralTextureStatic
        abstract DefaultRenderingPipeline: DefaultRenderingPipelineStatic
        abstract LensRenderingPipeline: LensRenderingPipelineStatic
        abstract SSAO2RenderingPipeline: SSAO2RenderingPipelineStatic
        abstract SSAORenderingPipeline: SSAORenderingPipelineStatic
        abstract StandardRenderingPipeline: StandardRenderingPipelineStatic

    /// Set of assets to keep when moving a scene into an asset container.
    type [<AllowNullLiteral>] KeepAssets =
        /// Cameras to keep.
        abstract cameras: ResizeArray<Camera> with get, set
        /// Lights to keep.
        abstract lights: ResizeArray<Light> with get, set
        /// Meshes to keep.
        abstract meshes: ResizeArray<AbstractMesh> with get, set
        /// Skeletons to keep.
        abstract skeletons: ResizeArray<Skeleton> with get, set
        /// ParticleSystems to keep.
        abstract particleSystems: ResizeArray<IParticleSystem> with get, set
        /// Animations to keep.
        abstract animations: ResizeArray<Animation> with get, set
        /// AnimationGroups to keep.
        abstract animationGroups: ResizeArray<AnimationGroup> with get, set
        /// MultiMaterials to keep.
        abstract multiMaterials: ResizeArray<MultiMaterial> with get, set
        /// Materials to keep.
        abstract materials: ResizeArray<Material> with get, set
        /// MorphTargetManagers to keep.
        abstract morphTargetManagers: ResizeArray<MorphTargetManager> with get, set
        /// Geometries to keep.
        abstract geometries: ResizeArray<Geometry> with get, set
        /// TransformNodes to keep.
        abstract transformNodes: ResizeArray<TransformNode> with get, set
        /// LensFlareSystems to keep.
        abstract lensFlareSystems: ResizeArray<LensFlareSystem> with get, set
        /// ShadowGenerators to keep.
        abstract shadowGenerators: ResizeArray<ShadowGenerator> with get, set
        /// ActionManagers to keep.
        abstract actionManagers: ResizeArray<ActionManager> with get, set
        /// Sounds to keep.
        abstract sounds: ResizeArray<Sound> with get, set
        /// Textures to keep.
        abstract textures: ResizeArray<Texture> with get, set
        /// Effect layers to keep.
        abstract effectLayers: ResizeArray<EffectLayer> with get, set

    /// Set of assets to keep when moving a scene into an asset container.
    type [<AllowNullLiteral>] KeepAssetsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> KeepAssets

    /// Container with a set of assets that can be added or removed from a scene.
    type [<AllowNullLiteral>] AssetContainer =
        /// The scene the AssetContainer belongs to.
        abstract scene: Scene with get, set
        /// Cameras populated in the container.
        abstract cameras: ResizeArray<Camera> with get, set
        /// Lights populated in the container.
        abstract lights: ResizeArray<Light> with get, set
        /// Meshes populated in the container.
        abstract meshes: ResizeArray<AbstractMesh> with get, set
        /// Skeletons populated in the container.
        abstract skeletons: ResizeArray<Skeleton> with get, set
        /// ParticleSystems populated in the container.
        abstract particleSystems: ResizeArray<IParticleSystem> with get, set
        /// Animations populated in the container.
        abstract animations: ResizeArray<Animation> with get, set
        /// AnimationGroups populated in the container.
        abstract animationGroups: ResizeArray<AnimationGroup> with get, set
        /// MultiMaterials populated in the container.
        abstract multiMaterials: ResizeArray<MultiMaterial> with get, set
        /// Materials populated in the container.
        abstract materials: ResizeArray<Material> with get, set
        /// MorphTargetManagers populated in the container.
        abstract morphTargetManagers: ResizeArray<MorphTargetManager> with get, set
        /// Geometries populated in the container.
        abstract geometries: ResizeArray<Geometry> with get, set
        /// TransformNodes populated in the container.
        abstract transformNodes: ResizeArray<TransformNode> with get, set
        /// LensFlareSystems populated in the container.
        abstract lensFlareSystems: ResizeArray<LensFlareSystem> with get, set
        /// ShadowGenerators populated in the container.
        abstract shadowGenerators: ResizeArray<ShadowGenerator> with get, set
        /// ActionManagers populated in the container.
        abstract actionManagers: ResizeArray<ActionManager> with get, set
        /// Sounds populated in the container.
        abstract sounds: ResizeArray<Sound> with get, set
        /// Textures populated in the container.
        abstract textures: ResizeArray<Texture> with get, set
        /// Effect layers populated in the container.
        abstract effectLayers: ResizeArray<EffectLayer> with get, set
        /// Adds all the assets from the container to the scene.
        abstract addAllToScene: unit -> unit
        /// Removes all the assets in the container from the scene
        abstract removeAllFromScene: unit -> unit
        abstract _moveAssets: sourceAssets: obj * targetAssets: obj * keepAssets: obj -> unit
        /// <summary>Removes all the assets contained in the scene and adds them to the container.</summary>
        /// <param name="keepAssets">Set of assets to keep in the scene. (default: empty)</param>
        abstract moveAllFromScene: ?keepAssets: KeepAssets -> unit

    /// Container with a set of assets that can be added or removed from a scene.
    type [<AllowNullLiteral>] AssetContainerStatic =
        /// <summary>Instantiates an AssetContainer.</summary>
        /// <param name="scene">The scene the AssetContainer belongs to.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> AssetContainer

    /// Node is the basic class for all scene objects (Mesh, Light Camera).
    type [<AllowNullLiteral>] Node =
        /// Gets or sets the name of the node
        abstract name: string with get, set
        /// Gets or sets the id of the node
        abstract id: string with get, set
        /// Gets or sets the unique id of the node
        abstract uniqueId: float with get, set
        /// Gets or sets a string used to store user defined state for the node
        abstract state: string with get, set
        /// Gets or sets an object used to store user defined information for the node
        abstract metadata: obj option with get, set
        /// Gets or sets a boolean used to define if the node must be serialized
        abstract doNotSerialize: bool with get, set
        abstract _isDisposed: bool with get, set
        /// Gets a list of Animations associated with the node
        abstract animations: ResizeArray<Animation> with get, set
        abstract _ranges: obj with get, set
        /// Callback raised when the node is ready to be used
        abstract onReady: (Node -> unit) with get, set
        abstract _isEnabled: obj with get, set
        abstract _isReady: obj with get, set
        abstract _currentRenderId: float with get, set
        abstract _parentRenderId: obj with get, set
        abstract _childRenderId: float with get, set
        abstract _waitingParentId: Nullable<string> with get, set
        abstract _scene: obj with get, set
        abstract _cache: obj option with get, set
        abstract _parentNode: obj with get, set
        abstract _children: obj with get, set
        /// Gets a boolean indicating if the node has been disposed
        abstract isDisposed: unit -> bool
        /// Gets or sets the parent of the node
        abstract parent: Nullable<Node> with get, set
        abstract _animationPropertiesOverride: obj with get, set
        /// Gets or sets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride> with get, set
        /// Gets a string idenfifying the name of the class
        abstract getClassName: unit -> string
        /// An event triggered when the mesh is disposed
        abstract onDisposeObservable: Observable<Node> with get, set
        abstract _onDisposeObserver: obj with get, set
        /// Sets a callback that will be raised when the node will be disposed
        abstract onDispose: (unit -> unit) with get, set
        /// Gets the scene of the node
        abstract getScene: unit -> Scene
        /// Gets the engine of the node
        abstract getEngine: unit -> Engine
        abstract _behaviors: obj with get, set
        /// <summary>Attach a behavior to the node</summary>
        /// <param name="behavior">defines the behavior to attach</param>
        abstract addBehavior: behavior: Behavior<Node> -> Node
        /// <summary>Remove an attached behavior</summary>
        /// <param name="behavior">defines the behavior to attach</param>
        abstract removeBehavior: behavior: Behavior<Node> -> Node
        /// Gets the list of attached behaviors
        abstract behaviors: ResizeArray<Behavior<Node>>
        /// <summary>Gets an attached behavior by name</summary>
        /// <param name="name">defines the name of the behavior to look for</param>
        abstract getBehaviorByName: name: string -> Nullable<Behavior<Node>>
        /// Returns the world matrix of the node
        abstract getWorldMatrix: unit -> Matrix
        abstract _initCache: unit -> unit
        abstract updateCache: ?force: bool -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _isSynchronized: unit -> bool
        abstract _markSyncedWithParent: unit -> unit
        abstract isSynchronizedWithParent: unit -> bool
        abstract isSynchronized: ?updateCache: bool -> bool
        abstract hasNewParent: ?update: bool -> bool
        /// <summary>Is this node ready to be used/rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including materials and lights) has to be done (false by default)</param>
        abstract isReady: ?completeCheck: bool -> bool
        /// <summary>Is this node enabled?
        /// If the node has a parent, all ancestors will be checked and false will be returned if any are false (not enabled), otherwise will return true</summary>
        /// <param name="checkAncestors">indicates if this method should check the ancestors. The default is to check the ancestors. If set to false, the method will return the value of this node without checking ancestors</param>
        abstract isEnabled: ?checkAncestors: bool -> bool
        /// <summary>Set the enabled state of this node</summary>
        /// <param name="value">defines the new enabled state</param>
        abstract setEnabled: value: bool -> unit
        /// <summary>Is this node a descendant of the given node?
        /// The function will iterate up the hierarchy until the ancestor was found or no more parents defined</summary>
        /// <param name="ancestor">defines the parent node to inspect</param>
        abstract isDescendantOf: ancestor: Node -> bool
        abstract _getDescendants: results: ResizeArray<Node> * ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> unit
        /// <summary>Will return all nodes that have this node as ascendant</summary>
        /// <param name="directDescendantsOnly">defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered</param>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getDescendants: ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> ResizeArray<Node>
        /// <summary>Get all child-meshes of this node</summary>
        /// <param name="directDescendantsOnly">defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered</param>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getChildMeshes: ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> ResizeArray<AbstractMesh>
        /// <summary>Get all child-transformNodes of this node</summary>
        /// <param name="directDescendantsOnly">defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered</param>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getChildTransformNodes: ?directDescendantsOnly: bool * ?predicate: (Node -> bool) -> ResizeArray<TransformNode>
        /// <summary>Get all direct children of this node</summary>
        /// <param name="predicate">defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored</param>
        abstract getChildren: ?predicate: (Node -> bool) -> ResizeArray<Node>
        abstract _setReady: state: bool -> unit
        /// <summary>Get an animation by name</summary>
        /// <param name="name">defines the name of the animation to look for</param>
        abstract getAnimationByName: name: string -> Nullable<Animation>
        /// <summary>Creates an animation range for this node</summary>
        /// <param name="name">defines the name of the range</param>
        /// <param name="from">defines the starting key</param>
        /// <param name="to">defines the end key</param>
        abstract createAnimationRange: name: string * from: float * ``to``: float -> unit
        /// <summary>Delete a specific animation range</summary>
        /// <param name="name">defines the name of the range to delete</param>
        /// <param name="deleteFrames">defines if animation frames from the range must be deleted as well</param>
        abstract deleteAnimationRange: name: string * ?deleteFrames: bool -> unit
        /// <summary>Get an animation range by name</summary>
        /// <param name="name">defines the name of the animation range to look for</param>
        abstract getAnimationRange: name: string -> Nullable<AnimationRange>
        /// <summary>Will start the animation sequence</summary>
        /// <param name="name">defines the range frames for animation sequence</param>
        /// <param name="loop">defines if the animation should loop (false by default)</param>
        /// <param name="speedRatio">defines the speed factor in which to run the animation (1 by default)</param>
        /// <param name="onAnimationEnd">defines a function to be executed when the animation ended (undefined by default)</param>
        abstract beginAnimation: name: string * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        /// Serialize animation ranges into a JSON compatible object
        abstract serializeAnimationRanges: unit -> obj option
        /// <summary>Computes the world matrix of the node</summary>
        /// <param name="force">defines if the cache version should be invalidated forcing the world matrix to be created from scratch</param>
        abstract computeWorldMatrix: ?force: bool -> Matrix
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// Node is the basic class for all scene objects (Mesh, Light Camera).
    type [<AllowNullLiteral>] NodeStatic =
        /// <summary>Creates a new Node</summary>
        /// <param name="name">- the name and id to be given to this node</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Nullable<Scene> -> Node
        /// <summary>Parse animation range data from a serialization object and store them into a given node</summary>
        /// <param name="node">defines where to store the animation ranges</param>
        /// <param name="parsedNode">defines the serialization object to read data from</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ParseAnimationRanges: node: Node * parsedNode: obj option * scene: Scene -> unit

    /// Define an interface for all classes that will hold resources
    type [<AllowNullLiteral>] IDisposable =
        /// Releases all held resources
        abstract dispose: unit -> unit

    /// Interface used to let developers provide their own mesh selection mechanism
    type [<AllowNullLiteral>] IActiveMeshCandidateProvider =
        /// <summary>Return the list of active meshes</summary>
        /// <param name="scene">defines the current scene</param>
        abstract getMeshes: scene: Scene -> ResizeArray<AbstractMesh>
        /// Indicates if the meshes have been checked to make sure they are isEnabled()
        abstract checksIsEnabled: bool

    /// This class is used by the onRenderingGroupObservable
    type [<AllowNullLiteral>] RenderingGroupInfo =
        /// The Scene that being rendered
        abstract scene: Scene with get, set
        /// The camera currently used for the rendering pass
        abstract camera: Nullable<Camera> with get, set
        /// The ID of the renderingGroup being processed
        abstract renderingGroupId: float with get, set
        /// The rendering stage, can be either STAGE_PRECLEAR, STAGE_PREOPAQUE, STAGE_PRETRANSPARENT, STAGE_POSTTRANSPARENT
        abstract renderStage: float with get, set
        /// Stage corresponding to the very first hook in the renderingGroup phase: before the render buffer may be cleared
        /// This stage will be fired no matter what
        abstract STAGE_PRECLEAR: float with get, set
        /// Called before opaque object are rendered.
        /// This stage will be fired only if there's 3D Opaque content to render
        abstract STAGE_PREOPAQUE: float with get, set
        /// Called after the opaque objects are rendered and before the transparent ones
        /// This stage will be fired only if there's 3D transparent content to render
        abstract STAGE_PRETRANSPARENT: float with get, set
        /// Called after the transparent object are rendered, last hook of the renderingGroup phase
        /// This stage will be fired no matter what
        abstract STAGE_POSTTRANSPARENT: float with get, set

    /// This class is used by the onRenderingGroupObservable
    type [<AllowNullLiteral>] RenderingGroupInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RenderingGroupInfo

    /// Represents a scene to be rendered by the engine.
    type [<AllowNullLiteral>] Scene =
        inherit IAnimatable
        abstract _FOGMODE_NONE: obj with get, set
        abstract _FOGMODE_EXP: obj with get, set
        abstract _FOGMODE_EXP2: obj with get, set
        abstract _FOGMODE_LINEAR: obj with get, set
        abstract _uniqueIdCounter: obj with get, set
        /// Gets or sets the minimum deltatime when deterministic lock step is enabled
        abstract MinDeltaTime: float with get, set
        /// Gets or sets the maximum deltatime when deterministic lock step is enabled
        abstract MaxDeltaTime: float with get, set
        /// The fog is deactivated 
        abstract FOGMODE_NONE: float
        /// The fog density is following an exponential function 
        abstract FOGMODE_EXP: float
        /// The fog density is following an exponential function faster than FOGMODE_EXP 
        abstract FOGMODE_EXP2: float
        /// The fog density is following a linear function. 
        abstract FOGMODE_LINEAR: float
        /// Gets or sets a boolean that indicates if the scene must clear the render buffer before rendering a frame
        abstract autoClear: bool with get, set
        /// Gets or sets a boolean that indicates if the scene must clear the depth and stencil buffers before rendering a frame
        abstract autoClearDepthAndStencil: bool with get, set
        /// Defines the color used to clear the render buffer (Default is (0.2, 0.2, 0.3, 1.0))
        abstract clearColor: Color4 with get, set
        /// Defines the color used to simulate the ambient color (Default is (0, 0, 0))
        abstract ambientColor: Color3 with get, set
        abstract _environmentBRDFTexture: BaseTexture with get, set
        abstract _environmentTexture: BaseTexture with get, set
        /// Texture used in all pbr material as the reflection texture.
        /// As in the majority of the scene they are the same (exception for multi room and so on),
        /// this is easier to reference from here than from all the materials.
        /// Texture used in all pbr material as the reflection texture.
        /// As in the majority of the scene they are the same (exception for multi room and so on),
        /// this is easier to set here than in all the materials.
        abstract environmentTexture: BaseTexture with get, set
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Default image processing configuration used either in the rendering
        /// Forward main pass or through the imageProcessingPostProcess if present.
        /// As in the majority of the scene they are the same (exception for multi camera),
        /// this is easier to reference from here than from all the materials and post process.
        /// 
        /// No setter as we it is a shared configuration, you can set the values instead.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration
        abstract _forceWireframe: obj with get, set
        /// Gets or sets a boolean indicating if all rendering must be done in wireframe
        abstract forceWireframe: bool with get, set
        abstract _forcePointsCloud: obj with get, set
        /// Gets or sets a boolean indicating if all rendering must be done in point cloud
        abstract forcePointsCloud: bool with get, set
        /// Gets or sets a boolean indicating if all bounding boxes must be rendered
        abstract forceShowBoundingBoxes: bool with get, set
        /// Gets or sets the active clipplane
        abstract clipPlane: Nullable<Plane> with get, set
        /// Gets or sets a boolean indicating if animations are enabled
        abstract animationsEnabled: bool with get, set
        abstract _animationPropertiesOverride: obj with get, set
        /// Gets or sets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride> with get, set
        /// Gets or sets a boolean indicating if a constant deltatime has to be used
        /// This is mostly useful for testing purposes when you do not want the animations to scale with the framerate
        abstract useConstantAnimationDeltaTime: bool with get, set
        /// Gets or sets a boolean indicating if the scene must keep the meshUnderPointer property updated
        /// Please note that it requires to run a ray cast through the scene on every frame
        abstract constantlyUpdateMeshUnderPointer: bool with get, set
        /// Defines the HTML cursor to use when hovering over interactive elements
        abstract hoverCursor: string with get, set
        /// Defines the HTML default cursor to use (empty by default)
        abstract defaultCursor: string with get, set
        /// This is used to call preventDefault() on pointer down
        /// in order to block unwanted artifacts like system double clicks
        abstract preventDefaultOnPointerDown: bool with get, set
        /// Gets or sets user defined metadata
        abstract metadata: obj option with get, set
        /// Gets the name of the plugin used to load this scene (null by default)
        abstract loadingPluginName: string with get, set
        /// Use this array to add regular expressions used to disable offline support for specific urls
        abstract disableOfflineSupportExceptionRules: ResizeArray<RegExp> with get, set
        abstract _spritePredicate: obj with get, set
        /// An event triggered when the scene is disposed.
        abstract onDisposeObservable: Observable<Scene> with get, set
        abstract _onDisposeObserver: obj with get, set
        /// Sets a function to be executed when this scene is disposed. 
        abstract onDispose: (unit -> unit) with get, set
        /// An event triggered before rendering the scene (right after animations and physics)
        abstract onBeforeRenderObservable: Observable<Scene> with get, set
        abstract _onBeforeRenderObserver: obj with get, set
        /// Sets a function to be executed before rendering this scene 
        abstract beforeRender: Nullable<(unit -> unit)> with get, set
        /// An event triggered after rendering the scene
        abstract onAfterRenderObservable: Observable<Scene> with get, set
        abstract _onAfterRenderObserver: obj with get, set
        /// Sets a function to be executed after rendering this scene 
        abstract afterRender: Nullable<(unit -> unit)> with get, set
        /// An event triggered before animating the scene
        abstract onBeforeAnimationsObservable: Observable<Scene> with get, set
        /// An event triggered after animations processing
        abstract onAfterAnimationsObservable: Observable<Scene> with get, set
        /// An event triggered before draw calls are ready to be sent
        abstract onBeforeDrawPhaseObservable: Observable<Scene> with get, set
        /// An event triggered after draw calls have been sent
        abstract onAfterDrawPhaseObservable: Observable<Scene> with get, set
        /// An event triggered when physic simulation is about to be run
        abstract onBeforePhysicsObservable: Observable<Scene> with get, set
        /// An event triggered when physic simulation has been done
        abstract onAfterPhysicsObservable: Observable<Scene> with get, set
        /// An event triggered when the scene is ready
        abstract onReadyObservable: Observable<Scene> with get, set
        /// An event triggered before rendering a camera
        abstract onBeforeCameraRenderObservable: Observable<Camera> with get, set
        abstract _onBeforeCameraRenderObserver: obj with get, set
        /// Sets a function to be executed before rendering a camera
        abstract beforeCameraRender: (unit -> unit) with get, set
        /// An event triggered after rendering a camera
        abstract onAfterCameraRenderObservable: Observable<Camera> with get, set
        abstract _onAfterCameraRenderObserver: obj with get, set
        /// Sets a function to be executed after rendering a camera
        abstract afterCameraRender: (unit -> unit) with get, set
        /// An event triggered when active meshes evaluation is about to start
        abstract onBeforeActiveMeshesEvaluationObservable: Observable<Scene> with get, set
        /// An event triggered when active meshes evaluation is done
        abstract onAfterActiveMeshesEvaluationObservable: Observable<Scene> with get, set
        /// An event triggered when particles rendering is about to start
        /// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        abstract onBeforeParticlesRenderingObservable: Observable<Scene> with get, set
        /// An event triggered when particles rendering is done
        /// Note: This event can be trigger more than once per frame (because particles can be rendered by render target textures as well)
        abstract onAfterParticlesRenderingObservable: Observable<Scene> with get, set
        /// An event triggered when sprites rendering is about to start
        /// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
        abstract onBeforeSpritesRenderingObservable: Observable<Scene> with get, set
        /// An event triggered when sprites rendering is done
        /// Note: This event can be trigger more than once per frame (because sprites can be rendered by render target textures as well)
        abstract onAfterSpritesRenderingObservable: Observable<Scene> with get, set
        /// An event triggered when SceneLoader.Append or SceneLoader.Load or SceneLoader.ImportMesh were successfully executed
        abstract onDataLoadedObservable: Observable<Scene> with get, set
        /// An event triggered when a camera is created
        abstract onNewCameraAddedObservable: Observable<Camera> with get, set
        /// An event triggered when a camera is removed
        abstract onCameraRemovedObservable: Observable<Camera> with get, set
        /// An event triggered when a light is created
        abstract onNewLightAddedObservable: Observable<Light> with get, set
        /// An event triggered when a light is removed
        abstract onLightRemovedObservable: Observable<Light> with get, set
        /// An event triggered when a geometry is created
        abstract onNewGeometryAddedObservable: Observable<Geometry> with get, set
        /// An event triggered when a geometry is removed
        abstract onGeometryRemovedObservable: Observable<Geometry> with get, set
        /// An event triggered when a transform node is created
        abstract onNewTransformNodeAddedObservable: Observable<TransformNode> with get, set
        /// An event triggered when a transform node is removed
        abstract onTransformNodeRemovedObservable: Observable<TransformNode> with get, set
        /// An event triggered when a mesh is created
        abstract onNewMeshAddedObservable: Observable<AbstractMesh> with get, set
        /// An event triggered when a mesh is removed
        abstract onMeshRemovedObservable: Observable<AbstractMesh> with get, set
        /// An event triggered when render targets are about to be rendered
        /// Can happen multiple times per frame.
        abstract onBeforeRenderTargetsRenderObservable: Observable<Scene> with get, set
        /// An event triggered when render targets were rendered.
        /// Can happen multiple times per frame.
        abstract onAfterRenderTargetsRenderObservable: Observable<Scene> with get, set
        /// An event triggered before calculating deterministic simulation step
        abstract onBeforeStepObservable: Observable<Scene> with get, set
        /// An event triggered after calculating deterministic simulation step
        abstract onAfterStepObservable: Observable<Scene> with get, set
        /// This Observable will be triggered for each stage of each renderingGroup of each rendered camera.
        /// The RenderinGroupInfo class contains all the information about the context in which the observable is called
        /// If you wish to register an Observer only for a given set of renderingGroup, use the mask with a combination of the renderingGroup index elevated to the power of two (1 for renderingGroup 0, 2 for renderingrOup1, 4 for 2 and 8 for 3)
        abstract onRenderingGroupObservable: Observable<RenderingGroupInfo> with get, set
        /// Gets a list of Animations associated with the scene
        abstract animations: ResizeArray<Animation> with get, set
        abstract _registeredForLateAnimationBindings: obj with get, set
        /// Gets or sets a predicate used to select candidate meshes for a pointer down event
        abstract pointerDownPredicate: (AbstractMesh -> bool) with get, set
        /// Gets or sets a predicate used to select candidate meshes for a pointer up event
        abstract pointerUpPredicate: (AbstractMesh -> bool) with get, set
        /// Gets or sets a predicate used to select candidate meshes for a pointer move event
        abstract pointerMovePredicate: (AbstractMesh -> bool) with get, set
        abstract _onPointerMove: obj with get, set
        abstract _onPointerDown: obj with get, set
        abstract _onPointerUp: obj with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerMove: (PointerEvent -> PickingInfo -> PointerEventTypes -> unit) with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerDown: (PointerEvent -> PickingInfo -> PointerEventTypes -> unit) with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerUp: (PointerEvent -> Nullable<PickingInfo> -> PointerEventTypes -> unit) with get, set
        /// Deprecated. Use onPointerObservable instead 
        abstract onPointerPick: (PointerEvent -> PickingInfo -> unit) with get, set
        abstract _gamepadManager: obj with get, set
        /// Gets the gamepad manager associated with the scene
        abstract gamepadManager: GamepadManager
        /// This observable event is triggered when any ponter event is triggered. It is registered during Scene.attachControl() and it is called BEFORE the 3D engine process anything (mesh/sprite picking for instance).
        /// You have the possibility to skip the process and the call to onPointerObservable by setting PointerInfoPre.skipOnPointerObservable to true
        abstract onPrePointerObservable: Observable<PointerInfoPre> with get, set
        /// Observable event triggered each time an input event is received from the rendering canvas
        abstract onPointerObservable: Observable<PointerInfo> with get, set
        /// Gets the pointer coordinates without any translation (ie. straight out of the pointer event)
        abstract unTranslatedPointer: Vector2
        /// The distance in pixel that you have to move to prevent some events 
        abstract DragMovementThreshold: float with get, set
        /// Time in milliseconds to wait to raise long press events if button is still pressed 
        abstract LongPressDelay: float with get, set
        /// Time in milliseconds with two consecutive clicks will be considered as a double click 
        abstract DoubleClickDelay: float with get, set
        /// If you need to check double click without raising a single click at first click, enable this flag 
        abstract ExclusiveDoubleClickMode: bool with get, set
        abstract _initClickEvent: obj with get, set
        abstract _initActionManager: obj with get, set
        abstract _delayedSimpleClick: obj with get, set
        abstract _delayedSimpleClickTimeout: obj with get, set
        abstract _previousDelayedSimpleClickTimeout: obj with get, set
        abstract _meshPickProceed: obj with get, set
        abstract _previousButtonPressed: obj with get, set
        abstract _currentPickResult: obj with get, set
        abstract _previousPickResult: obj with get, set
        abstract _totalPointersPressed: obj with get, set
        abstract _doubleClickOccured: obj with get, set
        /// Define this parameter if you are using multiple cameras and you want to specify which one should be used for pointer position 
        abstract cameraToUseForPointers: Nullable<Camera> with get, set
        abstract _pointerX: obj with get, set
        abstract _pointerY: obj with get, set
        abstract _unTranslatedPointerX: obj with get, set
        abstract _unTranslatedPointerY: obj with get, set
        abstract _startingPointerPosition: obj with get, set
        abstract _previousStartingPointerPosition: obj with get, set
        abstract _startingPointerTime: obj with get, set
        abstract _previousStartingPointerTime: obj with get, set
        abstract _timeAccumulator: obj with get, set
        abstract _currentStepId: obj with get, set
        abstract _currentInternalStep: obj with get, set
        abstract _mirroredCameraPosition: Nullable<Vector3> with get, set
        /// This observable event is triggered when any keyboard event si raised and registered during Scene.attachControl()
        /// You have the possibility to skip the process and the call to onKeyboardObservable by setting KeyboardInfoPre.skipOnPointerObservable to true
        abstract onPreKeyboardObservable: Observable<KeyboardInfoPre> with get, set
        /// Observable event triggered each time an keyboard event is received from the hosting window
        abstract onKeyboardObservable: Observable<KeyboardInfo> with get, set
        abstract _onKeyDown: obj with get, set
        abstract _onKeyUp: obj with get, set
        abstract _onCanvasFocusObserver: obj with get, set
        abstract _onCanvasBlurObserver: obj with get, set
        abstract _useRightHandedSystem: obj with get, set
        /// Gets or sets a boolean indicating if the scene must use right-handed coordinates system
        abstract useRightHandedSystem: bool with get, set
        /// <summary>Sets the step Id used by deterministic lock step</summary>
        /// <param name="newStepId">defines the step Id</param>
        abstract setStepId: newStepId: float -> unit
        /// Gets the step Id used by deterministic lock step
        abstract getStepId: unit -> float
        /// Gets the internal step used by deterministic lock step
        abstract getInternalStep: unit -> float
        abstract _fogEnabled: obj with get, set
        /// Gets or sets a boolean indicating if fog is enabled on this scene
        abstract fogEnabled: bool with get, set
        abstract _fogMode: obj with get, set
        /// Gets or sets the fog mode to use
        abstract fogMode: float with get, set
        /// Gets or sets the fog color to use
        abstract fogColor: Color3 with get, set
        /// Gets or sets the fog density to use
        abstract fogDensity: float with get, set
        /// Gets or sets the fog start distance to use
        abstract fogStart: float with get, set
        /// Gets or sets the fog end distance to use
        abstract fogEnd: float with get, set
        abstract _shadowsEnabled: obj with get, set
        /// Gets or sets a boolean indicating if shadows are enabled on this scene
        abstract shadowsEnabled: bool with get, set
        abstract _lightsEnabled: obj with get, set
        /// Gets or sets a boolean indicating if lights are enabled on this scene
        abstract lightsEnabled: bool with get, set
        /// All of the lights added to this scene
        abstract lights: ResizeArray<Light> with get, set
        /// All of the cameras added to this scene.
        abstract cameras: ResizeArray<Camera> with get, set
        /// All of the active cameras added to this scene. 
        abstract activeCameras: ResizeArray<Camera> with get, set
        /// The current active camera 
        abstract activeCamera: Nullable<Camera> with get, set
        /// All of the tranform nodes added to this scene
        abstract transformNodes: ResizeArray<TransformNode> with get, set
        /// All of the (abstract) meshes added to this scene
        abstract meshes: ResizeArray<AbstractMesh> with get, set
        /// All of the animation groups added to this scene
        abstract animationGroups: ResizeArray<AnimationGroup> with get, set
        abstract _geometries: obj with get, set
        /// All of the materials added to this scene
        abstract materials: ResizeArray<Material> with get, set
        /// All of the multi-materials added to this scene
        abstract multiMaterials: ResizeArray<MultiMaterial> with get, set
        abstract _defaultMaterial: obj with get, set
        /// The default material used on meshes when no material is affected 
        /// The default material used on meshes when no material is affected 
        abstract defaultMaterial: Material with get, set
        abstract _texturesEnabled: obj with get, set
        /// Gets or sets a boolean indicating if textures are enabled on this scene
        abstract texturesEnabled: bool with get, set
        /// All of the textures added to this scene
        abstract textures: ResizeArray<BaseTexture> with get, set
        /// Gets or sets a boolean indicating if particles are enabled on this scene
        abstract particlesEnabled: bool with get, set
        /// All of the particle systems added to this scene
        abstract particleSystems: ResizeArray<IParticleSystem> with get, set
        /// Gets or sets a boolean indicating if sprites are enabled on this scene
        abstract spritesEnabled: bool with get, set
        /// All of the sprite managers added to this scene
        abstract spriteManagers: ResizeArray<SpriteManager> with get, set
        /// The list of layers (background and foreground) of the scene
        abstract layers: ResizeArray<Layer> with get, set
        /// The list of effect layers (highlights/glow) added to the scene
        abstract effectLayers: ResizeArray<EffectLayer> with get, set
        abstract _skeletonsEnabled: obj with get, set
        /// Gets or sets a boolean indicating if skeletons are enabled on this scene
        abstract skeletonsEnabled: bool with get, set
        /// The list of skeletons added to the scene
        abstract skeletons: ResizeArray<Skeleton> with get, set
        /// The list of morph target managers added to the scene
        abstract morphTargetManagers: ResizeArray<MorphTargetManager> with get, set
        /// Gets or sets a boolean indicating if lens flares are enabled on this scene
        abstract lensFlaresEnabled: bool with get, set
        /// The list of lens flare system added to the scene
        abstract lensFlareSystems: ResizeArray<LensFlareSystem> with get, set
        /// Gets or sets a boolean indicating if collisions are enabled on this scene
        abstract collisionsEnabled: bool with get, set
        abstract _workerCollisions: obj with get, set
        abstract collisionCoordinator: ICollisionCoordinator with get, set
        /// Defines the gravity applied to this scene (used only for collisions)
        abstract gravity: Vector3 with get, set
        /// Gets or sets a boolean indicating if postprocesses are enabled on this scene
        abstract postProcessesEnabled: bool with get, set
        /// The list of postprocesses added to the scene
        abstract postProcesses: ResizeArray<PostProcess> with get, set
        /// Gets the current postprocess manager
        abstract postProcessManager: PostProcessManager with get, set
        abstract _postProcessRenderPipelineManager: obj with get, set
        /// Gets the postprocess render pipeline manager
        abstract postProcessRenderPipelineManager: PostProcessRenderPipelineManager
        /// Gets or sets a boolean indicating if render targets are enabled on this scene
        abstract renderTargetsEnabled: bool with get, set
        /// Gets or sets a boolean indicating if next render targets must be dumped as image for debugging purposes
        /// We recommend not using it and instead rely on Spector.js: http://spector.babylonjs.com
        abstract dumpNextRenderTargets: bool with get, set
        /// The list of user defined render targets added to the scene
        abstract customRenderTargets: ResizeArray<RenderTargetTexture> with get, set
        /// Defines if texture loading must be delayed
        /// If true, textures will only be loaded when they need to be rendered
        abstract useDelayedTextureLoading: bool with get, set
        /// Gets the list of meshes imported to the scene through SceneLoader
        abstract importedMeshesFiles: ResizeArray<String> with get, set
        /// Gets or sets a boolean indicating if probes are enabled on this scene
        abstract probesEnabled: bool with get, set
        /// The list of reflection probes added to the scene
        abstract reflectionProbes: ResizeArray<ReflectionProbe> with get, set
        abstract database: Database with get, set
        /// Gets or sets the action manager associated with the scene
        abstract actionManager: ActionManager with get, set
        abstract _actionManagers: ResizeArray<ActionManager> with get, set
        abstract _meshesForIntersections: obj with get, set
        /// Gets or sets a boolean indicating if procedural textures are enabled on this scene
        abstract proceduralTexturesEnabled: bool with get, set
        /// The list of procedural textures added to the scene
        abstract proceduralTextures: ResizeArray<ProceduralTexture> with get, set
        abstract _mainSoundTrack: obj with get, set
        /// The list of sound tracks added to the scene
        abstract soundTracks: ResizeArray<SoundTrack> with get, set
        abstract _audioEnabled: obj with get, set
        abstract _headphone: obj with get, set
        /// Gets the main soundtrack associated with the scene
        abstract mainSoundTrack: SoundTrack
        /// Gets or sets the VRExperienceHelper attached to the scene
        abstract VRHelper: VRExperienceHelper with get, set
        /// Gets or sets the simplification queue attached to the scene
        abstract simplificationQueue: SimplificationQueue with get, set
        abstract _engine: obj with get, set
        abstract _totalVertices: obj with get, set
        abstract _activeIndices: PerfCounter with get, set
        abstract _activeParticles: PerfCounter with get, set
        abstract _activeBones: PerfCounter with get, set
        abstract _animationRatio: obj with get, set
        abstract _animationTimeLast: obj with get, set
        abstract _animationTime: obj with get, set
        /// Gets or sets a general scale for animation speed
        abstract animationTimeScale: float with get, set
        abstract _cachedMaterial: Nullable<Material> with get, set
        abstract _cachedEffect: Nullable<Effect> with get, set
        abstract _cachedVisibility: Nullable<float> with get, set
        abstract _renderId: obj with get, set
        abstract _executeWhenReadyTimeoutId: obj with get, set
        abstract _intermediateRendering: obj with get, set
        abstract _viewUpdateFlag: obj with get, set
        abstract _projectionUpdateFlag: obj with get, set
        abstract _alternateViewUpdateFlag: obj with get, set
        abstract _alternateProjectionUpdateFlag: obj with get, set
        abstract _toBeDisposed: SmartArray<Nullable<IDisposable>> with get, set
        abstract _activeRequests: obj with get, set
        abstract _pendingData: obj with get, set
        abstract _isDisposed: obj with get, set
        /// Gets or sets a boolean indicating that all submeshes of active meshes must be rendered
        /// Use this boolean to avoid computing frustum clipping on submeshes (This could help when you are CPU bound)
        abstract dispatchAllSubMeshesOfActiveMeshes: bool with get, set
        abstract _activeMeshes: obj with get, set
        abstract _processedMaterials: obj with get, set
        abstract _renderTargets: obj with get, set
        abstract _activeParticleSystems: SmartArray<IParticleSystem> with get, set
        abstract _activeSkeletons: obj with get, set
        abstract _softwareSkinnedMeshes: obj with get, set
        abstract _renderingManager: obj with get, set
        abstract _physicsEngine: obj with get, set
        abstract _activeAnimatables: ResizeArray<Animatable> with get, set
        abstract _transformMatrix: obj with get, set
        abstract _sceneUbo: obj with get, set
        abstract _alternateSceneUbo: obj with get, set
        abstract _pickWithRayInverseMatrix: obj with get, set
        abstract _boundingBoxRenderer: obj with get, set
        abstract _outlineRenderer: obj with get, set
        abstract _viewMatrix: obj with get, set
        abstract _projectionMatrix: obj with get, set
        abstract _alternateViewMatrix: obj with get, set
        abstract _alternateProjectionMatrix: obj with get, set
        abstract _alternateTransformMatrix: obj with get, set
        abstract _useAlternateCameraConfiguration: obj with get, set
        abstract _alternateRendering: obj with get, set
        abstract _forcedViewPosition: Nullable<Vector3> with get, set
        abstract _isAlternateRenderingEnabled: bool
        abstract _frustumPlanes: obj with get, set
        /// Gets the list of frustum planes (built from the active camera)
        abstract frustumPlanes: ResizeArray<Plane>
        /// Gets or sets a boolean indicating if lights must be sorted by priority (off by default)
        /// This is useful if there are more lights that the maximum simulteanous authorized
        abstract requireLightSorting: bool with get, set
        abstract _selectionOctree: obj with get, set
        abstract _pointerOverMesh: obj with get, set
        abstract _pointerOverSprite: obj with get, set
        abstract _debugLayer: obj with get, set
        abstract _depthRenderer: obj with get, set
        abstract _geometryBufferRenderer: obj with get, set
        /// Gets the current geometry buffer associated to the scene.
        /// Sets the current geometry buffer for the scene.
        abstract geometryBufferRenderer: Nullable<GeometryBufferRenderer> with get, set
        abstract _pickedDownMesh: obj with get, set
        abstract _pickedUpMesh: obj with get, set
        abstract _pickedDownSprite: obj with get, set
        abstract _externalData: obj with get, set
        abstract _uid: obj with get, set
        /// Gets the debug layer associated with the scene
        abstract debugLayer: DebugLayer
        /// Gets a boolean indicating if collisions are processed on a web worker
        abstract workerCollisions: bool with get, set
        /// Gets the octree used to boost mesh selection (picking)
        abstract selectionOctree: Octree<AbstractMesh>
        /// Gets the mesh that is currently under the pointer
        abstract meshUnderPointer: Nullable<AbstractMesh>
        /// Gets the current on-screen X position of the pointer
        abstract pointerX: float
        /// Gets the current on-screen Y position of the pointer
        abstract pointerY: float
        /// Gets the cached material (ie. the latest rendered one)
        abstract getCachedMaterial: unit -> Nullable<Material>
        /// Gets the cached effect (ie. the latest rendered one)
        abstract getCachedEffect: unit -> Nullable<Effect>
        /// Gets the cached visibility state (ie. the latest rendered one)
        abstract getCachedVisibility: unit -> Nullable<float>
        /// <summary>Gets a boolean indicating if the current material / effect / visibility must be bind again</summary>
        /// <param name="material">defines the current material</param>
        /// <param name="effect">defines the current effect</param>
        /// <param name="visibility">defines the current visibility state</param>
        abstract isCachedMaterialInvalid: material: Material * effect: Effect * ?visibility: float -> bool
        /// Gets the bounding box renderer associated with the scene
        abstract getBoundingBoxRenderer: unit -> BoundingBoxRenderer
        /// Gets the outline renderer associated with the scene
        abstract getOutlineRenderer: unit -> OutlineRenderer
        /// Gets the engine associated with the scene
        abstract getEngine: unit -> Engine
        /// Gets the total number of vertices rendered per frame
        abstract getTotalVertices: unit -> float
        /// Gets the performance counter for total vertices
        abstract totalVerticesPerfCounter: PerfCounter
        /// Gets the total number of active indices rendered per frame (You can deduce the number of rendered triangles by dividing this number by 3)
        abstract getActiveIndices: unit -> float
        /// Gets the performance counter for active indices
        abstract totalActiveIndicesPerfCounter: PerfCounter
        /// Gets the total number of active particles rendered per frame
        abstract getActiveParticles: unit -> float
        /// Gets the performance counter for active particles
        abstract activeParticlesPerfCounter: PerfCounter
        /// Gets the total number of active bones rendered per frame
        abstract getActiveBones: unit -> float
        /// Gets the performance counter for active bones
        abstract activeBonesPerfCounter: PerfCounter
        abstract getInterFramePerfCounter: unit -> float
        abstract interFramePerfCounter: Nullable<PerfCounter>
        abstract getLastFrameDuration: unit -> float
        abstract lastFramePerfCounter: Nullable<PerfCounter>
        abstract getEvaluateActiveMeshesDuration: unit -> float
        abstract evaluateActiveMeshesDurationPerfCounter: Nullable<PerfCounter>
        /// Gets the array of active meshes
        abstract getActiveMeshes: unit -> SmartArray<AbstractMesh>
        abstract getRenderTargetsDuration: unit -> float
        abstract getRenderDuration: unit -> float
        abstract renderDurationPerfCounter: Nullable<PerfCounter>
        abstract getParticlesDuration: unit -> float
        abstract particlesDurationPerfCounter: Nullable<PerfCounter>
        abstract getSpritesDuration: unit -> float
        abstract spriteDuractionPerfCounter: Nullable<PerfCounter>
        /// Gets the animation ratio (which is 1.0 is the scene renders at 60fps and 2 if the scene renders at 30fps, etc.)
        abstract getAnimationRatio: unit -> float
        /// Gets an unique Id for the current frame
        abstract getRenderId: unit -> float
        /// Call this function if you want to manually increment the render Id
        abstract incrementRenderId: unit -> unit
        abstract _updatePointerPosition: evt: obj -> unit
        abstract _createUbo: unit -> unit
        abstract _createAlternateUbo: unit -> unit
        /// <summary>Use this method to simulate a pointer move on a mesh
        /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay</summary>
        /// <param name="pickResult">pickingInfo of the object wished to simulate pointer event on</param>
        /// <param name="pointerEventInit">pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)</param>
        abstract simulatePointerMove: pickResult: PickingInfo * ?pointerEventInit: PointerEventInit -> Scene
        abstract _processPointerMove: pickResult: obj * evt: obj -> unit
        /// <summary>Use this method to simulate a pointer down on a mesh
        /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay</summary>
        /// <param name="pickResult">pickingInfo of the object wished to simulate pointer event on</param>
        /// <param name="pointerEventInit">pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)</param>
        abstract simulatePointerDown: pickResult: PickingInfo * ?pointerEventInit: PointerEventInit -> Scene
        abstract _processPointerDown: pickResult: obj * evt: obj -> unit
        /// <summary>Use this method to simulate a pointer up on a mesh
        /// The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay</summary>
        /// <param name="pickResult">pickingInfo of the object wished to simulate pointer event on</param>
        /// <param name="pointerEventInit">pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)</param>
        abstract simulatePointerUp: pickResult: PickingInfo * ?pointerEventInit: PointerEventInit -> Scene
        abstract _processPointerUp: pickResult: obj * evt: obj * clickInfo: obj -> unit
        /// <summary>Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp</summary>
        /// <param name="attachUp">defines if you want to attach events to pointerup</param>
        /// <param name="attachDown">defines if you want to attach events to pointerdown</param>
        /// <param name="attachMove">defines if you want to attach events to pointermove</param>
        abstract attachControl: ?attachUp: bool * ?attachDown: bool * ?attachMove: bool -> unit
        /// Detaches all event handlers
        abstract detachControl: unit -> unit
        /// This function will check if the scene can be rendered (textures are loaded, shaders are compiled)
        /// Delay loaded resources are not taking in account
        abstract isReady: unit -> bool
        /// Resets all cached information relative to material (including effect and visibility) 
        abstract resetCachedMaterial: unit -> unit
        /// <summary>Registers a function to be called before every frame render</summary>
        /// <param name="func">defines the function to register</param>
        abstract registerBeforeRender: func: (unit -> unit) -> unit
        /// <summary>Unregisters a function called before every frame render</summary>
        /// <param name="func">defines the function to unregister</param>
        abstract unregisterBeforeRender: func: (unit -> unit) -> unit
        /// <summary>Registers a function to be called after every frame render</summary>
        /// <param name="func">defines the function to register</param>
        abstract registerAfterRender: func: (unit -> unit) -> unit
        /// <summary>Unregisters a function called after every frame render</summary>
        /// <param name="func">defines the function to unregister</param>
        abstract unregisterAfterRender: func: (unit -> unit) -> unit
        abstract _executeOnceBeforeRender: func: obj -> unit
        /// <summary>The provided function will run before render once and will be disposed afterwards.
        /// A timeout delay can be provided so that the function will be executed in N ms.
        /// The timeout is using the browser's native setTimeout so time percision cannot be guaranteed.</summary>
        /// <param name="func">The function to be executed.</param>
        /// <param name="timeout">optional delay in ms</param>
        abstract executeOnceBeforeRender: func: (unit -> unit) * ?timeout: float -> unit
        abstract _addPendingData: data: obj option -> unit
        abstract _removePendingData: data: obj option -> unit
        /// Returns the number of items waiting to be loaded
        abstract getWaitingItemsCount: unit -> float
        /// Returns a boolean indicating if the scene is still loading data
        abstract isLoading: bool
        /// <summary>Registers a function to be executed when the scene is ready</summary>
        /// <param name="func">- the function to be executed</param>
        abstract executeWhenReady: func: (unit -> unit) -> unit
        /// Returns a promise that resolves when the scene is ready
        abstract whenReadyAsync: unit -> Promise<unit>
        abstract _checkIsReady: unit -> unit
        /// <summary>Will start the animation sequence of a given target</summary>
        /// <param name="target">defines the target</param>
        /// <param name="from">defines from which frame should animation start</param>
        /// <param name="to">defines until which frame should animation run.</param>
        /// <param name="weight">defines the weight to apply to the animation (1.0 by default)</param>
        /// <param name="loop">defines if the animation loops</param>
        /// <param name="speedRatio">defines the speed in which to run the animation (1.0 by default)</param>
        /// <param name="onAnimationEnd">defines the function to be executed when the animation ends</param>
        /// <param name="animatable">defines an animatable object. If not provided a new one will be created from the given params</param>
        abstract beginWeightedAnimation: target: obj option * from: float * ``to``: float * ?weight: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) * ?animatable: Animatable -> Animatable
        /// <summary>Will start the animation sequence of a given target</summary>
        /// <param name="target">defines the target</param>
        /// <param name="from">defines from which frame should animation start</param>
        /// <param name="to">defines until which frame should animation run.</param>
        /// <param name="loop">defines if the animation loops</param>
        /// <param name="speedRatio">defines the speed in which to run the animation (1.0 by default)</param>
        /// <param name="onAnimationEnd">defines the function to be executed when the animation ends</param>
        /// <param name="animatable">defines an animatable object. If not provided a new one will be created from the given params</param>
        /// <param name="stopCurrent">defines if the current animations must be stopped first (true by default)</param>
        abstract beginAnimation: target: obj option * from: float * ``to``: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) * ?animatable: Animatable * ?stopCurrent: bool -> Animatable
        /// <summary>Begin a new animation on a given node</summary>
        /// <param name="target">defines the target where the animation will take place</param>
        /// <param name="animations">defines the list of animations to start</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loop">defines if you want animation to loop (off by default)</param>
        /// <param name="speedRatio">defines the speed ratio to apply to all animations</param>
        /// <param name="onAnimationEnd">defines the callback to call when an animation ends (will be called once per node)</param>
        abstract beginDirectAnimation: target: obj option * animations: ResizeArray<Animation> * from: float * ``to``: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> Animatable
        /// <summary>Begin a new animation on a given node and its hierarchy</summary>
        /// <param name="target">defines the root node where the animation will take place</param>
        /// <param name="directDescendantsOnly">if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.</param>
        /// <param name="animations">defines the list of animations to start</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loop">defines if you want animation to loop (off by default)</param>
        /// <param name="speedRatio">defines the speed ratio to apply to all animations</param>
        /// <param name="onAnimationEnd">defines the callback to call when an animation ends (will be called once per node)</param>
        abstract beginDirectHierarchyAnimation: target: Node * directDescendantsOnly: bool * animations: ResizeArray<Animation> * from: float * ``to``: float * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> ResizeArray<Animatable>
        /// <summary>Gets the animatable associated with a specific target</summary>
        /// <param name="target">defines the target of the animatable</param>
        abstract getAnimatableByTarget: target: obj option -> Nullable<Animatable>
        /// <summary>Gets all animatables associated with a given target</summary>
        /// <param name="target">defines the target to look animatables for</param>
        abstract getAllAnimatablesByTarget: target: obj option -> Array<Animatable>
        /// Gets all animatable attached to the scene
        abstract animatables: ResizeArray<Animatable>
        /// <summary>Will stop the animation of the given target</summary>
        /// <param name="target">- the target</param>
        /// <param name="animationName">- the name of the animation to stop (all animations will be stopped if empty)</param>
        abstract stopAnimation: target: obj option * ?animationName: string -> unit
        /// Stops and removes all animations that have been applied to the scene
        abstract stopAllAnimations: unit -> unit
        abstract _animate: unit -> unit
        abstract _registerTargetForLateAnimationBinding: runtimeAnimation: RuntimeAnimation -> unit
        abstract _processLateAnimationBindingsForMatrices: holder: obj * originalValue: obj -> unit
        abstract _processLateAnimationBindings: unit -> unit
        abstract _switchToAlternateCameraConfiguration: active: bool -> unit
        /// Gets the current view matrix
        abstract getViewMatrix: unit -> Matrix
        /// Gets the current projection matrix
        abstract getProjectionMatrix: unit -> Matrix
        /// Gets the current transform matrix
        abstract getTransformMatrix: unit -> Matrix
        /// <summary>Sets the current transform matrix</summary>
        /// <param name="view">defines the View matrix to use</param>
        /// <param name="projection">defines the Projection matrix to use</param>
        abstract setTransformMatrix: view: Matrix * projection: Matrix -> unit
        abstract _setAlternateTransformMatrix: view: Matrix * projection: Matrix -> unit
        /// Gets the uniform buffer used to store scene data
        abstract getSceneUniformBuffer: unit -> UniformBuffer
        /// Gets an unique (relatively to the current scene) Id
        abstract getUniqueId: unit -> float
        /// <summary>Add a mesh to the list of scene's meshes</summary>
        /// <param name="newMesh">defines the mesh to add</param>
        abstract addMesh: newMesh: AbstractMesh -> unit
        /// <summary>Remove a mesh for the list of scene's meshes</summary>
        /// <param name="toRemove">defines the mesh to remove</param>
        abstract removeMesh: toRemove: AbstractMesh -> float
        /// <summary>Add a transform node to the list of scene's transform nodes</summary>
        /// <param name="newTransformNode">defines the transform node to add</param>
        abstract addTransformNode: newTransformNode: TransformNode -> unit
        /// <summary>Remove a transform node for the list of scene's transform nodes</summary>
        /// <param name="toRemove">defines the transform node to remove</param>
        abstract removeTransformNode: toRemove: TransformNode -> float
        /// <summary>Remove a skeleton for the list of scene's skeletons</summary>
        /// <param name="toRemove">defines the skeleton to remove</param>
        abstract removeSkeleton: toRemove: Skeleton -> float
        /// <summary>Remove a morph target for the list of scene's morph targets</summary>
        /// <param name="toRemove">defines the morph target to remove</param>
        abstract removeMorphTargetManager: toRemove: MorphTargetManager -> float
        /// <summary>Remove a light for the list of scene's lights</summary>
        /// <param name="toRemove">defines the light to remove</param>
        abstract removeLight: toRemove: Light -> float
        /// <summary>Remove a camera for the list of scene's cameras</summary>
        /// <param name="toRemove">defines the camera to remove</param>
        abstract removeCamera: toRemove: Camera -> float
        /// <summary>Remove a particle system for the list of scene's particle systems</summary>
        /// <param name="toRemove">defines the particle system to remove</param>
        abstract removeParticleSystem: toRemove: IParticleSystem -> float
        /// <summary>Remove a animation for the list of scene's animations</summary>
        /// <param name="toRemove">defines the animation to remove</param>
        abstract removeAnimation: toRemove: Animation -> float
        /// <summary>Removes the given animation group from this scene.</summary>
        /// <param name="toRemove">The animation group to remove</param>
        abstract removeAnimationGroup: toRemove: AnimationGroup -> float
        /// <summary>Removes the given multi-material from this scene.</summary>
        /// <param name="toRemove">The multi-material to remove</param>
        abstract removeMultiMaterial: toRemove: MultiMaterial -> float
        /// <summary>Removes the given material from this scene.</summary>
        /// <param name="toRemove">The material to remove</param>
        abstract removeMaterial: toRemove: Material -> float
        /// <summary>Removes the given lens flare system from this scene.</summary>
        /// <param name="toRemove">The lens flare system to remove</param>
        abstract removeLensFlareSystem: toRemove: LensFlareSystem -> float
        /// <summary>Removes the given action manager from this scene.</summary>
        /// <param name="toRemove">The action manager to remove</param>
        abstract removeActionManager: toRemove: ActionManager -> float
        /// <summary>Removes the given effect layer from this scene.</summary>
        /// <param name="toRemove">defines the effect layer to remove</param>
        abstract removeEffectLayer: toRemove: EffectLayer -> float
        /// <summary>Removes the given texture from this scene.</summary>
        /// <param name="toRemove">The texture to remove</param>
        abstract removeTexture: toRemove: BaseTexture -> float
        /// <summary>Adds the given light to this scene</summary>
        /// <param name="newLight">The light to add</param>
        abstract addLight: newLight: Light -> unit
        /// Sorts the list list based on light priorities
        abstract sortLightsByPriority: unit -> unit
        /// <summary>Adds the given camera to this scene</summary>
        /// <param name="newCamera">The camera to add</param>
        abstract addCamera: newCamera: Camera -> unit
        /// <summary>Adds the given skeleton to this scene</summary>
        /// <param name="newSkeleton">The skeleton to add</param>
        abstract addSkeleton: newSkeleton: Skeleton -> unit
        /// <summary>Adds the given particle system to this scene</summary>
        /// <param name="newParticleSystem">The particle system to add</param>
        abstract addParticleSystem: newParticleSystem: IParticleSystem -> unit
        /// <summary>Adds the given animation to this scene</summary>
        /// <param name="newAnimation">The animation to add</param>
        abstract addAnimation: newAnimation: Animation -> unit
        /// <summary>Adds the given animation group to this scene.</summary>
        /// <param name="newAnimationGroup">The animation group to add</param>
        abstract addAnimationGroup: newAnimationGroup: AnimationGroup -> unit
        /// <summary>Adds the given multi-material to this scene</summary>
        /// <param name="newMultiMaterial">The multi-material to add</param>
        abstract addMultiMaterial: newMultiMaterial: MultiMaterial -> unit
        /// <summary>Adds the given material to this scene</summary>
        /// <param name="newMaterial">The material to add</param>
        abstract addMaterial: newMaterial: Material -> unit
        /// <summary>Adds the given morph target to this scene</summary>
        /// <param name="newMorphTargetManager">The morph target to add</param>
        abstract addMorphTargetManager: newMorphTargetManager: MorphTargetManager -> unit
        /// <summary>Adds the given geometry to this scene</summary>
        /// <param name="newGeometry">The geometry to add</param>
        abstract addGeometry: newGeometry: Geometry -> unit
        /// <summary>Adds the given lens flare system to this scene</summary>
        /// <param name="newLensFlareSystem">The lens flare system to add</param>
        abstract addLensFlareSystem: newLensFlareSystem: LensFlareSystem -> unit
        /// <summary>Adds the given effect layer to this scene</summary>
        /// <param name="newEffectLayer">defines the effect layer to add</param>
        abstract addEffectLayer: newEffectLayer: EffectLayer -> unit
        /// <summary>Adds the given action manager to this scene</summary>
        /// <param name="newActionManager">The action manager to add</param>
        abstract addActionManager: newActionManager: ActionManager -> unit
        /// <summary>Adds the given texture to this scene.</summary>
        /// <param name="newTexture">The texture to add</param>
        abstract addTexture: newTexture: BaseTexture -> unit
        /// <summary>Switch active camera</summary>
        /// <param name="newCamera">defines the new active camera</param>
        /// <param name="attachControl">defines if attachControl must be called for the new active camera (default: true)</param>
        abstract switchActiveCamera: newCamera: Camera * ?attachControl: bool -> unit
        /// <summary>sets the active camera of the scene using its ID</summary>
        /// <param name="id">defines the camera's ID</param>
        abstract setActiveCameraByID: id: string -> Nullable<Camera>
        /// <summary>sets the active camera of the scene using its name</summary>
        /// <param name="name">defines the camera's name</param>
        abstract setActiveCameraByName: name: string -> Nullable<Camera>
        /// <summary>get an animation group using its name</summary>
        /// <param name="name">defines the material's name</param>
        abstract getAnimationGroupByName: name: string -> Nullable<AnimationGroup>
        /// <summary>get a material using its id</summary>
        /// <param name="id">defines the material's ID</param>
        abstract getMaterialByID: id: string -> Nullable<Material>
        /// <summary>Gets a material using its name</summary>
        /// <param name="name">defines the material's name</param>
        abstract getMaterialByName: name: string -> Nullable<Material>
        /// <summary>Gets a lens flare system using its name</summary>
        /// <param name="name">defines the name to look for</param>
        abstract getLensFlareSystemByName: name: string -> Nullable<LensFlareSystem>
        /// <summary>Gets a lens flare system using its id</summary>
        /// <param name="id">defines the id to look for</param>
        abstract getLensFlareSystemByID: id: string -> Nullable<LensFlareSystem>
        /// <summary>Gets a camera using its id</summary>
        /// <param name="id">defines the id to look for</param>
        abstract getCameraByID: id: string -> Nullable<Camera>
        /// <summary>Gets a camera using its unique id</summary>
        /// <param name="uniqueId">defines the unique id to look for</param>
        abstract getCameraByUniqueID: uniqueId: float -> Nullable<Camera>
        /// <summary>Gets a camera using its name</summary>
        /// <param name="name">defines the camera's name</param>
        abstract getCameraByName: name: string -> Nullable<Camera>
        /// <summary>Gets a bone using its id</summary>
        /// <param name="id">defines the bone's id</param>
        abstract getBoneByID: id: string -> Nullable<Bone>
        /// <summary>Gets a bone using its id</summary>
        /// <param name="name">defines the bone's name</param>
        abstract getBoneByName: name: string -> Nullable<Bone>
        /// <summary>Gets a light node using its name</summary>
        /// <param name="name">defines the the light's name</param>
        abstract getLightByName: name: string -> Nullable<Light>
        /// <summary>Gets a light node using its id</summary>
        /// <param name="id">defines the light's id</param>
        abstract getLightByID: id: string -> Nullable<Light>
        /// <summary>Gets a light node using its scene-generated unique ID</summary>
        /// <param name="uniqueId">defines the light's unique id</param>
        abstract getLightByUniqueID: uniqueId: float -> Nullable<Light>
        /// <summary>Gets a particle system by id</summary>
        /// <param name="id">defines the particle system id</param>
        abstract getParticleSystemByID: id: string -> Nullable<IParticleSystem>
        /// <summary>Gets a geometry using its ID</summary>
        /// <param name="id">defines the geometry's id</param>
        abstract getGeometryByID: id: string -> Nullable<Geometry>
        /// <summary>Add a new geometry to this scene</summary>
        /// <param name="geometry">defines the geometry to be added to the scene.</param>
        /// <param name="force">defines if the geometry must be pushed even if a geometry with this id already exists</param>
        abstract pushGeometry: geometry: Geometry * ?force: bool -> bool
        /// <summary>Removes an existing geometry</summary>
        /// <param name="geometry">defines the geometry to be removed from the scene</param>
        abstract removeGeometry: geometry: Geometry -> bool
        /// Gets the list of geometries attached to the scene
        abstract getGeometries: unit -> ResizeArray<Geometry>
        /// <summary>Gets the first added mesh found of a given ID</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getMeshByID: id: string -> Nullable<AbstractMesh>
        /// <summary>Gets a list of meshes using their id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getMeshesByID: id: string -> Array<AbstractMesh>
        /// <summary>Gets the first added transform node found of a given ID</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getTransformNodeByID: id: string -> Nullable<TransformNode>
        /// <summary>Gets a list of transform nodes using their id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getTransformNodesByID: id: string -> Array<TransformNode>
        /// <summary>Gets a mesh with its auto-generated unique id</summary>
        /// <param name="uniqueId">defines the unique id to search for</param>
        abstract getMeshByUniqueID: uniqueId: float -> Nullable<AbstractMesh>
        /// <summary>Gets a the last added mesh using a given id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getLastMeshByID: id: string -> Nullable<AbstractMesh>
        /// <summary>Gets a the last added node (Mesh, Camera, Light) using a given id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getLastEntryByID: id: string -> Nullable<Node>
        /// <summary>Gets a node (Mesh, Camera, Light) using a given id</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getNodeByID: id: string -> Nullable<Node>
        /// <summary>Gets a node (Mesh, Camera, Light) using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getNodeByName: name: string -> Nullable<Node>
        /// <summary>Gets a mesh using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getMeshByName: name: string -> Nullable<AbstractMesh>
        /// <summary>Gets a transform node using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getTransformNodeByName: name: string -> Nullable<TransformNode>
        /// <summary>Gets a sound using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getSoundByName: name: string -> Nullable<Sound>
        /// <summary>Gets a skeleton using a given id (if many are found, this function will pick the last one)</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getLastSkeletonByID: id: string -> Nullable<Skeleton>
        /// <summary>Gets a skeleton using a given id (if many are found, this function will pick the first one)</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getSkeletonById: id: string -> Nullable<Skeleton>
        /// <summary>Gets a skeleton using a given name</summary>
        /// <param name="name">defines the name to search for</param>
        abstract getSkeletonByName: name: string -> Nullable<Skeleton>
        /// <summary>Gets a morph target manager  using a given id (if many are found, this function will pick the last one)</summary>
        /// <param name="id">defines the id to search for</param>
        abstract getMorphTargetManagerById: id: float -> Nullable<MorphTargetManager>
        /// <summary>Gets a boolean indicating if the given mesh is active</summary>
        /// <param name="mesh">defines the mesh to look for</param>
        abstract isActiveMesh: mesh: AbstractMesh -> bool
        /// <summary>Return a the first highlight layer of the scene with a given name.</summary>
        /// <param name="name">The name of the highlight layer to look for.</param>
        abstract getHighlightLayerByName: name: string -> Nullable<HighlightLayer>
        /// <summary>Return a the first highlight layer of the scene with a given name.</summary>
        /// <param name="name">The name of the highlight layer to look for.</param>
        abstract getGlowLayerByName: name: string -> Nullable<GlowLayer>
        /// Return a unique id as a string which can serve as an identifier for the scene
        abstract uid: string
        /// <summary>Add an externaly attached data from its key.
        /// This method call will fail and return false, if such key already exists.
        /// If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="data">the data object to associate to the key for this Engine instance</param>
        abstract addExternalData: key: string * data: 'T -> bool
        /// <summary>Get an externaly attached data from its key</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract getExternalData: key: string -> Nullable<'T>
        /// <summary>Get an externaly attached data from its key, create it using a factory if it's not already present</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="factory">the factory that will be called to create the instance if and only if it doesn't exists</param>
        abstract getOrAddExternalDataWithFactory: key: string * factory: (string -> 'T) -> 'T
        /// <summary>Remove an externaly attached data from the Engine instance</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract removeExternalData: key: string -> bool
        abstract _evaluateSubMesh: subMesh: obj * mesh: obj -> unit
        /// Clear the processed materials smart array preventing retention point in material dispose.
        abstract freeProcessedMaterials: unit -> unit
        /// Clear the active meshes smart array preventing retention point in mesh dispose.
        abstract freeActiveMeshes: unit -> unit
        /// Clear the info related to rendering groups preventing retention points during dispose.
        abstract freeRenderingGroups: unit -> unit
        abstract _isInIntermediateRendering: unit -> bool
        abstract _activeMeshCandidateProvider: obj with get, set
        /// <summary>Defines the current active mesh candidate provider</summary>
        /// <param name="provider">defines the provider to use</param>
        abstract setActiveMeshCandidateProvider: provider: IActiveMeshCandidateProvider -> unit
        /// Gets the current active mesh candidate provider
        abstract getActiveMeshCandidateProvider: unit -> IActiveMeshCandidateProvider
        abstract _activeMeshesFrozen: obj with get, set
        /// Use this function to stop evaluating active meshes. The current list will be keep alive between frames
        abstract freezeActiveMeshes: unit -> Scene
        /// Use this function to restart evaluating active meshes on every frame
        abstract unfreezeActiveMeshes: unit -> Scene
        abstract _evaluateActiveMeshes: unit -> unit
        abstract _activeMesh: sourceMesh: obj * mesh: obj -> unit
        /// <summary>Update the transform matrix to update from the current active camera</summary>
        /// <param name="force">defines a boolean used to force the update even if cache is up to date</param>
        abstract updateTransformMatrix: ?force: bool -> unit
        /// <summary>Defines an alternate camera (used mostly in VR-like scenario where two cameras can render the same scene from a slightly different point of view)</summary>
        /// <param name="alternateCamera">defines the camera to use</param>
        abstract updateAlternateTransformMatrix: alternateCamera: Camera -> unit
        abstract _renderForCamera: camera: obj * ?rigParent: obj -> unit
        abstract _processSubCameras: camera: obj -> unit
        abstract _checkIntersections: unit -> unit
        /// Render the scene
        abstract render: unit -> unit
        abstract _updateAudioParameters: unit -> unit
        /// Gets or sets if audio support is enabled
        abstract audioEnabled: bool with get, set
        abstract _disableAudio: unit -> unit
        abstract _enableAudio: unit -> unit
        /// Gets or sets if audio will be output to headphones
        abstract headphone: bool with get, set
        abstract _switchAudioModeForHeadphones: unit -> unit
        abstract _switchAudioModeForNormalSpeakers: unit -> unit
        /// <summary>Creates a depth renderer a given camera which contains a depth map which can be used for post processing.</summary>
        /// <param name="camera">The camera to create the depth renderer on (default: scene's active camera)</param>
        abstract enableDepthRenderer: ?camera: Nullable<Camera> -> DepthRenderer
        /// <summary>Disables a depth renderer for a given camera</summary>
        /// <param name="camera">The camera to disable the depth renderer on (default: scene's active camera)</param>
        abstract disableDepthRenderer: ?camera: Nullable<Camera> -> unit
        /// <summary>Enables a GeometryBufferRender and associates it with the scene</summary>
        /// <param name="ratio">defines the scaling ratio to apply to the renderer (1 by default which means same resolution)</param>
        abstract enableGeometryBufferRenderer: ?ratio: float -> Nullable<GeometryBufferRenderer>
        /// Disables the GeometryBufferRender associated with the scene
        abstract disableGeometryBufferRenderer: unit -> unit
        /// Freeze all materials
        /// A frozen material will not be updatable but should be faster to render
        abstract freezeMaterials: unit -> unit
        /// Unfreeze all materials
        /// A frozen material will not be updatable but should be faster to render
        abstract unfreezeMaterials: unit -> unit
        /// Releases all held ressources
        abstract dispose: unit -> unit
        /// Gets if the scene is already disposed
        abstract isDisposed: bool
        /// Releases sounds & soundtracks
        abstract disposeSounds: unit -> unit
        /// <summary>Get the world extend vectors with an optional filter</summary>
        /// <param name="filterPredicate">the predicate - which meshes should be included when calculating the world size</param>
        abstract getWorldExtends: ?filterPredicate: (AbstractMesh -> bool) -> obj
        /// <summary>Creates or updates the octree used to boost selection (picking)</summary>
        /// <param name="maxCapacity">defines the maximum capacity per leaf</param>
        /// <param name="maxDepth">defines the maximum depth of the octree</param>
        abstract createOrUpdateSelectionOctree: ?maxCapacity: float * ?maxDepth: float -> Octree<AbstractMesh>
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="world">defines the world matrix to use if you want to pick in object space (instead of world space)</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        /// <param name="cameraViewSpace">defines if picking will be done in view space (false by default)</param>
        abstract createPickingRay: x: float * y: float * world: Matrix * camera: Nullable<Camera> * ?cameraViewSpace: bool -> Ray
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="world">defines the world matrix to use if you want to pick in object space (instead of world space)</param>
        /// <param name="result">defines the ray where to store the picking ray</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        /// <param name="cameraViewSpace">defines if picking will be done in view space (false by default)</param>
        abstract createPickingRayToRef: x: float * y: float * world: Matrix * result: Ray * camera: Nullable<Camera> * ?cameraViewSpace: bool -> Scene
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        abstract createPickingRayInCameraSpace: x: float * y: float * ?camera: Camera -> Ray
        /// <summary>Creates a ray that can be used to pick in the scene</summary>
        /// <param name="x">defines the x coordinate of the origin (on-screen)</param>
        /// <param name="y">defines the y coordinate of the origin (on-screen)</param>
        /// <param name="result">defines the ray where to store the picking ray</param>
        /// <param name="camera">defines the camera to use for the picking</param>
        abstract createPickingRayInCameraSpaceToRef: x: float * y: float * result: Ray * ?camera: Camera -> Scene
        abstract _internalPick: rayFunction: obj * ?predicate: obj * ?fastCheck: obj -> unit
        abstract _internalMultiPick: rayFunction: obj * ?predicate: obj -> unit
        abstract _internalPickSprites: ray: obj * ?predicate: obj * ?fastCheck: obj * ?camera: obj -> unit
        abstract _tempPickingRay: obj with get, set
        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>
        /// <param name="x">position on screen</param>
        /// <param name="y">position on screen</param>
        /// <param name="predicate">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>
        /// <param name="fastCheck">Launch a fast check only using the bounding boxes. Can be set to null.</param>
        /// <param name="camera">to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>
        abstract pick: x: float * y: float * ?predicate: (AbstractMesh -> bool) * ?fastCheck: bool * ?camera: Nullable<Camera> -> Nullable<PickingInfo>
        /// <summary>Launch a ray to try to pick a sprite in the scene</summary>
        /// <param name="x">position on screen</param>
        /// <param name="y">position on screen</param>
        /// <param name="predicate">Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true</param>
        /// <param name="fastCheck">Launch a fast check only using the bounding boxes. Can be set to null.</param>
        /// <param name="camera">camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>
        abstract pickSprite: x: float * y: float * ?predicate: (Sprite -> bool) * ?fastCheck: bool * ?camera: Camera -> Nullable<PickingInfo>
        abstract _cachedRayForTransform: obj with get, set
        /// <summary>Use the given ray to pick a mesh in the scene</summary>
        /// <param name="ray">The ray to use to pick meshes</param>
        /// <param name="predicate">Predicate function used to determine eligible sprites. Can be set to null. In this case, a sprite must have isPickable set to true</param>
        /// <param name="fastCheck">Launch a fast check only using the bounding boxes. Can be set to null</param>
        abstract pickWithRay: ray: Ray * predicate: (AbstractMesh -> bool) * ?fastCheck: bool -> Nullable<PickingInfo>
        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>
        /// <param name="x">X position on screen</param>
        /// <param name="y">Y position on screen</param>
        /// <param name="predicate">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>
        /// <param name="camera">camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used</param>
        abstract multiPick: x: float * y: float * ?predicate: (AbstractMesh -> bool) * ?camera: Camera -> Nullable<ResizeArray<PickingInfo>>
        /// <summary>Launch a ray to try to pick a mesh in the scene</summary>
        /// <param name="ray">Ray to use</param>
        /// <param name="predicate">Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true</param>
        abstract multiPickWithRay: ray: Ray * predicate: (AbstractMesh -> bool) -> Nullable<ResizeArray<PickingInfo>>
        /// <summary>Force the value of meshUnderPointer</summary>
        /// <param name="mesh">defines the mesh to use</param>
        abstract setPointerOverMesh: mesh: Nullable<AbstractMesh> -> unit
        /// Gets the mesh under the pointer
        abstract getPointerOverMesh: unit -> Nullable<AbstractMesh>
        /// <summary>Force the sprite under the pointer</summary>
        /// <param name="sprite">defines the sprite to use</param>
        abstract setPointerOverSprite: sprite: Nullable<Sprite> -> unit
        /// Gets the sprite under the pointer
        abstract getPointerOverSprite: unit -> Nullable<Sprite>
        /// Gets the current physics engine
        abstract getPhysicsEngine: unit -> Nullable<PhysicsEngine>
        /// <summary>Enables physics to the current scene</summary>
        /// <param name="gravity">defines the scene's gravity for the physics engine</param>
        /// <param name="plugin">defines the physics engine to be used. defaults to OimoJS.</param>
        abstract enablePhysics: ?gravity: Nullable<Vector3> * ?plugin: IPhysicsEnginePlugin -> bool
        /// Disables and disposes the physics engine associated with the scene
        abstract disablePhysicsEngine: unit -> unit
        /// Gets a boolean indicating if there is an active physics engine
        abstract isPhysicsEnabled: unit -> bool
        /// <summary>Deletes a physics compound impostor</summary>
        /// <param name="compound">defines the compound to delete</param>
        abstract deleteCompoundImpostor: compound: obj option -> unit
        abstract _rebuildGeometries: unit -> unit
        abstract _rebuildTextures: unit -> unit
        /// <summary>Creates a default light for the scene.</summary>
        /// <param name="replace">Whether to replace the existing lights in the scene.</param>
        abstract createDefaultLight: ?replace: bool -> unit
        /// <summary>Creates a default camera for the scene.</summary>
        /// <param name="createArcRotateCamera">Whether to create an arc rotate or a free camera.</param>
        /// <param name="replace">Whether to replace the existing active camera in the scene.</param>
        /// <param name="attachCameraControls">Whether to attach camera controls to the canvas.</param>
        abstract createDefaultCamera: ?createArcRotateCamera: bool * ?replace: bool * ?attachCameraControls: bool -> unit
        /// <summary>Creates a default camera and a default light</summary>
        /// <param name="createArcRotateCamera">defines that the camera will be an ArcRotateCamera</param>
        /// <param name="replace">defines if the camera and/or light will replace the existing ones</param>
        /// <param name="attachCameraControls">defines if attachControl will be called on the new camera</param>
        abstract createDefaultCameraOrLight: ?createArcRotateCamera: bool * ?replace: bool * ?attachCameraControls: bool -> unit
        /// <summary>Creates a new sky box</summary>
        /// <param name="environmentTexture">defines the texture to use as environment texture</param>
        /// <param name="pbr">defines if PBRMaterial must be used instead of StandardMaterial</param>
        /// <param name="scale">defines the overall scale of the skybox</param>
        /// <param name="blur">defines if blurring must be applied to the environment texture (works only with pbr === true)</param>
        abstract createDefaultSkybox: ?environmentTexture: BaseTexture * ?pbr: bool * ?scale: float * ?blur: float -> Nullable<Mesh>
        /// <summary>Creates a new environment</summary>
        /// <param name="options">defines the options you can use to configure the environment</param>
        abstract createDefaultEnvironment: options: obj -> Nullable<EnvironmentHelper>
        /// <summary>Creates a new VREXperienceHelper</summary>
        /// <param name="webVROptions">defines the options used to create the new VREXperienceHelper</param>
        abstract createDefaultVRExperience: ?webVROptions: VRExperienceHelperOptions -> VRExperienceHelper
        abstract _getByTags: list: obj * tagsQuery: obj * ?forEach: obj -> unit
        /// <summary>Get a list of meshes by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getMeshesByTags: tagsQuery: string * ?forEach: (AbstractMesh -> unit) -> ResizeArray<Mesh>
        /// <summary>Get a list of cameras by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getCamerasByTags: tagsQuery: string * ?forEach: (Camera -> unit) -> ResizeArray<Camera>
        /// <summary>Get a list of lights by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getLightsByTags: tagsQuery: string * ?forEach: (Light -> unit) -> ResizeArray<Light>
        /// <summary>Get a list of materials by tags</summary>
        /// <param name="tagsQuery">defines the tags query to use</param>
        /// <param name="forEach">defines a predicate used to filter results</param>
        abstract getMaterialByTags: tagsQuery: string * ?forEach: (Material -> unit) -> ResizeArray<Material>
        /// <summary>Overrides the default sort function applied in the renderging group to prepare the meshes.
        /// This allowed control for front to back rendering or reversly depending of the special needs.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="opaqueSortCompareFn">The opaque queue comparison function use to sort.</param>
        /// <param name="alphaTestSortCompareFn">The alpha test queue comparison function use to sort.</param>
        /// <param name="transparentSortCompareFn">The transparent queue comparison function use to sort.</param>
        abstract setRenderingOrder: renderingGroupId: float * ?opaqueSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?alphaTestSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?transparentSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        /// <param name="depth">Automatically clears depth between groups if true and autoClear is true.</param>
        /// <param name="stencil">Automatically clears stencil between groups if true and autoClear is true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool * ?depth: bool * ?stencil: bool -> unit
        /// <summary>Will flag all materials as dirty to trigger new shader compilation</summary>
        /// <param name="flag">defines the flag used to specify which material part must be marked as dirty</param>
        /// <param name="predicate">If not null, it will be used to specifiy if a material has to be marked as dirty</param>
        abstract markAllMaterialsAsDirty: flag: float * ?predicate: (Material -> bool) -> unit
        abstract _loadFile: url: string * onSuccess: (U2<string, ArrayBuffer> -> string -> unit) * ?onProgress: (obj option -> unit) * ?useDatabase: bool * ?useArrayBuffer: bool * ?onError: (XMLHttpRequest -> obj option -> unit) -> IFileRequest
        abstract _loadFileAsync: url: string * ?useDatabase: bool * ?useArrayBuffer: bool -> Promise<U2<string, ArrayBuffer>>

    /// Represents a scene to be rendered by the engine.
    type [<AllowNullLiteral>] SceneStatic =
        /// <summary>Creates a new Scene</summary>
        /// <param name="engine">defines the engine to use to render this scene</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine -> Scene

    type Nullable<'T> =
        'T option

    type float =
        float

    type double =
        float

    type int =
        float

    type FloatArray =
        U2<ResizeArray<float>, Float32Array>

    [<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module FloatArray =
        let ofFloatArray v: FloatArray = v |> U2.Case1
        let isFloatArray (v: FloatArray) = match v with U2.Case1 _ -> true | _ -> false
        let asFloatArray (v: FloatArray) = match v with U2.Case1 o -> Some o | _ -> None
        let ofFloat32Array v: FloatArray = v |> U2.Case2
        let isFloat32Array (v: FloatArray) = match v with U2.Case2 _ -> true | _ -> false
        let asFloat32Array (v: FloatArray) = match v with U2.Case2 o -> Some o | _ -> None

    type IndicesArray =
        U4<ResizeArray<float>, Int32Array, Uint32Array, Uint16Array>

    [<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module IndicesArray =
        let ofFloatArray v: IndicesArray = v |> U4.Case1
        let isFloatArray (v: IndicesArray) = match v with U4.Case1 _ -> true | _ -> false
        let asFloatArray (v: IndicesArray) = match v with U4.Case1 o -> Some o | _ -> None
        let ofInt32Array v: IndicesArray = v |> U4.Case2
        let isInt32Array (v: IndicesArray) = match v with U4.Case2 _ -> true | _ -> false
        let asInt32Array (v: IndicesArray) = match v with U4.Case2 o -> Some o | _ -> None
        let ofUint32Array v: IndicesArray = v |> U4.Case3
        let isUint32Array (v: IndicesArray) = match v with U4.Case3 _ -> true | _ -> false
        let asUint32Array (v: IndicesArray) = match v with U4.Case3 o -> Some o | _ -> None
        let ofUint16Array v: IndicesArray = v |> U4.Case4
        let isUint16Array (v: IndicesArray) = match v with U4.Case4 _ -> true | _ -> false
        let asUint16Array (v: IndicesArray) = match v with U4.Case4 o -> Some o | _ -> None

    type DataArray =
        U3<ResizeArray<float>, ArrayBuffer, ArrayBufferView>

    [<RequireQualifiedAccess; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
    module DataArray =
        let ofFloatArray v: DataArray = v |> U3.Case1
        let isFloatArray (v: DataArray) = match v with U3.Case1 _ -> true | _ -> false
        let asFloatArray (v: DataArray) = match v with U3.Case1 o -> Some o | _ -> None
        let ofArrayBuffer v: DataArray = v |> U3.Case2
        let isArrayBuffer (v: DataArray) = match v with U3.Case2 _ -> true | _ -> false
        let asArrayBuffer (v: DataArray) = match v with U3.Case2 o -> Some o | _ -> None
        let ofArrayBufferView v: DataArray = v |> U3.Case3
        let isArrayBufferView (v: DataArray) = match v with U3.Case3 _ -> true | _ -> false
        let asArrayBufferView (v: DataArray) = match v with U3.Case3 o -> Some o | _ -> None

    /// The action to be carried out following a trigger
    type [<AllowNullLiteral>] Action =
        abstract triggerOptions: obj option with get, set
        /// Trigger for the action
        abstract trigger: float with get, set
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        abstract _nextActiveAction: obj with get, set
        abstract _child: obj with get, set
        abstract _condition: obj option with get, set
        abstract _triggerParameter: obj with get, set
        /// An event triggered prior to action being executed.
        abstract onBeforeExecuteObservable: Observable<Action> with get, set
        /// Internal only
        abstract _prepare: unit -> unit
        /// Gets the trigger parameters
        abstract getTriggerParameter: unit -> obj option
        /// Internal only - executes current action event
        abstract _executeCurrent: ?evt: ActionEvent -> unit
        /// <summary>Execute placeholder for child classes</summary>
        /// <param name="evt">optional action event</param>
        abstract execute: ?evt: ActionEvent -> unit
        /// Skips to next active action
        abstract skipToNextActiveAction: unit -> unit
        /// Adds action to chain of actions, may be a DoNothingAction
        abstract ``then``: action: Action -> Action
        /// Internal only
        abstract _getProperty: propertyPath: string -> string
        /// Internal only
        abstract _getEffectiveTarget: target: obj option * propertyPath: string -> obj option
        /// <summary>Serialize placeholder for child classes</summary>
        /// <param name="parent">of child</param>
        abstract serialize: parent: obj option -> obj option
        /// Internal only called by serialize
        abstract _serialize: serializedAction: obj option * ?parent: obj option -> obj option
        /// Internal only
        abstract _SerializeValueAsString: (obj option -> string) with get, set
        /// Internal only
        abstract _GetTargetProperty: (U2<Scene, Node> -> obj) with get, set

    /// The action to be carried out following a trigger
    type [<AllowNullLiteral>] ActionStatic =
        /// <summary>Creates a new Action</summary>
        /// <param name="triggerOptions">the trigger, with or without parameters, for the action</param>
        /// <param name="condition">an optional determinant of action</param>
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * ?condition: Condition -> Action

    /// ActionEvent is the event being sent when an action is triggered.
    type [<AllowNullLiteral>] ActionEvent =
        abstract source: obj option with get, set
        abstract pointerX: float with get, set
        abstract pointerY: float with get, set
        abstract meshUnderPointer: Nullable<AbstractMesh> with get, set
        abstract sourceEvent: obj option with get, set
        abstract additionalData: obj option with get, set

    /// ActionEvent is the event being sent when an action is triggered.
    type [<AllowNullLiteral>] ActionEventStatic =
        /// <param name="source">The mesh or sprite that triggered the action.</param>
        /// <param name="pointerX">The X mouse cursor position at the time of the event</param>
        /// <param name="pointerY">The Y mouse cursor position at the time of the event</param>
        /// <param name="meshUnderPointer">The mesh that is currently pointed at (can be null)</param>
        /// <param name="sourceEvent">the original (browser) event that triggered the ActionEvent</param>
        [<Emit "new $0($1...)">] abstract Create: source: obj option * pointerX: float * pointerY: float * meshUnderPointer: Nullable<AbstractMesh> * ?sourceEvent: obj option * ?additionalData: obj option -> ActionEvent
        /// <summary>Helper function to auto-create an ActionEvent from a source mesh.</summary>
        /// <param name="source">The source mesh that triggered the event</param>
        /// <param name="evt">The original (browser) event</param>
        abstract CreateNew: source: AbstractMesh * ?evt: Event * ?additionalData: obj option -> ActionEvent
        /// <summary>Helper function to auto-create an ActionEvent from a source mesh.</summary>
        /// <param name="source">The source sprite that triggered the event</param>
        /// <param name="scene">Scene associated with the sprite</param>
        /// <param name="evt">The original (browser) event</param>
        abstract CreateNewFromSprite: source: Sprite * scene: Scene * ?evt: Event * ?additionalData: obj option -> ActionEvent
        /// <summary>Helper function to auto-create an ActionEvent from a scene. If triggered by a mesh use ActionEvent.CreateNew</summary>
        /// <param name="scene">the scene where the event occurred</param>
        /// <param name="evt">The original (browser) event</param>
        abstract CreateNewFromScene: scene: Scene * evt: Event -> ActionEvent
        abstract CreateNewFromPrimitive: prim: obj option * pointerPos: Vector2 * ?evt: Event * ?additionalData: obj option -> ActionEvent

    /// Action Manager manages all events to be triggered on a given mesh or the global scene.
    /// A single scene can have many Action Managers to handle predefined actions on specific meshes.
    type [<AllowNullLiteral>] ActionManager =
        abstract _NothingTrigger: obj with get, set
        abstract _OnPickTrigger: obj with get, set
        abstract _OnLeftPickTrigger: obj with get, set
        abstract _OnRightPickTrigger: obj with get, set
        abstract _OnCenterPickTrigger: obj with get, set
        abstract _OnPickDownTrigger: obj with get, set
        abstract _OnDoublePickTrigger: obj with get, set
        abstract _OnPickUpTrigger: obj with get, set
        abstract _OnLongPressTrigger: obj with get, set
        abstract _OnPointerOverTrigger: obj with get, set
        abstract _OnPointerOutTrigger: obj with get, set
        abstract _OnEveryFrameTrigger: obj with get, set
        abstract _OnIntersectionEnterTrigger: obj with get, set
        abstract _OnIntersectionExitTrigger: obj with get, set
        abstract _OnKeyDownTrigger: obj with get, set
        abstract _OnKeyUpTrigger: obj with get, set
        abstract _OnPickOutTrigger: obj with get, set
        abstract NothingTrigger: float
        abstract OnPickTrigger: float
        abstract OnLeftPickTrigger: float
        abstract OnRightPickTrigger: float
        abstract OnCenterPickTrigger: float
        abstract OnPickDownTrigger: float
        abstract OnDoublePickTrigger: float
        abstract OnPickUpTrigger: float
        abstract OnPickOutTrigger: float
        abstract OnLongPressTrigger: float
        abstract OnPointerOverTrigger: float
        abstract OnPointerOutTrigger: float
        abstract OnEveryFrameTrigger: float
        abstract OnIntersectionEnterTrigger: float
        abstract OnIntersectionExitTrigger: float
        abstract OnKeyDownTrigger: float
        abstract OnKeyUpTrigger: float
        abstract Triggers: obj with get, set
        abstract actions: ResizeArray<Action> with get, set
        abstract hoverCursor: string with get, set
        abstract _scene: obj with get, set
        abstract dispose: unit -> unit
        abstract getScene: unit -> Scene
        /// <summary>Does this action manager handles actions of any of the given triggers</summary>
        /// <param name="triggers">- the triggers to be tested</param>
        abstract hasSpecificTriggers: triggers: ResizeArray<float> -> bool
        /// <summary>Does this action manager handles actions of a given trigger</summary>
        /// <param name="trigger">defines the trigger to be tested</param>
        /// <param name="parameterPredicate">defines an optional predicate to filter triggers by parameter</param>
        abstract hasSpecificTrigger: trigger: float * ?parameterPredicate: (obj option -> bool) -> bool
        /// Does this action manager has pointer triggers
        abstract hasPointerTriggers: bool
        /// Does this action manager has pick triggers
        abstract hasPickTriggers: bool
        /// Does exist one action manager with at least one trigger
        abstract HasTriggers: bool
        /// Does exist one action manager with at least one pick trigger
        abstract HasPickTriggers: bool
        /// <summary>Registers an action to this action manager</summary>
        /// <param name="action">- the action to be registered</param>
        abstract registerAction: action: Action -> Nullable<Action>
        /// <summary>Unregisters an action to this action manager</summary>
        /// <param name="action">The action to be unregistered</param>
        abstract unregisterAction: action: Action -> Boolean
        /// <summary>Process a specific trigger</summary>
        /// <param name="trigger">- the trigger to process</param>
        /// <param name="evt">the event details to be processed</param>
        abstract processTrigger: trigger: float * ?evt: ActionEvent -> unit
        abstract _getEffectiveTarget: target: obj option * propertyPath: string -> obj option
        abstract _getProperty: propertyPath: string -> string
        abstract serialize: name: string -> obj option

    /// Action Manager manages all events to be triggered on a given mesh or the global scene.
    /// A single scene can have many Action Managers to handle predefined actions on specific meshes.
    type [<AllowNullLiteral>] ActionManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> ActionManager
        /// <summary>Does exist one action manager that handles actions of a given trigger</summary>
        /// <param name="trigger">- the trigger to be tested</param>
        abstract HasSpecificTrigger: trigger: float -> bool
        abstract Parse: parsedActions: obj option * ``object``: Nullable<AbstractMesh> * scene: Scene -> unit
        abstract GetTriggerName: trigger: float -> string

    /// A Condition applied to an Action
    type [<AllowNullLiteral>] Condition =
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        /// Internal only
        abstract _evaluationId: float with get, set
        /// Internal only
        abstract _currentResult: bool with get, set
        /// Check if the current condition is valid
        abstract isValid: unit -> bool
        /// Internal only
        abstract _getProperty: propertyPath: string -> string
        /// Internal only
        abstract _getEffectiveTarget: target: obj option * propertyPath: string -> obj option
        /// Serialize placeholder for child classes
        abstract serialize: unit -> obj option
        /// Internal only
        abstract _serialize: serializedCondition: obj option -> obj option

    /// A Condition applied to an Action
    type [<AllowNullLiteral>] ConditionStatic =
        /// <summary>Creates a new Condition</summary>
        /// <param name="actionManager">the manager of the action the condition is applied to</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager -> Condition

    /// Defines specific conditional operators as extensions of Condition
    type [<AllowNullLiteral>] ValueCondition =
        inherit Condition
        /// path to specify the property of the target the conditional operator uses  
        abstract propertyPath: string with get, set
        /// the value compared by the conditional operator against the current value of the property 
        abstract value: obj option with get, set
        /// the conditional operator, default ValueCondition.IsEqual 
        abstract operator: float with get, set
        /// Internal only
        abstract _IsEqual: obj with get, set
        /// Internal only
        abstract _IsDifferent: obj with get, set
        /// Internal only
        abstract _IsGreater: obj with get, set
        /// Internal only
        abstract _IsLesser: obj with get, set
        /// returns the number for IsEqual
        abstract IsEqual: float
        /// Returns the number for IsDifferent
        abstract IsDifferent: float
        /// Returns the number for IsGreater
        abstract IsGreater: float
        /// Returns the number for IsLesser
        abstract IsLesser: float
        /// Internal only The action manager for the condition
        abstract _actionManager: ActionManager with get, set
        /// Internal only
        abstract _target: obj with get, set
        /// Internal only
        abstract _effectiveTarget: obj with get, set
        /// Internal only
        abstract _property: obj with get, set
        /// Compares the given value with the property value for the specified conditional operator
        abstract isValid: unit -> bool
        /// Serialize the ValueCondition into a JSON compatible object
        abstract serialize: unit -> obj option

    /// Defines specific conditional operators as extensions of Condition
    type [<AllowNullLiteral>] ValueConditionStatic =
        /// <summary>Creates a new ValueCondition</summary>
        /// <param name="actionManager">manager for the action the condition applies to</param>
        /// <param name="target">for the action</param>
        /// <param name="propertyPath">path to specify the property of the target the conditional operator uses</param>
        /// <param name="value">the value compared by the conditional operator against the current value of the property</param>
        /// <param name="operator">the conditional operator, default ValueCondition.IsEqual</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager * target: obj option * propertyPath: string * value: obj option * ?operator: float -> ValueCondition
        /// <summary>Gets the name of the conditional operator for the ValueCondition</summary>
        /// <param name="operator">the conditional operator</param>
        abstract GetOperatorName: operator: float -> string

    /// Defines a predicate condition as an extension of Condition
    type [<AllowNullLiteral>] PredicateCondition =
        inherit Condition
        /// defines the predicate function used to validate the condition 
        abstract predicate: (unit -> bool) with get, set
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        abstract isValid: unit -> bool

    /// Defines a predicate condition as an extension of Condition
    type [<AllowNullLiteral>] PredicateConditionStatic =
        /// <summary>Creates a new PredicateCondition</summary>
        /// <param name="actionManager">manager for the action the condition applies to</param>
        /// <param name="predicate">defines the predicate function used to validate the condition</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager * predicate: (unit -> bool) -> PredicateCondition

    /// Defines a state condition as an extension of Condition
    type [<AllowNullLiteral>] StateCondition =
        inherit Condition
        abstract value: string with get, set
        /// Internal only - manager for action
        abstract _actionManager: ActionManager with get, set
        /// Internal only
        abstract _target: obj with get, set
        abstract isValid: unit -> bool
        /// Serialize the StateCondition into a JSON compatible object
        abstract serialize: unit -> obj option

    /// Defines a state condition as an extension of Condition
    type [<AllowNullLiteral>] StateConditionStatic =
        /// <summary>Creates a new StateCondition</summary>
        /// <param name="actionManager">manager for the action the condition applies to</param>
        /// <param name="target">of the condition</param>
        /// <param name="value">to compare with target state</param>
        [<Emit "new $0($1...)">] abstract Create: actionManager: ActionManager * target: obj option * value: string -> StateCondition

    type [<AllowNullLiteral>] SwitchBooleanAction =
        inherit Action
        abstract propertyPath: string with get, set
        abstract _target: obj with get, set
        abstract _effectiveTarget: obj with get, set
        abstract _property: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] SwitchBooleanActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * ?condition: Condition -> SwitchBooleanAction

    type [<AllowNullLiteral>] SetStateAction =
        inherit Action
        abstract value: string with get, set
        abstract _target: obj with get, set
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] SetStateActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * value: string * ?condition: Condition -> SetStateAction

    type [<AllowNullLiteral>] SetValueAction =
        inherit Action
        abstract propertyPath: string with get, set
        abstract value: obj option with get, set
        abstract _target: obj with get, set
        abstract _effectiveTarget: obj with get, set
        abstract _property: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] SetValueActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * value: obj option * ?condition: Condition -> SetValueAction

    type [<AllowNullLiteral>] IncrementValueAction =
        inherit Action
        abstract propertyPath: string with get, set
        abstract value: obj option with get, set
        abstract _target: obj with get, set
        abstract _effectiveTarget: obj with get, set
        abstract _property: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] IncrementValueActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * value: obj option * ?condition: Condition -> IncrementValueAction

    type [<AllowNullLiteral>] PlayAnimationAction =
        inherit Action
        abstract from: float with get, set
        abstract ``to``: float with get, set
        abstract loop: bool option with get, set
        abstract _target: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] PlayAnimationActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * from: float * ``to``: float * ?loop: bool option * ?condition: Condition -> PlayAnimationAction

    type [<AllowNullLiteral>] StopAnimationAction =
        inherit Action
        abstract _target: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] StopAnimationActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * ?condition: Condition -> StopAnimationAction

    type [<AllowNullLiteral>] DoNothingAction =
        inherit Action
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] DoNothingActionStatic =
        [<Emit "new $0($1...)">] abstract Create: ?triggerOptions: obj option * ?condition: Condition -> DoNothingAction

    type [<AllowNullLiteral>] CombineAction =
        inherit Action
        abstract children: ResizeArray<Action> with get, set
        abstract _prepare: unit -> unit
        abstract execute: evt: ActionEvent -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] CombineActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * children: ResizeArray<Action> * ?condition: Condition -> CombineAction

    type [<AllowNullLiteral>] ExecuteCodeAction =
        inherit Action
        abstract func: (ActionEvent -> unit) with get, set
        abstract execute: evt: ActionEvent -> unit

    type [<AllowNullLiteral>] ExecuteCodeActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * func: (ActionEvent -> unit) * ?condition: Condition -> ExecuteCodeAction

    type [<AllowNullLiteral>] SetParentAction =
        inherit Action
        abstract _parent: obj with get, set
        abstract _target: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] SetParentActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * parent: obj option * ?condition: Condition -> SetParentAction

    type [<AllowNullLiteral>] PlaySoundAction =
        inherit Action
        abstract _sound: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] PlaySoundActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * sound: Sound * ?condition: Condition -> PlaySoundAction

    type [<AllowNullLiteral>] StopSoundAction =
        inherit Action
        abstract _sound: obj with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] StopSoundActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * sound: Sound * ?condition: Condition -> StopSoundAction

    type [<AllowNullLiteral>] InterpolateValueAction =
        inherit Action
        abstract propertyPath: string with get, set
        abstract value: obj option with get, set
        abstract duration: float with get, set
        abstract stopOtherAnimations: bool option with get, set
        abstract onInterpolationDone: (unit -> unit) option with get, set
        abstract _target: obj with get, set
        abstract _effectiveTarget: obj with get, set
        abstract _property: obj with get, set
        abstract onInterpolationDoneObservable: Observable<InterpolateValueAction> with get, set
        abstract _prepare: unit -> unit
        abstract execute: unit -> unit
        abstract serialize: parent: obj option -> obj option

    type [<AllowNullLiteral>] InterpolateValueActionStatic =
        [<Emit "new $0($1...)">] abstract Create: triggerOptions: obj option * target: obj option * propertyPath: string * value: obj option * ?duration: float * ?condition: Condition * ?stopOtherAnimations: bool option * ?onInterpolationDone: (unit -> unit) option -> InterpolateValueAction

    type [<AllowNullLiteral>] Animatable =
        abstract target: obj option with get, set
        abstract fromFrame: float with get, set
        abstract toFrame: float with get, set
        abstract loopAnimation: bool with get, set
        abstract onAnimationEnd: (unit -> unit) option with get, set
        abstract _localDelayOffset: obj with get, set
        abstract _pausedDelay: obj with get, set
        abstract _runtimeAnimations: obj with get, set
        abstract _paused: obj with get, set
        abstract _scene: obj with get, set
        abstract _speedRatio: obj with get, set
        abstract _weight: obj with get, set
        abstract _syncRoot: obj with get, set
        abstract animationStarted: bool with get, set
        /// Gets the root Animatable used to synchronize and normalize animations
        abstract syncRoot: Animatable
        /// Gets the current frame of the first RuntimeAnimation
        /// Used to synchronize Animatables
        abstract masterFrame: float
        /// Gets or sets the animatable weight (-1.0 by default meaning not weighted)
        abstract weight: float with get, set
        /// Gets or sets the speed ratio to apply to the animatable (1.0 by default)
        abstract speedRatio: float with get, set
        /// <summary>Synchronize and normalize current Animatable with a source Animatable
        /// This is useful when using animation weights and when animations are not of the same length</summary>
        /// <param name="root">defines the root Animatable to synchronize with</param>
        abstract syncWith: root: Animatable -> Animatable
        abstract getAnimations: unit -> ResizeArray<RuntimeAnimation>
        abstract appendAnimations: target: obj option * animations: ResizeArray<Animation> -> unit
        abstract getAnimationByTargetProperty: property: string -> Nullable<Animation>
        abstract getRuntimeAnimationByTargetProperty: property: string -> Nullable<RuntimeAnimation>
        abstract reset: unit -> unit
        abstract enableBlending: blendingSpeed: float -> unit
        abstract disableBlending: unit -> unit
        abstract goToFrame: frame: float -> unit
        abstract pause: unit -> unit
        abstract restart: unit -> unit
        abstract stop: ?animationName: string -> unit
        abstract _animate: delay: float -> bool

    type [<AllowNullLiteral>] AnimatableStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * target: obj option * ?fromFrame: float * ?toFrame: float * ?loopAnimation: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) option * ?animations: obj option -> Animatable

    type [<AllowNullLiteral>] AnimationRange =
        abstract name: string with get, set
        abstract from: float with get, set
        abstract ``to``: float with get, set
        abstract clone: unit -> AnimationRange

    type [<AllowNullLiteral>] AnimationRangeStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * from: float * ``to``: float -> AnimationRange

    /// Composed of a frame, and an action function
    type [<AllowNullLiteral>] AnimationEvent =
        abstract frame: float with get, set
        abstract action: (unit -> unit) with get, set
        abstract onlyOnce: bool option with get, set
        abstract isDone: bool with get, set

    /// Composed of a frame, and an action function
    type [<AllowNullLiteral>] AnimationEventStatic =
        [<Emit "new $0($1...)">] abstract Create: frame: float * action: (unit -> unit) * ?onlyOnce: bool option -> AnimationEvent

    type [<AllowNullLiteral>] PathCursor =
        abstract path: obj with get, set
        abstract _onchange: obj with get, set
        abstract value: float with get, set
        abstract animations: ResizeArray<Animation> with get, set
        abstract getPoint: unit -> Vector3
        abstract moveAhead: ?step: float -> PathCursor
        abstract moveBack: ?step: float -> PathCursor
        abstract move: step: float -> PathCursor
        abstract ensureLimits: unit -> unit
        abstract raiseOnChange: unit -> unit
        abstract onchange: f: (PathCursor -> unit) -> PathCursor

    type [<AllowNullLiteral>] PathCursorStatic =
        [<Emit "new $0($1...)">] abstract Create: path: Path2 -> PathCursor

    type [<AllowNullLiteral>] IAnimationKey =
        abstract frame: float with get, set
        abstract value: obj option with get, set
        abstract inTangent: obj option with get, set
        abstract outTangent: obj option with get, set
        abstract interpolation: AnimationKeyInterpolation option with get, set

    type [<RequireQualifiedAccess>] AnimationKeyInterpolation =
        | STEP = 1

    /// Class used to store any kind of animation
    type [<AllowNullLiteral>] Animation =
        abstract name: string with get, set
        abstract targetProperty: string with get, set
        abstract framePerSecond: float with get, set
        abstract dataType: float with get, set
        abstract loopMode: float option with get, set
        abstract enableBlending: bool option with get, set
        /// Use matrix interpolation instead of using direct key value when animating matrices
        abstract AllowMatricesInterpolation: bool with get, set
        /// When matrix interpolation is enabled, this boolean forces the system to use Matrix.DecomposeLerp instead of Matrix.Lerp. Interpolation is more precise but slower
        abstract AllowMatrixDecomposeForInterpolation: bool with get, set
        abstract _keys: obj with get, set
        abstract _easingFunction: obj with get, set
        abstract _runtimeAnimations: ResizeArray<RuntimeAnimation> with get, set
        abstract _events: obj with get, set
        abstract targetPropertyPath: ResizeArray<string> with get, set
        abstract blendingSpeed: float with get, set
        abstract _ranges: obj with get, set
        /// Return the array of runtime animations currently using this animation
        abstract runtimeAnimations: ResizeArray<RuntimeAnimation>
        abstract hasRunningRuntimeAnimations: bool
        /// <param name="fullDetails">- support for multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string
        /// Add an event to this animation.
        abstract addEvent: ``event``: AnimationEvent -> unit
        /// <summary>Remove all events found at the given frame</summary>
        /// <param name="frame"></param>
        abstract removeEvents: frame: float -> unit
        abstract getEvents: unit -> ResizeArray<AnimationEvent>
        abstract createRange: name: string * from: float * ``to``: float -> unit
        abstract deleteRange: name: string * ?deleteFrames: bool -> unit
        abstract getRange: name: string -> Nullable<AnimationRange>
        abstract getKeys: unit -> Array<IAnimationKey>
        abstract getHighestFrame: unit -> float
        abstract getEasingFunction: unit -> IEasingFunction
        abstract setEasingFunction: easingFunction: EasingFunction -> unit
        abstract floatInterpolateFunction: startValue: float * endValue: float * gradient: float -> float
        abstract floatInterpolateFunctionWithTangents: startValue: float * outTangent: float * endValue: float * inTangent: float * gradient: float -> float
        abstract quaternionInterpolateFunction: startValue: Quaternion * endValue: Quaternion * gradient: float -> Quaternion
        abstract quaternionInterpolateFunctionWithTangents: startValue: Quaternion * outTangent: Quaternion * endValue: Quaternion * inTangent: Quaternion * gradient: float -> Quaternion
        abstract vector3InterpolateFunction: startValue: Vector3 * endValue: Vector3 * gradient: float -> Vector3
        abstract vector3InterpolateFunctionWithTangents: startValue: Vector3 * outTangent: Vector3 * endValue: Vector3 * inTangent: Vector3 * gradient: float -> Vector3
        abstract vector2InterpolateFunction: startValue: Vector2 * endValue: Vector2 * gradient: float -> Vector2
        abstract vector2InterpolateFunctionWithTangents: startValue: Vector2 * outTangent: Vector2 * endValue: Vector2 * inTangent: Vector2 * gradient: float -> Vector2
        abstract sizeInterpolateFunction: startValue: Size * endValue: Size * gradient: float -> Size
        abstract color3InterpolateFunction: startValue: Color3 * endValue: Color3 * gradient: float -> Color3
        /// <summary>Defines the function to use to interpolate matrices</summary>
        /// <param name="startValue">defines the start matrix</param>
        /// <param name="endValue">defines the end matrix</param>
        /// <param name="gradient">defines the gradient between both matrices</param>
        /// <param name="result">defines an optional target matrix where to store the interpolation</param>
        abstract matrixInterpolateFunction: startValue: Matrix * endValue: Matrix * gradient: float * ?result: Matrix -> Matrix
        abstract clone: unit -> Animation
        abstract setKeys: values: Array<IAnimationKey> -> unit
        abstract serialize: unit -> obj option
        abstract _ANIMATIONTYPE_FLOAT: obj with get, set
        abstract _ANIMATIONTYPE_VECTOR3: obj with get, set
        abstract _ANIMATIONTYPE_QUATERNION: obj with get, set
        abstract _ANIMATIONTYPE_MATRIX: obj with get, set
        abstract _ANIMATIONTYPE_COLOR3: obj with get, set
        abstract _ANIMATIONTYPE_VECTOR2: obj with get, set
        abstract _ANIMATIONTYPE_SIZE: obj with get, set
        abstract _ANIMATIONLOOPMODE_RELATIVE: obj with get, set
        abstract _ANIMATIONLOOPMODE_CYCLE: obj with get, set
        abstract _ANIMATIONLOOPMODE_CONSTANT: obj with get, set
        abstract ANIMATIONTYPE_FLOAT: float
        abstract ANIMATIONTYPE_VECTOR3: float
        abstract ANIMATIONTYPE_VECTOR2: float
        abstract ANIMATIONTYPE_SIZE: float
        abstract ANIMATIONTYPE_QUATERNION: float
        abstract ANIMATIONTYPE_MATRIX: float
        abstract ANIMATIONTYPE_COLOR3: float
        abstract ANIMATIONLOOPMODE_RELATIVE: float
        abstract ANIMATIONLOOPMODE_CYCLE: float
        abstract ANIMATIONLOOPMODE_CONSTANT: float

    /// Class used to store any kind of animation
    type [<AllowNullLiteral>] AnimationStatic =
        abstract _PrepareAnimation: name: string * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction -> Nullable<Animation>
        /// <summary>Sets up an animation.</summary>
        /// <param name="property">the property to animate</param>
        /// <param name="animationType">the animation type to apply</param>
        /// <param name="easingFunction">the easing function used in the animation</param>
        abstract CreateAnimation: property: string * animationType: float * framePerSecond: float * easingFunction: EasingFunction -> Animation
        /// <summary>Create and start an animation on a node</summary>
        /// <param name="name">defines the name of the global animation that will be run on all nodes</param>
        /// <param name="node">defines the root node where the animation will take place</param>
        /// <param name="targetProperty">defines property to animate</param>
        /// <param name="framePerSecond">defines the number of frame per second yo use</param>
        /// <param name="totalFrame">defines the number of frames in total</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loopMode">defines which loop mode you want to use (off by default)</param>
        /// <param name="easingFunction">defines the easing function to use (linear by default)</param>
        /// <param name="onAnimationEnd">defines the callback to call when animation end</param>
        abstract CreateAndStartAnimation: name: string * node: Node * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        /// <summary>Create and start an animation on a node and its descendants</summary>
        /// <param name="name">defines the name of the global animation that will be run on all nodes</param>
        /// <param name="node">defines the root node where the animation will take place</param>
        /// <param name="directDescendantsOnly">if true only direct descendants will be used, if false direct and also indirect (children of children, an so on in a recursive manner) descendants will be used.</param>
        /// <param name="targetProperty">defines property to animate</param>
        /// <param name="framePerSecond">defines the number of frame per second yo use</param>
        /// <param name="totalFrame">defines the number of frames in total</param>
        /// <param name="from">defines the initial value</param>
        /// <param name="to">defines the final value</param>
        /// <param name="loopMode">defines which loop mode you want to use (off by default)</param>
        /// <param name="easingFunction">defines the easing function to use (linear by default)</param>
        /// <param name="onAnimationEnd">defines the callback to call when an animation ends (will be called once per node)</param>
        abstract CreateAndStartHierarchyAnimation: name: string * node: Node * directDescendantsOnly: bool * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction * ?onAnimationEnd: (unit -> unit) -> Nullable<ResizeArray<Animatable>>
        abstract CreateMergeAndStartAnimation: name: string * node: Node * targetProperty: string * framePerSecond: float * totalFrame: float * from: obj option * ``to``: obj option * ?loopMode: float * ?easingFunction: EasingFunction * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        /// <summary>Transition property of the Camera to the target Value.</summary>
        /// <param name="property">The property to transition</param>
        /// <param name="targetValue">The target Value of the property</param>
        /// <param name="host">The object where the property to animate belongs</param>
        /// <param name="scene">Scene used to run the animation</param>
        /// <param name="frameRate">Framerate (in frame/s) to use</param>
        /// <param name="transition">The transition type we want to use</param>
        /// <param name="duration">The duration of the animation, in milliseconds</param>
        /// <param name="onAnimationEnd">Call back trigger at the end of the animation.</param>
        abstract TransitionTo: property: string * targetValue: obj option * host: obj option * scene: Scene * frameRate: float * transition: Animation * duration: float * ?onAnimationEnd: Nullable<(unit -> unit)> -> Nullable<Animatable>
        [<Emit "new $0($1...)">] abstract Create: name: string * targetProperty: string * framePerSecond: float * dataType: float * ?loopMode: float option * ?enableBlending: bool option -> Animation
        abstract Parse: parsedAnimation: obj option -> Animation
        abstract AppendSerializedAnimations: source: IAnimatable * destination: obj option -> obj option

    /// This class defines the direct association between an animation and a target
    type [<AllowNullLiteral>] TargetedAnimation =
        abstract animation: Animation with get, set
        abstract target: obj option with get, set

    /// This class defines the direct association between an animation and a target
    type [<AllowNullLiteral>] TargetedAnimationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> TargetedAnimation

    /// Use this class to create coordinated animations on multiple targets
    type [<AllowNullLiteral>] AnimationGroup =
        inherit IDisposable
        abstract name: string with get, set
        abstract _scene: obj with get, set
        abstract _targetedAnimations: obj with get, set
        abstract _animatables: obj with get, set
        abstract _from: obj with get, set
        abstract _to: obj with get, set
        abstract _isStarted: obj with get, set
        abstract _speedRatio: obj with get, set
        abstract onAnimationEndObservable: Observable<TargetedAnimation> with get, set
        /// Define if the animations are started
        abstract isStarted: bool
        /// Gets or sets the speed ratio to use for all animations
        /// Gets or sets the speed ratio to use for all animations
        abstract speedRatio: float with get, set
        /// Gets the targeted animations for this animation group
        abstract targetedAnimations: Array<TargetedAnimation>
        /// returning the list of animatables controlled by this animation group.
        abstract animatables: Array<Animatable>
        /// <summary>Add an animation (with its target) in the group</summary>
        /// <param name="animation">defines the animation we want to add</param>
        /// <param name="target">defines the target of the animation</param>
        abstract addTargetedAnimation: animation: Animation * target: obj option -> TargetedAnimation
        /// <summary>This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame
        /// It can add constant keys at begin or end</summary>
        /// <param name="beginFrame">defines the new begin frame for all animations. It can't be bigger than the smallest begin frame of all animations</param>
        /// <param name="endFrame">defines the new end frame for all animations. It can't be smaller than the largest end frame of all animations</param>
        abstract normalize: ?beginFrame: float * ?endFrame: float -> AnimationGroup
        /// <summary>Start all animations on given targets</summary>
        /// <param name="loop">defines if animations must loop</param>
        /// <param name="speedRatio">defines the ratio to apply to animation speed (1 by default)</param>
        /// <param name="from">defines the from key (optional)</param>
        /// <param name="to">defines the to key (optional)</param>
        abstract start: ?loop: bool * ?speedRatio: float * ?from: float * ?``to``: float -> AnimationGroup
        /// Pause all animations
        abstract pause: unit -> AnimationGroup
        /// <summary>Play all animations to initial state
        /// This function will start() the animations if they were not started or will restart() them if they were paused</summary>
        /// <param name="loop">defines if animations must loop</param>
        abstract play: ?loop: bool -> AnimationGroup
        /// Reset all animations to initial state
        abstract reset: unit -> AnimationGroup
        /// Restart animations from key 0
        abstract restart: unit -> AnimationGroup
        /// Stop all animations
        abstract stop: unit -> AnimationGroup
        /// <summary>Set animation weight for all animatables</summary>
        /// <param name="weight">defines the weight to use</param>
        abstract setWeightForAllAnimatables: weight: float -> AnimationGroup
        /// <summary>Synchronize and normalize all animatables with a source animatable</summary>
        /// <param name="root">defines the root animatable to synchronize with</param>
        abstract syncAllAnimationsWith: root: Animatable -> AnimationGroup
        /// <summary>Goes to a specific frame in this animation group</summary>
        /// <param name="frame">the frame number to go to</param>
        abstract goToFrame: frame: float -> AnimationGroup
        /// Dispose all associated resources
        abstract dispose: unit -> unit

    /// Use this class to create coordinated animations on multiple targets
    type [<AllowNullLiteral>] AnimationGroupStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Nullable<Scene> -> AnimationGroup

    /// Class used to override all child animations of a given target
    type [<AllowNullLiteral>] AnimationPropertiesOverride =
        /// Gets or sets a value indicating if animation blending must be used
        abstract enableBlending: bool with get, set
        /// Gets or sets the blending speed to use when enableBlending is true
        abstract blendingSpeed: float with get, set
        /// Gets or sets the default loop mode to use
        abstract loopMode: float with get, set

    /// Class used to override all child animations of a given target
    type [<AllowNullLiteral>] AnimationPropertiesOverrideStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AnimationPropertiesOverride

    type [<AllowNullLiteral>] IEasingFunction =
        abstract ease: gradient: float -> float

    type [<AllowNullLiteral>] EasingFunction =
        inherit IEasingFunction
        abstract _EASINGMODE_EASEIN: obj with get, set
        abstract _EASINGMODE_EASEOUT: obj with get, set
        abstract _EASINGMODE_EASEINOUT: obj with get, set
        abstract EASINGMODE_EASEIN: float
        abstract EASINGMODE_EASEOUT: float
        abstract EASINGMODE_EASEINOUT: float
        abstract _easingMode: obj with get, set
        abstract setEasingMode: easingMode: float -> unit
        abstract getEasingMode: unit -> float
        abstract easeInCore: gradient: float -> float
        abstract ease: gradient: float -> float

    type [<AllowNullLiteral>] EasingFunctionStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EasingFunction

    type [<AllowNullLiteral>] CircleEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] CircleEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CircleEase

    type [<AllowNullLiteral>] BackEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract amplitude: float with get, set
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] BackEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: ?amplitude: float -> BackEase

    type [<AllowNullLiteral>] BounceEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract bounces: float with get, set
        abstract bounciness: float with get, set
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] BounceEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: ?bounces: float * ?bounciness: float -> BounceEase

    type [<AllowNullLiteral>] CubicEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] CubicEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CubicEase

    type [<AllowNullLiteral>] ElasticEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract oscillations: float with get, set
        abstract springiness: float with get, set
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] ElasticEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: ?oscillations: float * ?springiness: float -> ElasticEase

    type [<AllowNullLiteral>] ExponentialEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract exponent: float with get, set
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] ExponentialEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: ?exponent: float -> ExponentialEase

    type [<AllowNullLiteral>] PowerEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract power: float with get, set
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] PowerEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: ?power: float -> PowerEase

    type [<AllowNullLiteral>] QuadraticEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] QuadraticEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> QuadraticEase

    type [<AllowNullLiteral>] QuarticEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] QuarticEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> QuarticEase

    type [<AllowNullLiteral>] QuinticEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] QuinticEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> QuinticEase

    type [<AllowNullLiteral>] SineEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] SineEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SineEase

    type [<AllowNullLiteral>] BezierCurveEase =
        inherit EasingFunction
        inherit IEasingFunction
        abstract x1: float with get, set
        abstract y1: float with get, set
        abstract x2: float with get, set
        abstract y2: float with get, set
        abstract easeInCore: gradient: float -> float

    type [<AllowNullLiteral>] BezierCurveEaseStatic =
        [<Emit "new $0($1...)">] abstract Create: ?x1: float * ?y1: float * ?x2: float * ?y2: float -> BezierCurveEase

    type [<AllowNullLiteral>] RuntimeAnimation =
        abstract _currentFrame: obj with get, set
        abstract _animation: obj with get, set
        abstract _target: obj with get, set
        abstract _host: obj with get, set
        abstract _originalValue: obj with get, set
        abstract _originalBlendValue: obj with get, set
        abstract _offsetsCache: obj with get, set
        abstract _highLimitsCache: obj with get, set
        abstract _stopped: obj with get, set
        abstract _blendingFactor: obj with get, set
        abstract _scene: obj with get, set
        abstract _currentValue: obj with get, set
        abstract _workValue: obj option with get, set
        abstract _activeTarget: obj with get, set
        abstract _targetPath: obj with get, set
        abstract _weight: obj with get, set
        /// Gets the current frame
        abstract currentFrame: float
        /// Gets the weight of the runtime animation
        abstract weight: float
        /// Gets the original value of the runtime animation
        abstract originalValue: obj option
        /// Gets the current value of the runtime animation
        abstract currentValue: obj option
        /// Gets the path where to store the animated value in the target
        abstract targetPath: string
        /// Gets the actual target of the runtime animation
        abstract target: obj option
        abstract animation: Animation
        abstract reset: unit -> unit
        abstract isStopped: unit -> bool
        abstract dispose: unit -> unit
        abstract _getKeyValue: value: obj -> unit
        abstract _interpolate: currentFrame: obj * repeatCount: obj * ?loopMode: obj * ?offsetValue: obj * ?highLimitValue: obj -> unit
        /// <summary>Affect the interpolated value to the target</summary>
        /// <param name="currentValue">defines the value computed by the animation</param>
        /// <param name="weight">defines the weight to apply to this value</param>
        abstract setValue: currentValue: obj option * ?weight: float -> unit
        abstract _setValue: target: obj * currentValue: obj * ?weight: obj -> unit
        abstract _getCorrectLoopMode: unit -> unit
        /// <summary>Move the current animation to a given frame</summary>
        /// <param name="frame">defines the frame to move to</param>
        abstract goToFrame: frame: float -> unit
        abstract _prepareForSpeedRatioChange: newSpeedRatio: float -> unit
        abstract _ratioOffset: obj with get, set
        abstract _previousDelay: obj with get, set
        abstract _previousRatio: obj with get, set
        /// <summary>Execute the current animation</summary>
        /// <param name="delay">defines the delay to add to the current frame</param>
        /// <param name="from">defines the lower bound of the animation range</param>
        /// <param name="to">defines the upper bound of the animation range</param>
        /// <param name="loop">defines if the current animation must loop</param>
        /// <param name="speedRatio">defines the current speed ratio</param>
        /// <param name="weight">defines the weight of the animation (default is -1 so no weight)</param>
        abstract animate: delay: float * from: float * ``to``: float * loop: bool * speedRatio: float * ?weight: float -> bool

    type [<AllowNullLiteral>] RuntimeAnimationStatic =
        /// <summary>Create a new RuntimeAnimation object</summary>
        /// <param name="target">defines the target of the animation</param>
        /// <param name="animation">defines the source {BABYLON.Animation} object</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="host">defines the initiating Animatable</param>
        [<Emit "new $0($1...)">] abstract Create: target: obj option * animation: Animation * scene: Scene * host: Animatable -> RuntimeAnimation

    type [<AllowNullLiteral>] Analyser =
        abstract SMOOTHING: float with get, set
        abstract FFT_SIZE: float with get, set
        abstract BARGRAPHAMPLITUDE: float with get, set
        abstract DEBUGCANVASPOS: obj with get, set
        abstract DEBUGCANVASSIZE: obj with get, set
        abstract _byteFreqs: obj with get, set
        abstract _byteTime: obj with get, set
        abstract _floatFreqs: obj with get, set
        abstract _webAudioAnalyser: obj with get, set
        abstract _debugCanvas: obj with get, set
        abstract _debugCanvasContext: obj with get, set
        abstract _scene: obj with get, set
        abstract _registerFunc: obj with get, set
        abstract _audioEngine: obj with get, set
        abstract getFrequencyBinCount: unit -> float
        abstract getByteFrequencyData: unit -> Uint8Array
        abstract getByteTimeDomainData: unit -> Uint8Array
        abstract getFloatFrequencyData: unit -> Uint8Array
        abstract drawDebugCanvas: unit -> unit
        abstract stopDebugCanvas: unit -> unit
        abstract connectAudioNodes: inputAudioNode: AudioNode * outputAudioNode: AudioNode -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] AnalyserStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> Analyser

    type [<AllowNullLiteral>] AudioEngine =
        abstract _audioContext: obj with get, set
        abstract _audioContextInitialized: obj with get, set
        abstract canUseWebAudio: bool with get, set
        abstract masterGain: GainNode with get, set
        abstract _connectedAnalyser: obj with get, set
        abstract WarnedWebAudioUnsupported: bool with get, set
        abstract unlocked: bool with get, set
        abstract onAudioUnlocked: (unit -> obj option) with get, set
        abstract isMP3supported: bool with get, set
        abstract isOGGsupported: bool with get, set
        abstract audioContext: Nullable<AudioContext>
        abstract _unlockiOSaudio: unit -> unit
        abstract _initializeAudioContext: unit -> unit
        abstract dispose: unit -> unit
        abstract getGlobalVolume: unit -> float
        abstract setGlobalVolume: newVolume: float -> unit
        abstract connectToAnalyser: analyser: Analyser -> unit

    type [<AllowNullLiteral>] AudioEngineStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AudioEngine

    type [<AllowNullLiteral>] Sound =
        abstract name: string with get, set
        abstract autoplay: bool with get, set
        abstract loop: bool with get, set
        abstract useCustomAttenuation: bool with get, set
        abstract soundTrackId: float with get, set
        abstract spatialSound: bool with get, set
        abstract refDistance: float with get, set
        abstract rolloffFactor: float with get, set
        abstract maxDistance: float with get, set
        abstract distanceModel: string with get, set
        abstract _panningModel: obj with get, set
        abstract onended: (unit -> obj option) with get, set
        abstract _playbackRate: obj with get, set
        abstract _streaming: obj with get, set
        abstract _startTime: obj with get, set
        abstract _startOffset: obj with get, set
        abstract _position: obj with get, set
        abstract _localDirection: obj with get, set
        abstract _volume: obj with get, set
        abstract _isReadyToPlay: obj with get, set
        abstract isPlaying: bool with get, set
        abstract isPaused: bool with get, set
        abstract _isDirectional: obj with get, set
        abstract _readyToPlayCallback: obj with get, set
        abstract _audioBuffer: obj with get, set
        abstract _soundSource: obj with get, set
        abstract _streamingSource: obj with get, set
        abstract _soundPanner: obj with get, set
        abstract _soundGain: obj with get, set
        abstract _inputAudioNode: obj with get, set
        abstract _ouputAudioNode: obj with get, set
        abstract _coneInnerAngle: obj with get, set
        abstract _coneOuterAngle: obj with get, set
        abstract _coneOuterGain: obj with get, set
        abstract _scene: obj with get, set
        abstract _connectedMesh: obj with get, set
        abstract _customAttenuationFunction: obj with get, set
        abstract _registerFunc: obj with get, set
        abstract _isOutputConnected: obj with get, set
        abstract _htmlAudioElement: obj with get, set
        abstract _urlType: obj with get, set
        abstract dispose: unit -> unit
        abstract isReady: unit -> bool
        abstract _soundLoaded: audioData: obj -> unit
        abstract setAudioBuffer: audioBuffer: AudioBuffer -> unit
        abstract updateOptions: options: obj option -> unit
        abstract _createSpatialParameters: unit -> unit
        abstract _updateSpatialParameters: unit -> unit
        abstract switchPanningModelToHRTF: unit -> unit
        abstract switchPanningModelToEqualPower: unit -> unit
        abstract _switchPanningModel: unit -> unit
        abstract connectToSoundTrackAudioNode: soundTrackAudioNode: AudioNode -> unit
        /// <summary>Transform this sound into a directional source</summary>
        /// <param name="coneInnerAngle">Size of the inner cone in degree</param>
        /// <param name="coneOuterAngle">Size of the outer cone in degree</param>
        /// <param name="coneOuterGain">Volume of the sound outside the outer cone (between 0.0 and 1.0)</param>
        abstract setDirectionalCone: coneInnerAngle: float * coneOuterAngle: float * coneOuterGain: float -> unit
        abstract setPosition: newPosition: Vector3 -> unit
        abstract setLocalDirectionToMesh: newLocalDirection: Vector3 -> unit
        abstract _updateDirection: unit -> unit
        abstract updateDistanceFromListener: unit -> unit
        abstract setAttenuationFunction: callback: (float -> float -> float -> float -> float -> float) -> unit
        /// <summary>Play the sound</summary>
        /// <param name="time">(optional) Start the sound after X seconds. Start immediately (0) by default.</param>
        /// <param name="offset">(optional) Start the sound setting it at a specific time</param>
        abstract play: ?time: float * ?offset: float -> unit
        abstract _onended: unit -> unit
        /// <summary>Stop the sound</summary>
        /// <param name="time">(optional) Stop the sound after X seconds. Stop immediately (0) by default.</param>
        abstract stop: ?time: float -> unit
        abstract pause: unit -> unit
        abstract setVolume: newVolume: float * ?time: float -> unit
        abstract setPlaybackRate: newPlaybackRate: float -> unit
        abstract getVolume: unit -> float
        abstract attachToMesh: meshToConnectTo: AbstractMesh -> unit
        abstract detachFromMesh: unit -> unit
        abstract _onRegisterAfterWorldMatrixUpdate: node: obj -> unit
        abstract clone: unit -> Nullable<Sound>
        abstract getAudioBuffer: unit -> AudioBuffer option
        abstract serialize: unit -> obj option

    type [<AllowNullLiteral>] SoundStatic =
        /// <summary>Create a sound and attach it to a scene</summary>
        /// <param name="name">Name of your sound</param>
        /// <param name="urlOrArrayBuffer">Url to the sound to load async or ArrayBuffer</param>
        /// <param name="readyToPlayCallback">Provide a callback function if you'd like to load your code once the sound is ready to be played</param>
        /// <param name="options">Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * urlOrArrayBuffer: obj option * scene: Scene * ?readyToPlayCallback: Nullable<(unit -> unit)> * ?options: obj option -> Sound
        abstract Parse: parsedSound: obj option * scene: Scene * rootUrl: string * ?sourceSound: Sound -> Sound

    type [<AllowNullLiteral>] SoundTrack =
        abstract _outputAudioNode: obj with get, set
        abstract _scene: obj with get, set
        abstract id: float with get, set
        abstract soundCollection: Array<Sound> with get, set
        abstract _isMainTrack: obj with get, set
        abstract _connectedAnalyser: obj with get, set
        abstract _options: obj with get, set
        abstract _isInitialized: obj with get, set
        abstract _initializeSoundTrackAudioGraph: unit -> unit
        abstract dispose: unit -> unit
        abstract AddSound: sound: Sound -> unit
        abstract RemoveSound: sound: Sound -> unit
        abstract setVolume: newVolume: float -> unit
        abstract switchPanningModelToHRTF: unit -> unit
        abstract switchPanningModelToEqualPower: unit -> unit
        abstract connectToAnalyser: analyser: Analyser -> unit

    type [<AllowNullLiteral>] SoundTrackStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?options: obj option -> SoundTrack

    type [<AllowNullLiteral>] Behavior<'T> =
        abstract name: string with get, set
        abstract init: unit -> unit
        abstract attach: node: 'T -> unit
        abstract detach: unit -> unit

    /// Class used to store bone information
    type [<AllowNullLiteral>] Bone =
        inherit Node
        /// defines the bone name
        abstract name: string with get, set
        abstract _tmpVecs: obj with get, set
        abstract _tmpQuat: obj with get, set
        abstract _tmpMats: obj with get, set
        /// Gets the list of child bones
        abstract children: ResizeArray<Bone> with get, set
        /// Gets the animations associated with this bone 
        abstract animations: ResizeArray<Animation> with get, set
        /// Gets or sets bone length
        abstract length: float with get, set
        abstract _index: Nullable<float> with get, set
        abstract _skeleton: obj with get, set
        abstract _localMatrix: obj with get, set
        abstract _restPose: obj with get, set
        abstract _baseMatrix: obj with get, set
        abstract _absoluteTransform: obj with get, set
        abstract _invertedAbsoluteTransform: obj with get, set
        abstract _parent: obj with get, set
        abstract _scalingDeterminant: obj with get, set
        abstract _worldTransform: obj with get, set
        abstract _localScaling: obj with get, set
        abstract _localRotation: obj with get, set
        abstract _localPosition: obj with get, set
        abstract _needToDecompose: obj with get, set
        abstract _needToCompose: obj with get, set
        abstract _matrix: Matrix with get, set
        /// Gets the parent skeleton
        abstract getSkeleton: unit -> Skeleton
        /// Gets parent bone
        abstract getParent: unit -> Nullable<Bone>
        /// <summary>Sets the parent bone</summary>
        /// <param name="parent">defines the parent (can be null if the bone is the root)</param>
        /// <param name="updateDifferenceMatrix">defines if the difference matrix must be updated</param>
        abstract setParent: parent: Nullable<Bone> * ?updateDifferenceMatrix: bool -> unit
        /// Gets the local matrix
        abstract getLocalMatrix: unit -> Matrix
        /// Gets the base matrix (initial matrix which remains unchanged)
        abstract getBaseMatrix: unit -> Matrix
        /// Gets the rest pose matrix
        abstract getRestPose: unit -> Matrix
        /// Gets a matrix used to store world matrix (ie. the matrix sent to shaders)
        abstract getWorldMatrix: unit -> Matrix
        /// Sets the local matrix to rest pose matrix
        abstract returnToRest: unit -> unit
        /// Gets the inverse of the absolute transform matrix.
        /// This matrix will be multiplied by local matrix to get the difference matrix (ie. the difference between original state and current state)
        abstract getInvertedAbsoluteTransform: unit -> Matrix
        /// Gets the absolute transform matrix (ie base matrix * parent world matrix)
        abstract getAbsoluteTransform: unit -> Matrix
        /// Gets or sets current position (in local space) 
        abstract position: Vector3 with get, set
        /// Gets or sets current rotation (in local space) 
        abstract rotation: Vector3 with get, set
        /// Gets or sets current rotation quaternion (in local space) 
        abstract rotationQuaternion: Quaternion with get, set
        /// Gets or sets current scaling (in local space) 
        abstract scaling: Vector3 with get, set
        /// Gets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride>
        abstract _decompose: unit -> unit
        abstract _compose: unit -> unit
        /// <summary>Update the local matrix</summary>
        /// <param name="matrix">defines the new local matrix</param>
        /// <param name="updateDifferenceMatrix">defines if the difference matrix must be updated</param>
        abstract updateMatrix: matrix: Matrix * ?updateDifferenceMatrix: bool -> unit
        abstract _updateDifferenceMatrix: ?rootMatrix: Matrix -> unit
        /// Flag the bone as dirty (Forcing it to update everything)
        abstract markAsDirty: unit -> unit
        abstract _markAsDirtyAndCompose: unit -> unit
        abstract _markAsDirtyAndDecompose: unit -> unit
        /// <summary>Copy an animation range from another bone</summary>
        /// <param name="source">defines the source bone</param>
        /// <param name="rangeName">defines the range name to copy</param>
        /// <param name="frameOffset">defines the frame offset</param>
        /// <param name="rescaleAsRequired">defines if rescaling must be applied if required</param>
        /// <param name="skelDimensionsRatio">defines the scaling ratio</param>
        abstract copyAnimationRange: source: Bone * rangeName: string * frameOffset: float * ?rescaleAsRequired: bool * ?skelDimensionsRatio: Nullable<Vector3> -> bool
        /// <summary>Translate the bone in local or world space</summary>
        /// <param name="vec">The amount to translate the bone</param>
        /// <param name="space">The space that the translation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract translate: vec: Vector3 * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the postion of the bone in local or world space</summary>
        /// <param name="position">The position to set the bone</param>
        /// <param name="space">The space that the position is in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract setPosition: position: Vector3 * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the absolute position of the bone (world space)</summary>
        /// <param name="position">The position to set the bone</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract setAbsolutePosition: position: Vector3 * ?mesh: AbstractMesh -> unit
        /// <summary>Scale the bone on the x, y and z axes (in local space)</summary>
        /// <param name="x">The amount to scale the bone on the x axis</param>
        /// <param name="y">The amount to scale the bone on the y axis</param>
        /// <param name="z">The amount to scale the bone on the z axis</param>
        /// <param name="scaleChildren">sets this to true if children of the bone should be scaled as well (false by default)</param>
        abstract scale: x: float * y: float * z: float * ?scaleChildren: bool -> unit
        /// <summary>Set the bone scaling in local space</summary>
        /// <param name="scale">defines the scaling vector</param>
        abstract setScale: scale: Vector3 -> unit
        /// Gets the current scaling in local space
        abstract getScale: unit -> Vector3
        /// <summary>Gets the current scaling in local space and stores it in a target vector</summary>
        /// <param name="result">defines the target vector</param>
        abstract getScaleToRef: result: Vector3 -> unit
        /// <summary>Set the yaw, pitch, and roll of the bone in local or world space</summary>
        /// <param name="yaw">The rotation of the bone on the y axis</param>
        /// <param name="pitch">The rotation of the bone on the x axis</param>
        /// <param name="roll">The rotation of the bone on the z axis</param>
        /// <param name="space">The space that the axes of rotation are in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract setYawPitchRoll: yaw: float * pitch: float * roll: float * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Add a rotation to the bone on an axis in local or world space</summary>
        /// <param name="axis">The axis to rotate the bone on</param>
        /// <param name="amount">The amount to rotate the bone</param>
        /// <param name="space">The space that the axis is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract rotate: axis: Vector3 * amount: float * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the rotation of the bone to a particular axis angle in local or world space</summary>
        /// <param name="axis">The axis to rotate the bone on</param>
        /// <param name="angle">The angle that the bone should be rotated to</param>
        /// <param name="space">The space that the axis is in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract setAxisAngle: axis: Vector3 * angle: float * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the euler rotation of the bone in local of world space</summary>
        /// <param name="rotation">The euler rotation that the bone should be set to</param>
        /// <param name="space">The space that the rotation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract setRotation: rotation: Vector3 * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the quaternion rotation of the bone in local of world space</summary>
        /// <param name="quat">The quaternion rotation that the bone should be set to</param>
        /// <param name="space">The space that the rotation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract setRotationQuaternion: quat: Quaternion * ?space: Space * ?mesh: AbstractMesh -> unit
        /// <summary>Set the rotation matrix of the bone in local of world space</summary>
        /// <param name="rotMat">The rotation matrix that the bone should be set to</param>
        /// <param name="space">The space that the rotation is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract setRotationMatrix: rotMat: Matrix * ?space: Space * ?mesh: AbstractMesh -> unit
        abstract _rotateWithMatrix: rmat: obj * ?space: obj * ?mesh: obj -> unit
        abstract _getNegativeRotationToRef: rotMatInv: obj * ?mesh: obj -> unit
        /// <summary>Get the position of the bone in local or world space</summary>
        /// <param name="space">The space that the returned position is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        abstract getPosition: ?space: Space * ?mesh: Nullable<AbstractMesh> -> Vector3
        /// <summary>Copy the position of the bone to a vector3 in local or world space</summary>
        /// <param name="space">The space that the returned position is in</param>
        /// <param name="mesh">The mesh that this bone is attached to. This is only used in world space</param>
        /// <param name="result">The vector3 to copy the position to</param>
        abstract getPositionToRef: space: Space option * mesh: Nullable<AbstractMesh> * result: Vector3 -> unit
        /// <summary>Get the absolute position of the bone (world space)</summary>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getAbsolutePosition: ?mesh: Nullable<AbstractMesh> -> Vector3
        /// <summary>Copy the absolute position of the bone (world space) to the result param</summary>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 to copy the absolute position to</param>
        abstract getAbsolutePositionToRef: mesh: AbstractMesh * result: Vector3 -> unit
        /// Compute the absolute transforms of this bone and its children
        abstract computeAbsoluteTransforms: unit -> unit
        /// <summary>Get the world direction from an axis that is in the local space of the bone</summary>
        /// <param name="localAxis">The local direction that is used to compute the world direction</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getDirection: localAxis: Vector3 * ?mesh: Nullable<AbstractMesh> -> Vector3
        /// <summary>Copy the world direction to a vector3 from an axis that is in the local space of the bone</summary>
        /// <param name="localAxis">The local direction that is used to compute the world direction</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 that the world direction will be copied to</param>
        abstract getDirectionToRef: localAxis: Vector3 * mesh: AbstractMesh option * result: Vector3 -> unit
        /// <summary>Get the euler rotation of the bone in local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract getRotation: ?space: Space * ?mesh: Nullable<AbstractMesh> -> Vector3
        /// <summary>Copy the euler rotation of the bone to a vector3.  The rotation can be in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        /// <param name="result">The vector3 that the rotation should be copied to</param>
        abstract getRotationToRef: space: Space option * mesh: AbstractMesh option * result: Vector3 -> unit
        /// <summary>Get the quaternion rotation of the bone in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract getRotationQuaternion: ?space: Space * ?mesh: Nullable<AbstractMesh> -> Quaternion
        /// <summary>Copy the quaternion rotation of the bone to a quaternion.  The rotation can be in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        /// <param name="result">The quaternion that the rotation should be copied to</param>
        abstract getRotationQuaternionToRef: space: Space option * mesh: AbstractMesh option * result: Quaternion -> unit
        /// <summary>Get the rotation matrix of the bone in local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        abstract getRotationMatrix: space: Space option * mesh: AbstractMesh -> Matrix
        /// <summary>Copy the rotation matrix of the bone to a matrix.  The rotation can be in either local or world space</summary>
        /// <param name="space">The space that the rotation should be in</param>
        /// <param name="mesh">The mesh that this bone is attached to.  This is only used in world space</param>
        /// <param name="result">The quaternion that the rotation should be copied to</param>
        abstract getRotationMatrixToRef: space: Space option * mesh: AbstractMesh * result: Matrix -> unit
        /// <summary>Get the world position of a point that is in the local space of the bone</summary>
        /// <param name="position">The local position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getAbsolutePositionFromLocal: position: Vector3 * ?mesh: Nullable<AbstractMesh> -> Vector3
        /// <summary>Get the world position of a point that is in the local space of the bone and copy it to the result param</summary>
        /// <param name="position">The local position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 that the world position should be copied to</param>
        abstract getAbsolutePositionFromLocalToRef: position: Vector3 * mesh: AbstractMesh option * result: Vector3 -> unit
        /// <summary>Get the local position of a point that is in world space</summary>
        /// <param name="position">The world position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        abstract getLocalPositionFromAbsolute: position: Vector3 * ?mesh: Nullable<AbstractMesh> -> Vector3
        /// <summary>Get the local position of a point that is in world space and copy it to the result param</summary>
        /// <param name="position">The world position</param>
        /// <param name="mesh">The mesh that this bone is attached to</param>
        /// <param name="result">The vector3 that the local position should be copied to</param>
        abstract getLocalPositionFromAbsoluteToRef: position: Vector3 * mesh: AbstractMesh option * result: Vector3 -> unit

    /// Class used to store bone information
    type [<AllowNullLiteral>] BoneStatic =
        /// <summary>Create a new bone</summary>
        /// <param name="name">defines the bone name</param>
        /// <param name="skeleton">defines the parent skeleton</param>
        /// <param name="parentBone">defines the parent (can be null if the bone is the root)</param>
        /// <param name="localMatrix">defines the local matrix</param>
        /// <param name="restPose">defines the rest pose matrix</param>
        /// <param name="baseMatrix">defines the base matrix</param>
        /// <param name="index">defines index of the bone in the hiearchy</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * skeleton: Skeleton * ?parentBone: Nullable<Bone> * ?localMatrix: Nullable<Matrix> * ?restPose: Nullable<Matrix> * ?baseMatrix: Nullable<Matrix> * ?index: Nullable<float> -> Bone

    /// Class used to apply inverse kinematics to bones
    type [<AllowNullLiteral>] BoneIKController =
        abstract _tmpVecs: obj with get, set
        abstract _tmpQuat: obj with get, set
        abstract _tmpMats: obj with get, set
        /// Gets or sets the target mesh
        abstract targetMesh: AbstractMesh with get, set
        /// Gets or sets the mesh used as pole 
        abstract poleTargetMesh: AbstractMesh with get, set
        /// Gets or sets the bone used as pole
        abstract poleTargetBone: Nullable<Bone> with get, set
        /// Gets or sets the target position
        abstract targetPosition: Vector3 with get, set
        /// Gets or sets the pole target position
        abstract poleTargetPosition: Vector3 with get, set
        /// Gets or sets the pole target local offset
        abstract poleTargetLocalOffset: Vector3 with get, set
        /// Gets or sets the pole angle
        abstract poleAngle: float with get, set
        /// Gets or sets the mesh associated with the controller
        abstract mesh: AbstractMesh with get, set
        /// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
        abstract slerpAmount: float with get, set
        abstract _bone1Quat: obj with get, set
        abstract _bone1Mat: obj with get, set
        abstract _bone2Ang: obj with get, set
        abstract _bone1: obj with get, set
        abstract _bone2: obj with get, set
        abstract _bone1Length: obj with get, set
        abstract _bone2Length: obj with get, set
        abstract _maxAngle: obj with get, set
        abstract _maxReach: obj with get, set
        abstract _rightHandedSystem: obj with get, set
        abstract _bendAxis: obj with get, set
        abstract _slerping: obj with get, set
        abstract _adjustRoll: obj with get, set
        /// Gets or sets maximum allowed angle
        abstract maxAngle: float with get, set
        abstract _setMaxAngle: ang: obj -> unit
        /// Force the controller to update the bones
        abstract update: unit -> unit

    /// Class used to apply inverse kinematics to bones
    type [<AllowNullLiteral>] BoneIKControllerStatic =
        /// <summary>Creates a new BoneIKController</summary>
        /// <param name="mesh">defines the mesh to control</param>
        /// <param name="bone">defines the bone to control</param>
        /// <param name="options">defines options to set up the controller</param>
        [<Emit "new $0($1...)">] abstract Create: mesh: AbstractMesh * bone: Bone * ?options: BoneIKControllerStaticOptions -> BoneIKController

    type [<AllowNullLiteral>] BoneIKControllerStaticOptions =
        abstract targetMesh: AbstractMesh option with get, set
        abstract poleTargetMesh: AbstractMesh option with get, set
        abstract poleTargetBone: Bone option with get, set
        abstract poleTargetLocalOffset: Vector3 option with get, set
        abstract poleAngle: float option with get, set
        abstract bendAxis: Vector3 option with get, set
        abstract maxAngle: float option with get, set
        abstract slerpAmount: float option with get, set

    /// Class used to make a bone look toward a point in space
    type [<AllowNullLiteral>] BoneLookController =
        abstract _tmpVecs: obj with get, set
        abstract _tmpQuat: obj with get, set
        abstract _tmpMats: obj with get, set
        /// The target Vector3 that the bone will look at
        abstract target: Vector3 with get, set
        /// The mesh that the bone is attached to
        abstract mesh: AbstractMesh with get, set
        /// The bone that will be looking to the target
        abstract bone: Bone with get, set
        /// The up axis of the coordinate system that is used when the bone is rotated
        abstract upAxis: Vector3 with get, set
        /// The space that the up axis is in - BABYLON.Space.BONE, BABYLON.Space.LOCAL (default), or BABYLON.Space.WORLD
        abstract upAxisSpace: Space with get, set
        /// Used to make an adjustment to the yaw of the bone
        abstract adjustYaw: float with get, set
        /// Used to make an adjustment to the pitch of the bone
        abstract adjustPitch: float with get, set
        /// Used to make an adjustment to the roll of the bone
        abstract adjustRoll: float with get, set
        /// The amount to slerp (spherical linear interpolation) to the target.  Set this to a value between 0 and 1 (a value of 1 disables slerp)
        abstract slerpAmount: float with get, set
        abstract _minYaw: obj with get, set
        abstract _maxYaw: obj with get, set
        abstract _minPitch: obj with get, set
        abstract _maxPitch: obj with get, set
        abstract _minYawSin: obj with get, set
        abstract _minYawCos: obj with get, set
        abstract _maxYawSin: obj with get, set
        abstract _maxYawCos: obj with get, set
        abstract _midYawConstraint: obj with get, set
        abstract _minPitchTan: obj with get, set
        abstract _maxPitchTan: obj with get, set
        abstract _boneQuat: obj with get, set
        abstract _slerping: obj with get, set
        abstract _transformYawPitch: obj with get, set
        abstract _transformYawPitchInv: obj with get, set
        abstract _firstFrameSkipped: obj with get, set
        abstract _yawRange: obj with get, set
        abstract _fowardAxis: obj with get, set
        /// Gets or sets the minimum yaw angle that the bone can look to
        abstract minYaw: float with get, set
        /// Gets or sets the maximum yaw angle that the bone can look to
        abstract maxYaw: float with get, set
        /// Gets or sets the minimum pitch angle that the bone can look to
        abstract minPitch: float with get, set
        /// Gets or sets the maximum pitch angle that the bone can look to
        abstract maxPitch: float with get, set
        /// Update the bone to look at the target.  This should be called before the scene is rendered (use scene.registerBeforeRender())
        abstract update: unit -> unit
        abstract _getAngleDiff: ang1: obj * ang2: obj -> unit
        abstract _getAngleBetween: ang1: obj * ang2: obj -> unit
        abstract _isAngleBetween: ang: obj * ang1: obj * ang2: obj -> unit

    /// Class used to make a bone look toward a point in space
    type [<AllowNullLiteral>] BoneLookControllerStatic =
        /// <summary>Create a BoneLookController</summary>
        /// <param name="mesh">the mesh that the bone belongs to</param>
        /// <param name="bone">the bone that will be looking to the target</param>
        /// <param name="target">the target Vector3 to look at</param>
        [<Emit "new $0($1...)">] abstract Create: mesh: AbstractMesh * bone: Bone * target: Vector3 * ?options: BoneLookControllerStaticOptions -> BoneLookController

    type [<AllowNullLiteral>] BoneLookControllerStaticOptions =
        abstract maxYaw: float option with get, set
        abstract minYaw: float option with get, set
        abstract maxPitch: float option with get, set
        abstract minPitch: float option with get, set
        abstract slerpAmount: float option with get, set
        abstract upAxis: Vector3 option with get, set
        abstract upAxisSpace: Space option with get, set
        abstract yawAxis: Vector3 option with get, set
        abstract pitchAxis: Vector3 option with get, set
        abstract adjustYaw: float option with get, set
        abstract adjustPitch: float option with get, set
        abstract adjustRoll: float option with get, set

    /// Class used to handle skinning animations
    type [<AllowNullLiteral>] Skeleton =
        inherit IAnimatable
        /// defines the skeleton name 
        abstract name: string with get, set
        /// defines the skeleton Id 
        abstract id: string with get, set
        /// Gets the list of child bones
        abstract bones: ResizeArray<Bone> with get, set
        /// Gets an estimate of the dimension of the skeleton at rest
        abstract dimensionsAtRest: Vector3 with get, set
        /// Gets a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)
        abstract needInitialSkinMatrix: bool with get, set
        /// Gets the list of animations attached to this skeleton
        abstract animations: Array<Animation> with get, set
        abstract _scene: obj with get, set
        abstract _isDirty: obj with get, set
        abstract _transformMatrices: obj with get, set
        abstract _meshesWithPoseMatrix: obj with get, set
        abstract _animatables: obj with get, set
        abstract _identity: obj with get, set
        abstract _synchronizedWithMesh: obj with get, set
        abstract _ranges: obj with get, set
        abstract _lastAbsoluteTransformsUpdateId: obj with get, set
        /// Specifies if the skeleton should be serialized
        abstract doNotSerialize: bool with get, set
        abstract _animationPropertiesOverride: obj with get, set
        /// Gets or sets the animation properties override
        abstract animationPropertiesOverride: Nullable<AnimationPropertiesOverride> with get, set
        /// An observable triggered before computing the skeleton's matrices
        abstract onBeforeComputeObservable: Observable<Skeleton> with get, set
        /// <summary>Gets the list of transform matrices to send to shaders (one matrix per bone)</summary>
        /// <param name="mesh">defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)</param>
        abstract getTransformMatrices: mesh: AbstractMesh -> Float32Array
        /// Gets the current hosting scene
        abstract getScene: unit -> Scene
        /// <summary>Gets a string representing the current skeleton data</summary>
        /// <param name="fullDetails">defines a boolean indicating if we want a verbose version</param>
        abstract toString: ?fullDetails: bool -> string
        /// <summary>Get bone's index searching by name</summary>
        /// <param name="name">defines bone's name to search for</param>
        abstract getBoneIndexByName: name: string -> float
        /// <summary>Creater a new animation range</summary>
        /// <param name="name">defines the name of the range</param>
        /// <param name="from">defines the start key</param>
        /// <param name="to">defines the end key</param>
        abstract createAnimationRange: name: string * from: float * ``to``: float -> unit
        /// <summary>Delete a specific animation range</summary>
        /// <param name="name">defines the name of the range</param>
        /// <param name="deleteFrames">defines if frames must be removed as well</param>
        abstract deleteAnimationRange: name: string * ?deleteFrames: bool -> unit
        /// <summary>Gets a specific animation range</summary>
        /// <param name="name">defines the name of the range to look for</param>
        abstract getAnimationRange: name: string -> Nullable<AnimationRange>
        /// Gets the list of all animation ranges defined on this skeleton
        abstract getAnimationRanges: unit -> ResizeArray<Nullable<AnimationRange>>
        /// <summary>Copy animation range from a source skeleton.
        /// This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences</summary>
        /// <param name="source">defines the source skeleton</param>
        /// <param name="name">defines the name of the range to copy</param>
        /// <param name="rescaleAsRequired">defines if rescaling must be applied if required</param>
        abstract copyAnimationRange: source: Skeleton * name: string * ?rescaleAsRequired: bool -> bool
        /// Forces the skeleton to go to rest pose
        abstract returnToRest: unit -> unit
        abstract _getHighestAnimationFrame: unit -> unit
        /// <summary>Begin a specific animation range</summary>
        /// <param name="name">defines the name of the range to start</param>
        /// <param name="loop">defines if looping must be turned on (false by default)</param>
        /// <param name="speedRatio">defines the speed ratio to apply (1 by default)</param>
        /// <param name="onAnimationEnd">defines a callback which will be called when animation will end</param>
        abstract beginAnimation: name: string * ?loop: bool * ?speedRatio: float * ?onAnimationEnd: (unit -> unit) -> Nullable<Animatable>
        abstract _markAsDirty: unit -> unit
        abstract _registerMeshWithPoseMatrix: mesh: AbstractMesh -> unit
        abstract _unregisterMeshWithPoseMatrix: mesh: AbstractMesh -> unit
        abstract _computeTransformMatrices: targetMatrix: Float32Array * initialSkinMatrix: Nullable<Matrix> -> unit
        /// Build all resources required to render a skeleton
        abstract prepare: unit -> unit
        /// Gets the list of animatables currently running for this skeleton
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        /// <summary>Clone the current skeleton</summary>
        /// <param name="name">defines the name of the new skeleton</param>
        /// <param name="id">defines the id of the enw skeleton</param>
        abstract clone: name: string * id: string -> Skeleton
        /// <summary>Enable animation blending for this skeleton</summary>
        /// <param name="blendingSpeed">defines the blending speed to apply</param>
        abstract enableBlending: ?blendingSpeed: float -> unit
        /// Releases all resources associated with the current skeleton
        abstract dispose: unit -> unit
        /// Serialize the skeleton in a JSON object
        abstract serialize: unit -> obj option
        /// <summary>Compute all node absolute transforms</summary>
        /// <param name="forceUpdate">defines if computation must be done even if cache is up to date</param>
        abstract computeAbsoluteTransforms: ?forceUpdate: bool -> unit
        /// Gets the root pose matrix
        abstract getPoseMatrix: unit -> Nullable<Matrix>
        /// Sorts bones per internal index
        abstract sortBones: unit -> unit
        abstract _sortBones: index: obj * bones: obj * visited: obj -> unit

    /// Class used to handle skinning animations
    type [<AllowNullLiteral>] SkeletonStatic =
        /// <summary>Creates a new skeleton</summary>
        /// <param name="name">defines the skeleton name</param>
        /// <param name="id">defines the skeleton Id</param>
        /// <param name="scene">defines the hosting scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * id: string * scene: Scene -> Skeleton
        /// <summary>Creates a new skeleton from serialized data</summary>
        /// <param name="parsedSkeleton">defines the serialized data</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract Parse: parsedSkeleton: obj option * scene: Scene -> Skeleton

    type [<AllowNullLiteral>] ArcRotateCamera =
        inherit TargetCamera
        abstract alpha: float with get, set
        abstract beta: float with get, set
        abstract radius: float with get, set
        abstract _target: Vector3 with get, set
        abstract _targetHost: Nullable<AbstractMesh> with get, set
        abstract target: Vector3 with get, set
        abstract inertialAlphaOffset: float with get, set
        abstract inertialBetaOffset: float with get, set
        abstract inertialRadiusOffset: float with get, set
        abstract lowerAlphaLimit: Nullable<float> with get, set
        abstract upperAlphaLimit: Nullable<float> with get, set
        abstract lowerBetaLimit: float with get, set
        abstract upperBetaLimit: float with get, set
        abstract lowerRadiusLimit: Nullable<float> with get, set
        abstract upperRadiusLimit: Nullable<float> with get, set
        abstract inertialPanningX: float with get, set
        abstract inertialPanningY: float with get, set
        abstract pinchToPanMaxDistance: float with get, set
        abstract panningDistanceLimit: Nullable<float> with get, set
        abstract panningOriginTarget: Vector3 with get, set
        abstract panningInertia: float with get, set
        abstract angularSensibilityX: float with get, set
        abstract angularSensibilityY: float with get, set
        abstract pinchPrecision: float with get, set
        abstract pinchDeltaPercentage: float with get, set
        abstract panningSensibility: float with get, set
        abstract keysUp: ResizeArray<float> with get, set
        abstract keysDown: ResizeArray<float> with get, set
        abstract keysLeft: ResizeArray<float> with get, set
        abstract keysRight: ResizeArray<float> with get, set
        abstract wheelPrecision: float with get, set
        abstract wheelDeltaPercentage: float with get, set
        abstract zoomOnFactor: float with get, set
        abstract targetScreenOffset: Vector2 with get, set
        abstract allowUpsideDown: bool with get, set
        abstract _viewMatrix: Matrix with get, set
        abstract _useCtrlForPanning: bool with get, set
        abstract _panningMouseButton: float with get, set
        abstract inputs: ArcRotateCameraInputsManager with get, set
        abstract _reset: (unit -> unit) with get, set
        abstract panningAxis: Vector3 with get, set
        abstract _localDirection: Vector3 with get, set
        abstract _transformedDirection: Vector3 with get, set
        abstract _bouncingBehavior: obj with get, set
        abstract bouncingBehavior: Nullable<BouncingBehavior>
        abstract useBouncingBehavior: bool with get, set
        abstract _framingBehavior: obj with get, set
        abstract framingBehavior: Nullable<FramingBehavior>
        abstract useFramingBehavior: bool with get, set
        abstract _autoRotationBehavior: obj with get, set
        abstract autoRotationBehavior: Nullable<AutoRotationBehavior>
        abstract useAutoRotationBehavior: bool with get, set
        abstract onMeshTargetChangedObservable: Observable<Nullable<AbstractMesh>> with get, set
        abstract onCollide: (AbstractMesh -> unit) with get, set
        abstract checkCollisions: bool with get, set
        abstract collisionRadius: Vector3 with get, set
        abstract _collider: Collider with get, set
        abstract _previousPosition: Vector3 with get, set
        abstract _collisionVelocity: Vector3 with get, set
        abstract _newPosition: Vector3 with get, set
        abstract _previousAlpha: float with get, set
        abstract _previousBeta: float with get, set
        abstract _previousRadius: float with get, set
        abstract _collisionTriggered: bool with get, set
        abstract _targetBoundingCenter: Nullable<Vector3> with get, set
        abstract _computationVector: obj with get, set
        abstract _initCache: unit -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _getTargetPosition: unit -> Vector3
        /// Store current camera state (fov, position, etc..)
        abstract _storedAlpha: obj with get, set
        abstract _storedBeta: obj with get, set
        abstract _storedRadius: obj with get, set
        abstract _storedTarget: obj with get, set
        abstract storeState: unit -> Camera
        /// Restored camera state. You must call storeState() first
        abstract _restoreStateValues: unit -> bool
        abstract _isSynchronizedViewMatrix: unit -> bool
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool * ?useCtrlForPanning: bool * ?panningMouseButton: float -> unit
        abstract detachControl: element: HTMLElement -> unit
        abstract _checkInputs: unit -> unit
        abstract _checkLimits: unit -> unit
        abstract rebuildAnglesAndRadius: unit -> unit
        abstract setPosition: position: Vector3 -> unit
        abstract setTarget: target: U2<AbstractMesh, Vector3> * ?toBoundingCenter: bool * ?allowSamePosition: bool -> unit
        abstract _getViewMatrix: unit -> Matrix
        abstract _onCollisionPositionChange: (float -> Vector3 -> Nullable<AbstractMesh> -> unit) with get, set
        abstract zoomOn: ?meshes: ResizeArray<AbstractMesh> * ?doNotUpdateMaxZ: bool -> unit
        abstract focusOn: meshesOrMinMaxVectorAndDistance: U2<ResizeArray<AbstractMesh>, obj> * ?doNotUpdateMaxZ: bool -> unit
        abstract createRigCamera: name: string * cameraIndex: float -> Camera
        abstract _updateRigCameras: unit -> unit
        abstract dispose: unit -> unit
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] ArcRotateCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * scene: Scene -> ArcRotateCamera

    type [<AllowNullLiteral>] ArcRotateCameraInputsManager =
        inherit CameraInputsManager<ArcRotateCamera>
        abstract addMouseWheel: unit -> ArcRotateCameraInputsManager
        abstract addPointers: unit -> ArcRotateCameraInputsManager
        abstract addKeyboard: unit -> ArcRotateCameraInputsManager
        abstract addGamepad: unit -> ArcRotateCameraInputsManager
        abstract addVRDeviceOrientation: unit -> ArcRotateCameraInputsManager

    type [<AllowNullLiteral>] ArcRotateCameraInputsManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: camera: ArcRotateCamera -> ArcRotateCameraInputsManager

    type [<AllowNullLiteral>] Camera =
        inherit Node
        abstract inputs: CameraInputsManager<Camera> with get, set
        abstract _PERSPECTIVE_CAMERA: obj with get, set
        abstract _ORTHOGRAPHIC_CAMERA: obj with get, set
        abstract _FOVMODE_VERTICAL_FIXED: obj with get, set
        abstract _FOVMODE_HORIZONTAL_FIXED: obj with get, set
        abstract _RIG_MODE_NONE: obj with get, set
        abstract _RIG_MODE_STEREOSCOPIC_ANAGLYPH: obj with get, set
        abstract _RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: obj with get, set
        abstract _RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: obj with get, set
        abstract _RIG_MODE_STEREOSCOPIC_OVERUNDER: obj with get, set
        abstract _RIG_MODE_VR: obj with get, set
        abstract _RIG_MODE_WEBVR: obj with get, set
        abstract PERSPECTIVE_CAMERA: float
        abstract ORTHOGRAPHIC_CAMERA: float
        /// This is the default FOV mode for perspective cameras.
        /// This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.
        abstract FOVMODE_VERTICAL_FIXED: float
        /// This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.
        abstract FOVMODE_HORIZONTAL_FIXED: float
        abstract RIG_MODE_NONE: float
        abstract RIG_MODE_STEREOSCOPIC_ANAGLYPH: float
        abstract RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: float
        abstract RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: float
        abstract RIG_MODE_STEREOSCOPIC_OVERUNDER: float
        abstract RIG_MODE_VR: float
        abstract RIG_MODE_WEBVR: float
        abstract ForceAttachControlToAlwaysPreventDefault: bool with get, set
        abstract UseAlternateWebVRRendering: bool with get, set
        abstract position: Vector3 with get, set
        /// The vector the camera should consider as up.
        /// (default is Vector3(0, 1, 0) aka Vector3.Up())
        abstract upVector: Vector3 with get, set
        abstract orthoLeft: Nullable<float> with get, set
        abstract orthoRight: Nullable<float> with get, set
        abstract orthoBottom: Nullable<float> with get, set
        abstract orthoTop: Nullable<float> with get, set
        /// FOV is set in Radians. (default is 0.8)
        abstract fov: float with get, set
        abstract minZ: float with get, set
        abstract maxZ: float with get, set
        abstract inertia: float with get, set
        abstract mode: float with get, set
        abstract isIntermediate: bool with get, set
        abstract viewport: Viewport with get, set
        /// Restricts the camera to viewing objects with the same layerMask.
        /// A camera with a layerMask of 1 will render mesh.layerMask & camera.layerMask!== 0
        abstract layerMask: float with get, set
        /// fovMode sets the camera frustum bounds to the viewport bounds. (default is FOVMODE_VERTICAL_FIXED)
        abstract fovMode: float with get, set
        abstract cameraRigMode: float with get, set
        abstract interaxialDistance: float with get, set
        abstract isStereoscopicSideBySide: bool with get, set
        abstract _cameraRigParams: obj option with get, set
        abstract _rigCameras: ResizeArray<Camera> with get, set
        abstract _rigPostProcess: Nullable<PostProcess> with get, set
        abstract _webvrViewMatrix: Matrix with get, set
        abstract _skipRendering: bool with get, set
        abstract _alternateCamera: Camera with get, set
        abstract customRenderTargets: ResizeArray<RenderTargetTexture> with get, set
        abstract onViewMatrixChangedObservable: Observable<Camera> with get, set
        abstract onProjectionMatrixChangedObservable: Observable<Camera> with get, set
        abstract onAfterCheckInputsObservable: Observable<Camera> with get, set
        abstract onRestoreStateObservable: Observable<Camera> with get, set
        abstract _computedViewMatrix: obj with get, set
        abstract _projectionMatrix: Matrix with get, set
        abstract _doNotComputeProjectionMatrix: obj with get, set
        abstract _worldMatrix: obj with get, set
        abstract _postProcesses: ResizeArray<Nullable<PostProcess>> with get, set
        abstract _transformMatrix: obj with get, set
        abstract _activeMeshes: SmartArray<AbstractMesh> with get, set
        abstract _globalPosition: obj with get, set
        abstract _frustumPlanes: obj with get, set
        abstract _refreshFrustumPlanes: obj with get, set
        abstract _storedFov: obj with get, set
        abstract _stateStored: obj with get, set
        /// Store current camera state (fov, position, etc..)
        abstract storeState: unit -> Camera
        /// Restores the camera state values if it has been stored. You must call storeState() first
        abstract _restoreStateValues: unit -> bool
        /// Restored camera state. You must call storeState() first
        abstract restoreState: unit -> bool
        abstract getClassName: unit -> string
        /// <param name="fullDetails">- support for multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string
        abstract globalPosition: Vector3
        abstract getActiveMeshes: unit -> SmartArray<AbstractMesh>
        abstract isActiveMesh: mesh: Mesh -> bool
        /// <summary>Is this camera ready to be used/rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including post processes) has to be done (false by default)</param>
        abstract isReady: ?completeCheck: bool -> bool
        abstract _initCache: unit -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _isSynchronized: unit -> bool
        abstract _isSynchronizedViewMatrix: unit -> bool
        abstract _isSynchronizedProjectionMatrix: unit -> bool
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: HTMLElement -> unit
        abstract update: unit -> unit
        abstract _checkInputs: unit -> unit
        abstract rigCameras: ResizeArray<Camera>
        abstract rigPostProcess: Nullable<PostProcess>
        /// Internal, gets the first post proces.
        abstract _getFirstPostProcess: unit -> Nullable<PostProcess>
        abstract _cascadePostProcessesToRigCams: unit -> unit
        abstract attachPostProcess: postProcess: PostProcess * ?insertAt: Nullable<float> -> float
        abstract detachPostProcess: postProcess: PostProcess -> unit
        abstract getWorldMatrix: unit -> Matrix
        abstract _getViewMatrix: unit -> Matrix
        abstract getViewMatrix: ?force: bool -> Matrix
        abstract freezeProjectionMatrix: ?projection: Matrix -> unit
        abstract unfreezeProjectionMatrix: unit -> unit
        abstract getProjectionMatrix: ?force: bool -> Matrix
        abstract getTranformationMatrix: unit -> Matrix
        abstract updateFrustumPlanes: unit -> unit
        abstract isInFrustum: target: ICullable -> bool
        abstract isCompletelyInFrustum: target: ICullable -> bool
        abstract getForwardRay: ?length: float * ?transform: Matrix * ?origin: Vector3 -> Ray
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        abstract leftCamera: Nullable<FreeCamera>
        abstract rightCamera: Nullable<FreeCamera>
        abstract getLeftTarget: unit -> Nullable<Vector3>
        abstract getRightTarget: unit -> Nullable<Vector3>
        abstract setCameraRigMode: mode: float * rigParams: obj option -> unit
        abstract _getVRProjectionMatrix: unit -> unit
        abstract _updateCameraRotationMatrix: unit -> unit
        abstract _updateWebVRCameraRotationMatrix: unit -> unit
        /// This function MUST be overwritten by the different WebVR cameras available.
        /// The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
        abstract _getWebVRProjectionMatrix: unit -> Matrix
        /// This function MUST be overwritten by the different WebVR cameras available.
        /// The context in which it is running is the RIG camera. So 'this' is the TargetCamera, left or right.
        abstract _getWebVRViewMatrix: unit -> Matrix
        abstract setCameraRigParameter: name: string * value: obj option -> unit
        /// needs to be overridden by children so sub has required properties to be copied
        abstract createRigCamera: name: string * cameraIndex: float -> Nullable<Camera>
        /// May need to be overridden by children
        abstract _updateRigCameras: unit -> unit
        abstract _setupInputs: unit -> unit
        abstract serialize: unit -> obj option
        abstract clone: name: string -> Camera
        abstract getDirection: localAxis: Vector3 -> Vector3
        abstract getDirectionToRef: localAxis: Vector3 * result: Vector3 -> unit
        abstract computeWorldMatrix: unit -> Matrix

    type [<AllowNullLiteral>] CameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> Camera
        abstract GetConstructorFromName: ``type``: string * name: string * scene: Scene * ?interaxial_distance: float * ?isStereoscopicSideBySide: bool -> (unit -> Camera)
        abstract Parse: parsedCamera: obj option * scene: Scene -> Camera

    type [<AllowNullLiteral>] ICameraInput<'TCamera> =
        abstract camera: Nullable<'TCamera> with get, set
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string
        abstract attachControl: (HTMLElement -> bool -> unit) with get, set
        abstract detachControl: (Nullable<HTMLElement> -> unit) with get, set
        abstract checkInputs: (unit -> unit) option with get, set

    type [<AllowNullLiteral>] CameraInputsMap<'TCamera> =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: name: string -> ICameraInput<'TCamera> with get, set
        [<Emit "$0[$1]{{=$2}}">] abstract Item: idx: float -> ICameraInput<'TCamera> with get, set

    type [<AllowNullLiteral>] CameraInputsManager<'TCamera> =
        abstract attached: CameraInputsMap<'TCamera> with get, set
        abstract attachedElement: Nullable<HTMLElement> with get, set
        abstract noPreventDefault: bool with get, set
        abstract camera: 'TCamera with get, set
        abstract checkInputs: (unit -> unit) with get, set
        /// <summary>Add an input method to a camera.
        /// builtin inputs example: camera.inputs.addGamepad();
        /// custom inputs example: camera.inputs.add(new BABYLON.FreeCameraGamepadInput());</summary>
        /// <param name="input">camera input method</param>
        abstract add: input: ICameraInput<'TCamera> -> unit
        /// <summary>Remove a specific input method from a camera
        /// example: camera.inputs.remove(camera.inputs.attached.mouse);</summary>
        /// <param name="inputToRemove">camera input method</param>
        abstract remove: inputToRemove: ICameraInput<'TCamera> -> unit
        abstract removeByType: inputType: string -> unit
        abstract _addCheckInputs: fn: obj -> unit
        abstract attachInput: input: ICameraInput<'TCamera> -> unit
        abstract attachElement: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachElement: element: HTMLElement * ?disconnect: bool -> unit
        abstract rebuildInputCheck: unit -> unit
        /// Remove all attached input methods from a camera
        abstract clear: unit -> unit
        abstract serialize: serializedCamera: obj option -> unit
        abstract parse: parsedCamera: obj option -> unit

    type [<AllowNullLiteral>] CameraInputsManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: camera: 'TCamera -> CameraInputsManager<'TCamera>

    /// This is a camera specifically designed to react to device orientation events such as a modern mobile device
    /// being tilted forward or back and left or right.
    type [<AllowNullLiteral>] DeviceOrientationCamera =
        inherit FreeCamera
        abstract _initialQuaternion: obj with get, set
        abstract _quaternionCache: obj with get, set
        /// Gets the current instance class name ("DeviceOrientationCamera").
        /// This helps avoiding instanceof at run time.
        abstract getClassName: unit -> string
        /// Checks and applies the current values of the inputs to the camera. (Internal use only)
        abstract _checkInputs: unit -> unit
        /// <summary>Reset the camera to its default orientation on the specified axis only.</summary>
        /// <param name="axis">The axis to reset</param>
        abstract resetToCurrentRotation: ?axis: Axis -> unit

    /// This is a camera specifically designed to react to device orientation events such as a modern mobile device
    /// being tilted forward or back and left or right.
    type [<AllowNullLiteral>] DeviceOrientationCameraStatic =
        /// <summary>Creates a new device orientation camera</summary>
        /// <param name="name">The name of the camera</param>
        /// <param name="position">The start position camera</param>
        /// <param name="scene">The scene the camera belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> DeviceOrientationCamera

    type [<AllowNullLiteral>] FollowCamera =
        inherit TargetCamera
        abstract radius: float with get, set
        abstract rotationOffset: float with get, set
        abstract heightOffset: float with get, set
        abstract cameraAcceleration: float with get, set
        abstract maxCameraSpeed: float with get, set
        abstract lockedTarget: Nullable<AbstractMesh> with get, set
        abstract getRadians: degrees: obj -> unit
        abstract follow: cameraTarget: obj -> unit
        abstract _checkInputs: unit -> unit
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] FollowCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?lockedTarget: Nullable<AbstractMesh> -> FollowCamera

    type [<AllowNullLiteral>] ArcFollowCamera =
        inherit TargetCamera
        abstract alpha: float with get, set
        abstract beta: float with get, set
        abstract radius: float with get, set
        abstract target: Nullable<AbstractMesh> with get, set
        abstract _cartesianCoordinates: obj with get, set
        abstract follow: unit -> unit
        abstract _checkInputs: unit -> unit
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] ArcFollowCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Nullable<AbstractMesh> * scene: Scene -> ArcFollowCamera

    type [<AllowNullLiteral>] FreeCamera =
        inherit TargetCamera
        abstract ellipsoid: Vector3 with get, set
        abstract ellipsoidOffset: Vector3 with get, set
        abstract checkCollisions: bool with get, set
        abstract applyGravity: bool with get, set
        abstract inputs: FreeCameraInputsManager with get, set
        /// Gets the input sensibility for a mouse input. (default is 2000.0)
        /// Higher values reduce sensitivity.
        /// Sets the input sensibility for a mouse input. (default is 2000.0)
        /// Higher values reduce sensitivity.
        abstract angularSensibility: float with get, set
        abstract keysUp: ResizeArray<float> with get, set
        abstract keysDown: ResizeArray<float> with get, set
        abstract keysLeft: ResizeArray<float> with get, set
        abstract keysRight: ResizeArray<float> with get, set
        abstract onCollide: (AbstractMesh -> unit) with get, set
        abstract _collider: obj with get, set
        abstract _needMoveForGravity: obj with get, set
        abstract _oldPosition: obj with get, set
        abstract _diffPosition: obj with get, set
        abstract _newPosition: obj with get, set
        abstract _localDirection: Vector3 with get, set
        abstract _transformedDirection: Vector3 with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: HTMLElement -> unit
        abstract _collisionMask: obj with get, set
        abstract collisionMask: float with get, set
        abstract _collideWithWorld: displacement: Vector3 -> unit
        abstract _onCollisionPositionChange: obj with get, set
        abstract _checkInputs: unit -> unit
        abstract _decideIfNeedsToMove: unit -> bool
        abstract _updatePosition: unit -> unit
        abstract dispose: unit -> unit
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] FreeCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> FreeCamera

    type [<AllowNullLiteral>] FreeCameraInputsManager =
        inherit CameraInputsManager<FreeCamera>
        abstract addKeyboard: unit -> FreeCameraInputsManager
        abstract addMouse: ?touchEnabled: bool -> FreeCameraInputsManager
        abstract addGamepad: unit -> FreeCameraInputsManager
        abstract addDeviceOrientation: unit -> FreeCameraInputsManager
        abstract addTouch: unit -> FreeCameraInputsManager
        abstract addVirtualJoystick: unit -> FreeCameraInputsManager

    type [<AllowNullLiteral>] FreeCameraInputsManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: camera: FreeCamera -> FreeCameraInputsManager

    type [<AllowNullLiteral>] GamepadCamera =
        inherit UniversalCamera
        abstract gamepadAngularSensibility: float with get, set
        abstract gamepadMoveSensibility: float with get, set
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] GamepadCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> GamepadCamera

    type [<AllowNullLiteral>] AnaglyphFreeCamera =
        inherit FreeCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] AnaglyphFreeCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphFreeCamera

    type [<AllowNullLiteral>] AnaglyphArcRotateCamera =
        inherit ArcRotateCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] AnaglyphArcRotateCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphArcRotateCamera

    type [<AllowNullLiteral>] AnaglyphGamepadCamera =
        inherit GamepadCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] AnaglyphGamepadCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphGamepadCamera

    type [<AllowNullLiteral>] AnaglyphUniversalCamera =
        inherit UniversalCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] AnaglyphUniversalCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * scene: Scene -> AnaglyphUniversalCamera

    type [<AllowNullLiteral>] StereoscopicFreeCamera =
        inherit FreeCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] StereoscopicFreeCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicFreeCamera

    type [<AllowNullLiteral>] StereoscopicArcRotateCamera =
        inherit ArcRotateCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] StereoscopicArcRotateCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicArcRotateCamera

    type [<AllowNullLiteral>] StereoscopicGamepadCamera =
        inherit GamepadCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] StereoscopicGamepadCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicGamepadCamera

    type [<AllowNullLiteral>] StereoscopicUniversalCamera =
        inherit UniversalCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] StereoscopicUniversalCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * interaxialDistance: float * isStereoscopicSideBySide: bool * scene: Scene -> StereoscopicUniversalCamera

    type [<AllowNullLiteral>] TargetCamera =
        inherit Camera
        abstract cameraDirection: Vector3 with get, set
        abstract cameraRotation: Vector2 with get, set
        abstract rotation: Vector3 with get, set
        abstract rotationQuaternion: Quaternion with get, set
        abstract speed: float with get, set
        abstract noRotationConstraint: bool with get, set
        abstract lockedTarget: obj option with get, set
        abstract _currentTarget: Vector3 with get, set
        abstract _viewMatrix: Matrix with get, set
        abstract _camMatrix: Matrix with get, set
        abstract _cameraTransformMatrix: Matrix with get, set
        abstract _cameraRotationMatrix: Matrix with get, set
        abstract _rigCamTransformMatrix: obj with get, set
        abstract _referencePoint: Vector3 with get, set
        abstract _currentUpVector: obj with get, set
        abstract _transformedReferencePoint: Vector3 with get, set
        abstract _lookAtTemp: Matrix with get, set
        abstract _tempMatrix: Matrix with get, set
        abstract _reset: (unit -> unit) with get, set
        abstract getFrontPosition: distance: float -> Vector3
        abstract _getLockedTargetPosition: unit -> Nullable<Vector3>
        /// Store current camera state (fov, position, etc..)
        abstract _storedPosition: obj with get, set
        abstract _storedRotation: obj with get, set
        abstract _storedRotationQuaternion: obj with get, set
        abstract storeState: unit -> Camera
        /// Restored camera state. You must call storeState() first
        abstract _restoreStateValues: unit -> bool
        abstract _initCache: unit -> unit
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        abstract _isSynchronizedViewMatrix: unit -> bool
        abstract _computeLocalCameraSpeed: unit -> float
        abstract setTarget: target: Vector3 -> unit
        /// Return the current target position of the camera. This value is expressed in local space.
        abstract getTarget: unit -> Vector3
        abstract _decideIfNeedsToMove: unit -> bool
        abstract _updatePosition: unit -> unit
        abstract _checkInputs: unit -> unit
        abstract _updateCameraRotationMatrix: unit -> unit
        abstract _getViewMatrix: unit -> Matrix
        abstract createRigCamera: name: string * cameraIndex: float -> Nullable<Camera>
        abstract _updateRigCameras: unit -> unit
        abstract _getRigCamPosition: halfSpace: obj * result: obj -> unit
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] TargetCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> TargetCamera

    type [<AllowNullLiteral>] TouchCamera =
        inherit FreeCamera
        abstract touchAngularSensibility: float with get, set
        abstract touchMoveSensibility: float with get, set
        abstract getClassName: unit -> string
        abstract _setupInputs: unit -> unit

    type [<AllowNullLiteral>] TouchCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> TouchCamera

    type [<AllowNullLiteral>] UniversalCamera =
        inherit TouchCamera
        abstract gamepadAngularSensibility: float with get, set
        abstract gamepadMoveSensibility: float with get, set
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] UniversalCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> UniversalCamera

    type [<AllowNullLiteral>] VirtualJoysticksCamera =
        inherit FreeCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] VirtualJoysticksCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> VirtualJoysticksCamera

    module Debug =

        type [<AllowNullLiteral>] IExports =
            abstract AxesViewer: AxesViewerStatic

        /// The Axes viewer will show 3 axes in a specific point in space
        type [<AllowNullLiteral>] AxesViewer =
            abstract _xline: obj with get, set
            abstract _yline: obj with get, set
            abstract _zline: obj with get, set
            abstract _xmesh: obj with get, set
            abstract _ymesh: obj with get, set
            abstract _zmesh: obj with get, set
            abstract scene: Nullable<Scene> with get, set
            abstract scaleLines: float with get, set
            abstract update: position: Vector3 * xaxis: Vector3 * yaxis: Vector3 * zaxis: Vector3 -> unit
            abstract dispose: unit -> unit

        /// The Axes viewer will show 3 axes in a specific point in space
        type [<AllowNullLiteral>] AxesViewerStatic =
            [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?scaleLines: float -> AxesViewer

    module Debug =

        type [<AllowNullLiteral>] IExports =
            abstract BoneAxesViewer: BoneAxesViewerStatic

        /// The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
        type [<AllowNullLiteral>] BoneAxesViewer =
            inherit AxesViewer
            abstract mesh: Nullable<Mesh> with get, set
            abstract bone: Nullable<Bone> with get, set
            abstract pos: Vector3 with get, set
            abstract xaxis: Vector3 with get, set
            abstract yaxis: Vector3 with get, set
            abstract zaxis: Vector3 with get, set
            abstract update: unit -> unit
            abstract dispose: unit -> unit

        /// The BoneAxesViewer will attach 3 axes to a specific bone of a specific mesh
        type [<AllowNullLiteral>] BoneAxesViewerStatic =
            [<Emit "new $0($1...)">] abstract Create: scene: Scene * bone: Bone * mesh: Mesh * ?scaleLines: float -> BoneAxesViewer

    type [<AllowNullLiteral>] DebugLayer =
        abstract _scene: obj with get, set
        abstract InspectorURL: string with get, set
        abstract _inspector: obj with get, set
        abstract BJSINSPECTOR: obj with get, set
        /// Creates the inspector window. 
        abstract _createInspector: ?config: obj -> unit
        abstract isVisible: unit -> bool
        abstract hide: unit -> unit
        abstract show: ?config: DebugLayerShowConfig -> unit

    type [<AllowNullLiteral>] DebugLayerShowConfig =
        abstract popup: bool option with get, set
        abstract initialTab: float option with get, set
        abstract parentElement: HTMLElement option with get, set
        abstract newColors: obj option with get, set

    type [<AllowNullLiteral>] DebugLayerStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> DebugLayer

    module Debug =

        type [<AllowNullLiteral>] IExports =
            abstract PhysicsViewer: PhysicsViewerStatic

        /// Used to show the physics impostor around the specific mesh.
        type [<AllowNullLiteral>] PhysicsViewer =
            abstract _impostors: Array<Nullable<PhysicsImpostor>> with get, set
            abstract _meshes: Array<Nullable<AbstractMesh>> with get, set
            abstract _scene: Nullable<Scene> with get, set
            abstract _numMeshes: float with get, set
            abstract _physicsEnginePlugin: Nullable<IPhysicsEnginePlugin> with get, set
            abstract _renderFunction: obj with get, set
            abstract _debugBoxMesh: obj with get, set
            abstract _debugSphereMesh: obj with get, set
            abstract _debugMaterial: obj with get, set
            abstract _updateDebugMeshes: unit -> unit
            abstract showImpostor: impostor: PhysicsImpostor -> unit
            abstract hideImpostor: impostor: Nullable<PhysicsImpostor> -> unit
            abstract _getDebugMaterial: scene: obj -> unit
            abstract _getDebugBoxMesh: scene: obj -> unit
            abstract _getDebugSphereMesh: scene: obj -> unit
            abstract _getDebugMesh: impostor: obj * scene: obj -> unit
            abstract dispose: unit -> unit

        /// Used to show the physics impostor around the specific mesh.
        type [<AllowNullLiteral>] PhysicsViewerStatic =
            [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PhysicsViewer

    type [<AllowNullLiteral>] RayHelper =
        abstract ray: Nullable<Ray> with get, set
        abstract _renderPoints: obj with get, set
        abstract _renderLine: obj with get, set
        abstract _renderFunction: obj with get, set
        abstract _scene: obj with get, set
        abstract _updateToMeshFunction: obj with get, set
        abstract _attachedToMesh: obj with get, set
        abstract _meshSpaceDirection: obj with get, set
        abstract _meshSpaceOrigin: obj with get, set
        abstract show: scene: Scene * color: Color3 -> unit
        abstract hide: unit -> unit
        abstract _render: unit -> unit
        abstract attachToMesh: mesh: AbstractMesh * ?meshSpaceDirection: Vector3 * ?meshSpaceOrigin: Vector3 * ?length: float -> unit
        abstract detachFromMesh: unit -> unit
        abstract _updateToMesh: unit -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] RayHelperStatic =
        abstract CreateAndShow: ray: Ray * scene: Scene * color: Color3 -> RayHelper
        [<Emit "new $0($1...)">] abstract Create: ray: Ray -> RayHelper

    module Debug =

        type [<AllowNullLiteral>] IExports =
            abstract SkeletonViewer: SkeletonViewerStatic

        /// Demo available here: http://www.babylonjs-playground.com/#1BZJVJ#8
        type [<AllowNullLiteral>] SkeletonViewer =
            abstract skeleton: Skeleton with get, set
            abstract mesh: AbstractMesh with get, set
            abstract autoUpdateBonesMatrices: bool with get, set
            abstract renderingGroupId: float with get, set
            abstract color: Color3 with get, set
            abstract _scene: obj with get, set
            abstract _debugLines: obj with get, set
            abstract _debugMesh: obj with get, set
            abstract _isEnabled: obj with get, set
            abstract _renderFunction: obj with get, set
            abstract isEnabled: bool with get, set
            abstract _getBonePosition: position: obj * bone: obj * meshMat: obj * ?x: obj * ?y: obj * ?z: obj -> unit
            abstract _getLinesForBonesWithLength: bones: obj * meshMat: obj -> unit
            abstract _getLinesForBonesNoLength: bones: obj * meshMat: obj -> unit
            abstract update: unit -> unit
            abstract dispose: unit -> unit

        /// Demo available here: http://www.babylonjs-playground.com/#1BZJVJ#8
        type [<AllowNullLiteral>] SkeletonViewerStatic =
            [<Emit "new $0($1...)">] abstract Create: skeleton: Skeleton * mesh: AbstractMesh * scene: Scene * ?autoUpdateBonesMatrices: bool * ?renderingGroupId: float -> SkeletonViewer

    type [<AllowNullLiteral>] Collider =
        /// Define if a collision was found 
        abstract collisionFound: bool with get, set
        /// Define last intersection point in local space
        abstract intersectionPoint: Vector3 with get, set
        /// Define last collided mesh
        abstract collidedMesh: Nullable<AbstractMesh> with get, set
        abstract _collisionPoint: obj with get, set
        abstract _planeIntersectionPoint: obj with get, set
        abstract _tempVector: obj with get, set
        abstract _tempVector2: obj with get, set
        abstract _tempVector3: obj with get, set
        abstract _tempVector4: obj with get, set
        abstract _edge: obj with get, set
        abstract _baseToVertex: obj with get, set
        abstract _destinationPoint: obj with get, set
        abstract _slidePlaneNormal: obj with get, set
        abstract _displacementVector: obj with get, set
        abstract _radius: Vector3 with get, set
        abstract _retry: float with get, set
        abstract _velocity: obj with get, set
        abstract _basePoint: obj with get, set
        abstract _epsilon: obj with get, set
        abstract _velocityWorldLength: float with get, set
        abstract _basePointWorld: Vector3 with get, set
        abstract _velocityWorld: obj with get, set
        abstract _normalizedVelocity: obj with get, set
        abstract _initialVelocity: Vector3 with get, set
        abstract _initialPosition: Vector3 with get, set
        abstract _nearestDistance: obj with get, set
        abstract _collisionMask: obj with get, set
        abstract collisionMask: float with get, set
        /// Gets the plane normal used to compute the sliding response (in local space)
        abstract slidePlaneNormal: Vector3
        abstract _initialize: source: Vector3 * dir: Vector3 * e: float -> unit
        abstract _checkPointInTriangle: point: Vector3 * pa: Vector3 * pb: Vector3 * pc: Vector3 * n: Vector3 -> bool
        abstract _canDoCollision: sphereCenter: Vector3 * sphereRadius: float * vecMin: Vector3 * vecMax: Vector3 -> bool
        abstract _testTriangle: faceIndex: float * trianglePlaneArray: Array<Plane> * p1: Vector3 * p2: Vector3 * p3: Vector3 * hasMaterial: bool -> unit
        abstract _collide: trianglePlaneArray: Array<Plane> * pts: ResizeArray<Vector3> * indices: IndicesArray * indexStart: float * indexEnd: float * decal: float * hasMaterial: bool -> unit
        abstract _getResponse: pos: Vector3 * vel: Vector3 -> unit

    type [<AllowNullLiteral>] ColliderStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Collider

    type [<AllowNullLiteral>] ICollisionCoordinator =
        abstract getNewPosition: position: Vector3 * displacement: Vector3 * collider: Collider * maximumRetry: float * excludedMesh: Nullable<AbstractMesh> * onNewPosition: (float -> Vector3 -> Nullable<AbstractMesh> -> unit) * collisionIndex: float -> unit
        abstract init: scene: Scene -> unit
        abstract destroy: unit -> unit
        abstract onMeshAdded: mesh: AbstractMesh -> unit
        abstract onMeshUpdated: mesh: AbstractMesh -> unit
        abstract onMeshRemoved: mesh: AbstractMesh -> unit
        abstract onGeometryAdded: geometry: Geometry -> unit
        abstract onGeometryUpdated: geometry: Geometry -> unit
        abstract onGeometryDeleted: geometry: Geometry -> unit

    type [<AllowNullLiteral>] SerializedMesh =
        abstract id: string with get, set
        abstract name: string with get, set
        abstract uniqueId: float with get, set
        abstract geometryId: Nullable<string> with get, set
        abstract sphereCenter: Array<float> with get, set
        abstract sphereRadius: float with get, set
        abstract boxMinimum: Array<float> with get, set
        abstract boxMaximum: Array<float> with get, set
        abstract worldMatrixFromCache: obj option with get, set
        abstract subMeshes: Array<SerializedSubMesh> with get, set
        abstract checkCollisions: bool with get, set

    type [<AllowNullLiteral>] SerializedSubMesh =
        abstract position: float with get, set
        abstract verticesStart: float with get, set
        abstract verticesCount: float with get, set
        abstract indexStart: float with get, set
        abstract indexCount: float with get, set
        abstract hasMaterial: bool with get, set
        abstract sphereCenter: Array<float> with get, set
        abstract sphereRadius: float with get, set
        abstract boxMinimum: Array<float> with get, set
        abstract boxMaximum: Array<float> with get, set

    /// Interface describing the value associated with a geometry
    type [<AllowNullLiteral>] SerializedGeometry =
        /// Defines the unique ID of the geometry
        abstract id: string with get, set
        /// Defines the array containing the positions
        abstract positions: Float32Array with get, set
        /// Defines the array containing the indices
        abstract indices: Uint32Array with get, set
        /// Defines the array containing the normals
        abstract normals: Float32Array with get, set

    type [<AllowNullLiteral>] BabylonMessage =
        abstract taskType: WorkerTaskType with get, set
        abstract payload: U3<InitPayload, CollidePayload, UpdatePayload> with get, set

    type [<AllowNullLiteral>] SerializedColliderToWorker =
        abstract position: Array<float> with get, set
        abstract velocity: Array<float> with get, set
        abstract radius: Array<float> with get, set

    type [<RequireQualifiedAccess>] WorkerTaskType =
        | INIT = 0
        | UPDATE = 1
        | COLLIDE = 2

    type [<AllowNullLiteral>] WorkerReply =
        abstract error: WorkerReplyType with get, set
        abstract taskType: WorkerTaskType with get, set
        abstract payload: obj option with get, set

    type [<AllowNullLiteral>] CollisionReplyPayload =
        abstract newPosition: Array<float> with get, set
        abstract collisionId: float with get, set
        abstract collidedMeshUniqueId: float with get, set

    type [<AllowNullLiteral>] InitPayload =
        interface end

    type [<AllowNullLiteral>] CollidePayload =
        abstract collisionId: float with get, set
        abstract collider: SerializedColliderToWorker with get, set
        abstract maximumRetry: float with get, set
        abstract excludedMeshUniqueId: Nullable<float> with get, set

    type [<AllowNullLiteral>] UpdatePayload =
        abstract updatedMeshes: obj with get, set
        abstract updatedGeometries: obj with get, set
        abstract removedMeshes: Array<float> with get, set
        abstract removedGeometries: Array<string> with get, set

    type [<RequireQualifiedAccess>] WorkerReplyType =
        | SUCCESS = 0
        | UNKNOWN_ERROR = 1

    type [<AllowNullLiteral>] CollisionCoordinatorWorker =
        inherit ICollisionCoordinator
        abstract _scene: obj with get, set
        abstract _scaledPosition: obj with get, set
        abstract _scaledVelocity: obj with get, set
        abstract _collisionsCallbackArray: obj with get, set
        abstract _init: obj with get, set
        abstract _runningUpdated: obj with get, set
        abstract _worker: obj with get, set
        abstract _addUpdateMeshesList: obj with get, set
        abstract _addUpdateGeometriesList: obj with get, set
        abstract _toRemoveMeshesArray: obj with get, set
        abstract _toRemoveGeometryArray: obj with get, set
        abstract SerializeMesh: (AbstractMesh -> SerializedMesh) with get, set
        abstract SerializeGeometry: (Geometry -> SerializedGeometry) with get, set
        abstract getNewPosition: position: Vector3 * displacement: Vector3 * collider: Collider * maximumRetry: float * excludedMesh: AbstractMesh * onNewPosition: (float -> Vector3 -> Nullable<AbstractMesh> -> unit) * collisionIndex: float -> unit
        abstract init: scene: Scene -> unit
        abstract destroy: unit -> unit
        abstract onMeshAdded: mesh: AbstractMesh -> unit
        abstract onMeshUpdated: (TransformNode -> unit) with get, set
        abstract onMeshRemoved: mesh: AbstractMesh -> unit
        abstract onGeometryAdded: geometry: Geometry -> unit
        abstract onGeometryUpdated: (Geometry -> unit) with get, set
        abstract onGeometryDeleted: geometry: Geometry -> unit
        abstract _afterRender: obj with get, set
        abstract _onMessageFromWorker: obj with get, set

    type [<AllowNullLiteral>] CollisionCoordinatorWorkerStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionCoordinatorWorker

    type [<AllowNullLiteral>] CollisionCoordinatorLegacy =
        inherit ICollisionCoordinator
        abstract _scene: obj with get, set
        abstract _scaledPosition: obj with get, set
        abstract _scaledVelocity: obj with get, set
        abstract _finalPosition: obj with get, set
        abstract getNewPosition: position: Vector3 * displacement: Vector3 * collider: Collider * maximumRetry: float * excludedMesh: AbstractMesh * onNewPosition: (float -> Vector3 -> Nullable<AbstractMesh> -> unit) * collisionIndex: float -> unit
        abstract init: scene: Scene -> unit
        abstract destroy: unit -> unit
        abstract onMeshAdded: mesh: AbstractMesh -> unit
        abstract onMeshUpdated: mesh: AbstractMesh -> unit
        abstract onMeshRemoved: mesh: AbstractMesh -> unit
        abstract onGeometryAdded: geometry: Geometry -> unit
        abstract onGeometryUpdated: geometry: Geometry -> unit
        abstract onGeometryDeleted: geometry: Geometry -> unit
        abstract _collideWithWorld: position: obj * velocity: obj * collider: obj * maximumRetry: obj * finalPosition: obj * ?excludedMesh: obj -> unit

    type [<AllowNullLiteral>] CollisionCoordinatorLegacyStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionCoordinatorLegacy

    type [<AllowNullLiteral>] CollisionCache =
        abstract _meshes: obj with get, set
        abstract _geometries: obj with get, set
        abstract getMeshes: unit -> obj
        abstract getGeometries: unit -> obj
        abstract getMesh: id: obj option -> SerializedMesh
        abstract addMesh: mesh: SerializedMesh -> unit
        abstract removeMesh: uniqueId: float -> unit
        abstract getGeometry: id: string -> SerializedGeometry
        abstract addGeometry: geometry: SerializedGeometry -> unit
        abstract removeGeometry: id: string -> unit

    type [<AllowNullLiteral>] CollisionCacheStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionCache

    type [<AllowNullLiteral>] CollideWorker =
        abstract collider: Collider with get, set
        abstract _collisionCache: obj with get, set
        abstract finalPosition: obj with get, set
        abstract collisionsScalingMatrix: obj with get, set
        abstract collisionTranformationMatrix: obj with get, set
        abstract collideWithWorld: position: Vector3 * velocity: Vector3 * maximumRetry: float * excludedMeshUniqueId: Nullable<float> -> unit
        abstract checkCollision: mesh: obj -> unit
        abstract processCollisionsForSubMeshes: transformMatrix: obj * mesh: obj -> unit
        abstract collideForSubMesh: subMesh: obj * transformMatrix: obj * meshGeometry: obj -> unit
        abstract checkSubmeshCollision: subMesh: obj -> unit

    type [<AllowNullLiteral>] CollideWorkerStatic =
        [<Emit "new $0($1...)">] abstract Create: collider: Collider * _collisionCache: CollisionCache * finalPosition: Vector3 -> CollideWorker

    type [<AllowNullLiteral>] ICollisionDetector =
        abstract onInit: payload: InitPayload -> unit
        abstract onUpdate: payload: UpdatePayload -> unit
        abstract onCollision: payload: CollidePayload -> unit

    type [<AllowNullLiteral>] CollisionDetectorTransferable =
        inherit ICollisionDetector
        abstract _collisionCache: obj with get, set
        abstract onInit: payload: InitPayload -> unit
        abstract onUpdate: payload: UpdatePayload -> unit
        abstract onCollision: payload: CollidePayload -> unit

    type [<AllowNullLiteral>] CollisionDetectorTransferableStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CollisionDetectorTransferable

    type [<AllowNullLiteral>] IntersectionInfo =
        abstract bu: Nullable<float> with get, set
        abstract bv: Nullable<float> with get, set
        abstract distance: float with get, set
        abstract faceId: float with get, set
        abstract subMeshId: float with get, set

    type [<AllowNullLiteral>] IntersectionInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: bu: Nullable<float> * bv: Nullable<float> * distance: float -> IntersectionInfo

    type [<AllowNullLiteral>] PickingInfo =
        abstract hit: bool with get, set
        abstract distance: float with get, set
        abstract pickedPoint: Nullable<Vector3> with get, set
        abstract pickedMesh: Nullable<AbstractMesh> with get, set
        abstract bu: float with get, set
        abstract bv: float with get, set
        abstract faceId: float with get, set
        abstract subMeshId: float with get, set
        abstract pickedSprite: Nullable<Sprite> with get, set
        abstract getNormal: ?useWorldCoordinates: bool * ?useVerticesNormals: bool -> Nullable<Vector3>
        abstract getTextureCoordinates: unit -> Nullable<Vector2>

    type [<AllowNullLiteral>] PickingInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PickingInfo

    type [<AllowNullLiteral>] BoundingBox =
        inherit ICullable
        abstract vectors: ResizeArray<Vector3> with get, set
        abstract center: Vector3 with get, set
        abstract centerWorld: Vector3 with get, set
        abstract extendSize: Vector3 with get, set
        abstract extendSizeWorld: Vector3 with get, set
        abstract directions: ResizeArray<Vector3> with get, set
        abstract vectorsWorld: ResizeArray<Vector3> with get, set
        abstract minimumWorld: Vector3 with get, set
        abstract maximumWorld: Vector3 with get, set
        abstract minimum: Vector3 with get, set
        abstract maximum: Vector3 with get, set
        abstract _worldMatrix: obj with get, set
        /// <summary>Recreates the entire bounding box from scratch</summary>
        /// <param name="min">defines the new minimum vector (in local space)</param>
        /// <param name="max">defines the new maximum vector (in local space)</param>
        abstract reConstruct: min: Vector3 * max: Vector3 -> unit
        abstract getWorldMatrix: unit -> Matrix
        abstract setWorldMatrix: matrix: Matrix -> BoundingBox
        abstract _update: world: Matrix -> unit
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        abstract intersectsPoint: point: Vector3 -> bool
        abstract intersectsSphere: sphere: BoundingSphere -> bool
        abstract intersectsMinMax: min: Vector3 * max: Vector3 -> bool

    type [<AllowNullLiteral>] BoundingBoxStatic =
        /// <summary>Creates a new bounding box</summary>
        /// <param name="min">defines the minimum vector (in local space)</param>
        /// <param name="max">defines the maximum vector (in local space)</param>
        [<Emit "new $0($1...)">] abstract Create: min: Vector3 * max: Vector3 -> BoundingBox
        abstract Intersects: box0: BoundingBox * box1: BoundingBox -> bool
        abstract IntersectsSphere: minPoint: Vector3 * maxPoint: Vector3 * sphereCenter: Vector3 * sphereRadius: float -> bool
        abstract IsCompletelyInFrustum: boundingVectors: ResizeArray<Vector3> * frustumPlanes: ResizeArray<Plane> -> bool
        abstract IsInFrustum: boundingVectors: ResizeArray<Vector3> * frustumPlanes: ResizeArray<Plane> -> bool

    type [<AllowNullLiteral>] ICullable =
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool

    type [<AllowNullLiteral>] BoundingInfo =
        inherit ICullable
        abstract minimum: Vector3 with get, set
        abstract maximum: Vector3 with get, set
        abstract boundingBox: BoundingBox with get, set
        abstract boundingSphere: BoundingSphere with get, set
        abstract _isLocked: obj with get, set
        abstract isLocked: bool with get, set
        abstract update: world: Matrix -> unit
        /// <summary>Recreate the bounding info to be centered around a specific point given a specific extend.</summary>
        /// <param name="center">New center of the bounding info</param>
        /// <param name="extend">New extend of the bounding info</param>
        abstract centerOn: center: Vector3 * extend: Vector3 -> BoundingInfo
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// Gets the world distance between the min and max points of the bounding box
        abstract diagonalLength: float
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        abstract _checkCollision: collider: Collider -> bool
        abstract intersectsPoint: point: Vector3 -> bool
        abstract intersects: boundingInfo: BoundingInfo * precise: bool -> bool

    type [<AllowNullLiteral>] BoundingInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: minimum: Vector3 * maximum: Vector3 -> BoundingInfo

    type [<AllowNullLiteral>] BoundingSphere =
        abstract center: Vector3 with get, set
        abstract radius: float with get, set
        abstract centerWorld: Vector3 with get, set
        abstract radiusWorld: float with get, set
        abstract minimum: Vector3 with get, set
        abstract maximum: Vector3 with get, set
        abstract _tempRadiusVector: obj with get, set
        /// <summary>Recreates the entire bounding sphere from scratch</summary>
        /// <param name="min">defines the new minimum vector (in local space)</param>
        /// <param name="max">defines the new maximum vector (in local space)</param>
        abstract reConstruct: min: Vector3 * max: Vector3 -> unit
        abstract _update: world: Matrix -> unit
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        abstract intersectsPoint: point: Vector3 -> bool

    type [<AllowNullLiteral>] BoundingSphereStatic =
        /// <summary>Creates a new bounding sphere</summary>
        /// <param name="min">defines the minimum vector (in local space)</param>
        /// <param name="max">defines the maximum vector (in local space)</param>
        [<Emit "new $0($1...)">] abstract Create: min: Vector3 * max: Vector3 -> BoundingSphere
        abstract Intersects: sphere0: BoundingSphere * sphere1: BoundingSphere -> bool

    type [<AllowNullLiteral>] Ray =
        abstract origin: Vector3 with get, set
        abstract direction: Vector3 with get, set
        abstract length: float with get, set
        abstract _edge1: obj with get, set
        abstract _edge2: obj with get, set
        abstract _pvec: obj with get, set
        abstract _tvec: obj with get, set
        abstract _qvec: obj with get, set
        abstract _tmpRay: obj with get, set
        abstract intersectsBoxMinMax: minimum: Vector3 * maximum: Vector3 -> bool
        abstract intersectsBox: box: BoundingBox -> bool
        abstract intersectsSphere: sphere: BoundingSphere -> bool
        abstract intersectsTriangle: vertex0: Vector3 * vertex1: Vector3 * vertex2: Vector3 -> Nullable<IntersectionInfo>
        abstract intersectsPlane: plane: Plane -> Nullable<float>
        abstract intersectsMesh: mesh: AbstractMesh * ?fastCheck: bool -> PickingInfo
        abstract intersectsMeshes: meshes: Array<AbstractMesh> * ?fastCheck: bool * ?results: Array<PickingInfo> -> Array<PickingInfo>
        abstract _comparePickingInfo: pickingInfoA: obj * pickingInfoB: obj -> unit
        abstract smallnum: obj with get, set
        abstract rayl: obj with get, set
        /// <summary>Intersection test between the ray and a given segment whithin a given tolerance (threshold)</summary>
        /// <param name="sega">the first point of the segment to test the intersection against</param>
        /// <param name="segb">the second point of the segment to test the intersection against</param>
        /// <param name="threshold">the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful</param>
        abstract intersectionSegment: sega: Vector3 * segb: Vector3 * threshold: float -> float
        abstract update: x: float * y: float * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix -> Ray

    type [<AllowNullLiteral>] RayStatic =
        [<Emit "new $0($1...)">] abstract Create: origin: Vector3 * direction: Vector3 * ?length: float -> Ray
        abstract Zero: unit -> Ray
        abstract CreateNew: x: float * y: float * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix -> Ray
        /// <summary>Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be
        /// transformed to the given world matrix.</summary>
        /// <param name="origin">The origin point</param>
        /// <param name="end">The end point</param>
        /// <param name="world">a matrix to transform the ray to. Default is the identity matrix.</param>
        abstract CreateNewFromTo: origin: Vector3 * ``end``: Vector3 * ?world: Matrix -> Ray
        abstract Transform: ray: Ray * matrix: Matrix -> Ray
        abstract TransformToRef: ray: Ray * matrix: Matrix * result: Ray -> unit

    /// Interface for attribute information associated with buffer instanciation
    type [<AllowNullLiteral>] InstancingAttributeInfo =
        /// Index/offset of the attribute in the vertex shader
        abstract index: float with get, set
        /// size of the attribute, 1, 2, 3 or 4
        abstract attributeSize: float with get, set
        /// type of the attribute, gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.FIXED, gl.FLOAT.
        /// default is FLOAT
        abstract attribyteType: float with get, set
        /// normalization of fixed-point data. behavior unclear, use FALSE, default is FALSE
        abstract normalized: bool with get, set
        /// Offset of the data in the Vertex Buffer acting as the instancing buffer
        abstract offset: float with get, set
        /// Name of the GLSL attribute, for debugging purpose only
        abstract attributeName: string with get, set

    /// Interface for attribute information associated with buffer instanciation
    type [<AllowNullLiteral>] InstancingAttributeInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> InstancingAttributeInfo

    /// Define options used to create a render target texture
    type [<AllowNullLiteral>] RenderTargetCreationOptions =
        /// Specifies is mipmaps must be generated
        abstract generateMipMaps: bool option with get, set
        /// Specifies whether or not a depth should be allocated in the texture (true by default) 
        abstract generateDepthBuffer: bool option with get, set
        /// Specifies whether or not a stencil should be allocated in the texture (false by default)
        abstract generateStencilBuffer: bool option with get, set
        /// Defines texture type (int by default) 
        abstract ``type``: float option with get, set
        /// Defines sampling mode (trilinear by default) 
        abstract samplingMode: float option with get, set
        /// Defines format (RGBA by default) 
        abstract format: float option with get, set

    /// Define options used to create a render target texture
    type [<AllowNullLiteral>] RenderTargetCreationOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RenderTargetCreationOptions

    /// Define options used to create a depth texture
    type [<AllowNullLiteral>] DepthTextureCreationOptions =
        /// Specifies whether or not a stencil should be allocated in the texture 
        abstract generateStencil: bool option with get, set
        /// Specifies whether or not bilinear filtering is enable on the texture 
        abstract bilinearFiltering: bool option with get, set
        /// Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode 
        abstract comparisonFunction: float option with get, set
        /// Specifies if the created texture is a cube texture 
        abstract isCube: bool option with get, set

    /// Define options used to create a depth texture
    type [<AllowNullLiteral>] DepthTextureCreationOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DepthTextureCreationOptions

    /// Class used to describe the capabilities of the engine relatively to the current browser
    type [<AllowNullLiteral>] EngineCapabilities =
        /// Maximum textures units per fragment shader 
        abstract maxTexturesImageUnits: float with get, set
        /// Maximum texture units per vertex shader 
        abstract maxVertexTextureImageUnits: float with get, set
        /// Maximum textures units in the entire pipeline 
        abstract maxCombinedTexturesImageUnits: float with get, set
        /// Maximum texture size 
        abstract maxTextureSize: float with get, set
        /// Maximum cube texture size 
        abstract maxCubemapTextureSize: float with get, set
        /// Maximum render texture size 
        abstract maxRenderTextureSize: float with get, set
        /// Maximum number of vertex attributes 
        abstract maxVertexAttribs: float with get, set
        /// Maximum number of varyings 
        abstract maxVaryingVectors: float with get, set
        /// Maximum number of uniforms per vertex shader 
        abstract maxVertexUniformVectors: float with get, set
        /// Maximum number of uniforms per fragment shader 
        abstract maxFragmentUniformVectors: float with get, set
        /// Defines if standard derivates (dx/dy) are supported 
        abstract standardDerivatives: bool with get, set
        /// Defines if s3tc texture compression is supported 
        abstract s3tc: Nullable<WEBGL_compressed_texture_s3tc> with get, set
        /// Defines if pvrtc texture compression is supported 
        abstract pvrtc: obj option with get, set
        /// Defines if etc1 texture compression is supported 
        abstract etc1: obj option with get, set
        /// Defines if etc2 texture compression is supported 
        abstract etc2: obj option with get, set
        /// Defines if astc texture compression is supported 
        abstract astc: obj option with get, set
        /// Defines if float textures are supported 
        abstract textureFloat: bool with get, set
        /// Defines if vertex array objects are supported 
        abstract vertexArrayObject: bool with get, set
        /// Gets the webgl extension for anisotropic filtering (null if not supported) 
        abstract textureAnisotropicFilterExtension: Nullable<EXT_texture_filter_anisotropic> with get, set
        /// Gets the maximum level of anisotropy supported 
        abstract maxAnisotropy: float with get, set
        /// Defines if instancing is supported 
        abstract instancedArrays: bool with get, set
        /// Defines if 32 bits indices are supported 
        abstract uintIndices: bool with get, set
        /// Defines if high precision shaders are supported 
        abstract highPrecisionShaderSupported: bool with get, set
        /// Defines if depth reading in the fragment shader is supported 
        abstract fragmentDepthSupported: bool with get, set
        /// Defines if float texture linear filtering is supported
        abstract textureFloatLinearFiltering: bool with get, set
        /// Defines if rendering to float textures is supported 
        abstract textureFloatRender: bool with get, set
        /// Defines if half float textures are supported
        abstract textureHalfFloat: bool with get, set
        /// Defines if half float texture linear filtering is supported
        abstract textureHalfFloatLinearFiltering: bool with get, set
        /// Defines if rendering to half float textures is supported 
        abstract textureHalfFloatRender: bool with get, set
        /// Defines if textureLOD shader command is supported 
        abstract textureLOD: bool with get, set
        /// Defines if draw buffers extension is supported 
        abstract drawBuffersExtension: bool with get, set
        /// Defines if depth textures are supported 
        abstract depthTextureExtension: bool with get, set
        /// Defines if float color buffer are supported 
        abstract colorBufferFloat: bool with get, set
        /// Gets disjoint timer query extension (null if not supported) 
        abstract timerQuery: EXT_disjoint_timer_query with get, set
        /// Defines if timestamp can be used with timer query 
        abstract canUseTimestampForTimerQuery: bool with get, set

    /// Class used to describe the capabilities of the engine relatively to the current browser
    type [<AllowNullLiteral>] EngineCapabilitiesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EngineCapabilities

    /// Interface defining initialization parameters for Engine class 
    type [<AllowNullLiteral>] EngineOptions =
        inherit WebGLContextAttributes
        /// Defines if the engine should no exceed a specified device ratio
        abstract limitDeviceRatio: float option with get, set
        /// Defines if webvr should be enabled automatically
        abstract autoEnableWebVR: bool option with get, set
        /// Defines if webgl2 should be turned off even if supported
        abstract disableWebGL2Support: bool option with get, set
        /// Defines if webaudio should be initialized as well
        abstract audioEngine: bool option with get, set
        /// Defines if animations should run using a deterministic lock step
        abstract deterministicLockstep: bool option with get, set
        /// Defines the maximum steps to use with deterministic lock step mode 
        abstract lockstepMaxSteps: float option with get, set
        /// Defines that engine should ignore context lost events
        /// If this event happens when this parameter is true, you will have to reload the page to restore rendering
        abstract doNotHandleContextLost: bool option with get, set

    /// Defines the interface used by display changed events
    type [<AllowNullLiteral>] IDisplayChangedEventArgs =
        /// Gets the vrDisplay object (if any) 
        abstract vrDisplay: Nullable<obj option> with get, set
        /// Gets a boolean indicating if webVR is supported 
        abstract vrSupported: bool with get, set

    /// The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
    type [<AllowNullLiteral>] Engine =
        /// Use this array to turn off some WebGL2 features on known buggy browsers version 
        abstract ExceptionList: ResizeArray<U2<obj, obj>> with get, set
        /// Gets the list of created engines 
        abstract Instances: ResizeArray<Engine> with get, set
        /// Gets the latest created engine
        abstract LastCreatedEngine: Nullable<Engine>
        /// Gets the latest created scene
        abstract LastCreatedScene: Nullable<Scene>
        abstract _ALPHA_DISABLE: obj with get, set
        abstract _ALPHA_ADD: obj with get, set
        abstract _ALPHA_COMBINE: obj with get, set
        abstract _ALPHA_SUBTRACT: obj with get, set
        abstract _ALPHA_MULTIPLY: obj with get, set
        abstract _ALPHA_MAXIMIZED: obj with get, set
        abstract _ALPHA_ONEONE: obj with get, set
        abstract _ALPHA_PREMULTIPLIED: obj with get, set
        abstract _ALPHA_PREMULTIPLIED_PORTERDUFF: obj with get, set
        abstract _ALPHA_INTERPOLATE: obj with get, set
        abstract _ALPHA_SCREENMODE: obj with get, set
        abstract _DELAYLOADSTATE_NONE: obj with get, set
        abstract _DELAYLOADSTATE_LOADED: obj with get, set
        abstract _DELAYLOADSTATE_LOADING: obj with get, set
        abstract _DELAYLOADSTATE_NOTLOADED: obj with get, set
        abstract _TEXTUREFORMAT_ALPHA: obj with get, set
        abstract _TEXTUREFORMAT_LUMINANCE: obj with get, set
        abstract _TEXTUREFORMAT_LUMINANCE_ALPHA: obj with get, set
        abstract _TEXTUREFORMAT_RGB: obj with get, set
        abstract _TEXTUREFORMAT_RGBA: obj with get, set
        abstract _TEXTUREFORMAT_R32F: obj with get, set
        abstract _TEXTUREFORMAT_RG32F: obj with get, set
        abstract _TEXTUREFORMAT_RGB32F: obj with get, set
        abstract _TEXTUREFORMAT_RGBA32F: obj with get, set
        abstract _TEXTURETYPE_UNSIGNED_INT: obj with get, set
        abstract _TEXTURETYPE_FLOAT: obj with get, set
        abstract _TEXTURETYPE_HALF_FLOAT: obj with get, set
        abstract _NEVER: obj with get, set
        abstract _ALWAYS: obj with get, set
        abstract _LESS: obj with get, set
        abstract _EQUAL: obj with get, set
        abstract _LEQUAL: obj with get, set
        abstract _GREATER: obj with get, set
        abstract _GEQUAL: obj with get, set
        abstract _NOTEQUAL: obj with get, set
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn 
        abstract NEVER: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn 
        abstract ALWAYS: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value 
        abstract LESS: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value 
        abstract EQUAL: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value 
        abstract LEQUAL: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value 
        abstract GREATER: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value 
        abstract GEQUAL: float
        /// Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value 
        abstract NOTEQUAL: float
        abstract _KEEP: obj with get, set
        abstract _REPLACE: obj with get, set
        abstract _INCR: obj with get, set
        abstract _DECR: obj with get, set
        abstract _INVERT: obj with get, set
        abstract _INCR_WRAP: obj with get, set
        abstract _DECR_WRAP: obj with get, set
        /// Passed to stencilOperation to specify that stencil value must be kept 
        abstract KEEP: float
        /// Passed to stencilOperation to specify that stencil value must be replaced 
        abstract REPLACE: float
        /// Passed to stencilOperation to specify that stencil value must be incremented 
        abstract INCR: float
        /// Passed to stencilOperation to specify that stencil value must be decremented 
        abstract DECR: float
        /// Passed to stencilOperation to specify that stencil value must be inverted 
        abstract INVERT: float
        /// Passed to stencilOperation to specify that stencil value must be incremented with wrapping 
        abstract INCR_WRAP: float
        /// Passed to stencilOperation to specify that stencil value must be decremented with wrapping 
        abstract DECR_WRAP: float
        /// Defines that alpha blending is disabled 
        abstract ALPHA_DISABLE: float
        /// Defines that alpha blending to SRC + DEST 
        abstract ALPHA_ONEONE: float
        /// Defines that alpha blending to SRC ALPHA * SRC + DEST 
        abstract ALPHA_ADD: float
        /// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST 
        abstract ALPHA_COMBINE: float
        /// Defines that alpha blending to DEST - SRC * DEST 
        abstract ALPHA_SUBTRACT: float
        /// Defines that alpha blending to SRC * DEST 
        abstract ALPHA_MULTIPLY: float
        /// Defines that alpha blending to SRC ALPHA * SRC + (1 - SRC) * DEST 
        abstract ALPHA_MAXIMIZED: float
        /// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST 
        abstract ALPHA_PREMULTIPLIED: float
        /// Defines that alpha blending to SRC + (1 - SRC ALPHA) * DEST
        /// Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
        abstract ALPHA_PREMULTIPLIED_PORTERDUFF: float
        /// Defines that alpha blending to CST * SRC + (1 - CST) * DEST 
        abstract ALPHA_INTERPOLATE: float
        /// Defines that alpha blending to SRC + (1 - SRC) * DEST
        /// Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
        abstract ALPHA_SCREENMODE: float
        /// Defines that the ressource is not delayed
        abstract DELAYLOADSTATE_NONE: float
        /// Defines that the ressource was successfully delay loaded 
        abstract DELAYLOADSTATE_LOADED: float
        /// Defines that the ressource is currently delay loading 
        abstract DELAYLOADSTATE_LOADING: float
        /// Defines that the ressource is delayed and has not started loading 
        abstract DELAYLOADSTATE_NOTLOADED: float
        /// ALPHA 
        abstract TEXTUREFORMAT_ALPHA: float
        /// LUMINANCE 
        abstract TEXTUREFORMAT_LUMINANCE: float
        /// R32F
        abstract TEXTUREFORMAT_R32F: float
        /// RG32F
        abstract TEXTUREFORMAT_RG32F: float
        /// RGB32F
        abstract TEXTUREFORMAT_RGB32F: float
        /// RGBA32F
        abstract TEXTUREFORMAT_RGBA32F: float
        /// LUMINANCE_ALPHA 
        abstract TEXTUREFORMAT_LUMINANCE_ALPHA: float
        /// RGB 
        abstract TEXTUREFORMAT_RGB: float
        /// RGBA 
        abstract TEXTUREFORMAT_RGBA: float
        /// UNSIGNED_INT 
        abstract TEXTURETYPE_UNSIGNED_INT: float
        /// FLOAT 
        abstract TEXTURETYPE_FLOAT: float
        /// HALF_FLOAT 
        abstract TEXTURETYPE_HALF_FLOAT: float
        abstract _SCALEMODE_FLOOR: obj with get, set
        abstract _SCALEMODE_NEAREST: obj with get, set
        abstract _SCALEMODE_CEILING: obj with get, set
        /// Defines that texture rescaling will use a floor to find the closer power of 2 size 
        abstract SCALEMODE_FLOOR: float
        /// Defines that texture rescaling will look for the nearest power of 2 size 
        abstract SCALEMODE_NEAREST: float
        /// Defines that texture rescaling will use a ceil to find the closer power of 2 size 
        abstract SCALEMODE_CEILING: float
        /// Returns the current version of the framework
        abstract Version: string
        /// Gets or sets the epsilon value used by collision engine
        abstract CollisionsEpsilon: float with get, set
        /// Gets or sets the relative url used to load code if using the engine in non-minified mode
        abstract CodeRepository: string with get, set
        /// Gets or sets the relative url used to load shaders if using the engine in non-minified mode
        abstract ShadersRepository: string with get, set
        /// Gets or sets a boolean that indicates if textures must be forced to power of 2 size even if not required
        abstract forcePOTTextures: bool with get, set
        /// Gets a boolean indicating if the engine is currently rendering in fullscreen mode
        abstract isFullscreen: bool with get, set
        /// Gets a boolean indicating if the pointer is currently locked
        abstract isPointerLock: bool with get, set
        /// Gets or sets a boolean indicating if back faces must be culled (true by default)
        abstract cullBackFaces: bool with get, set
        /// Gets or sets a boolean indicating if the engine must keep rendering even if the window is not in foregroun
        abstract renderEvenInBackground: bool with get, set
        /// Gets or sets a boolean indicating that cache can be kept between frames
        abstract preventCacheWipeBetweenFrames: bool with get, set
        /// Gets or sets a boolean to enable/disable IndexedDB support and avoid XHR on .manifest
        abstract enableOfflineSupport: bool with get, set
        /// Gets the list of created scenes
        abstract scenes: ResizeArray<Scene> with get, set
        /// Gets the list of created postprocesses
        abstract postProcesses: ResizeArray<PostProcess> with get, set
        /// Observable event triggered each time the rendering canvas is resized
        abstract onResizeObservable: Observable<Engine> with get, set
        /// Observable event triggered each time the canvas loses focus
        abstract onCanvasBlurObservable: Observable<Engine> with get, set
        /// Observable event triggered each time the canvas gains focus
        abstract onCanvasFocusObservable: Observable<Engine> with get, set
        /// Observable event triggered each time the canvas receives pointerout event
        abstract onCanvasPointerOutObservable: Observable<PointerEvent> with get, set
        /// Observable event triggered before each texture is initialized
        abstract onBeforeTextureInitObservable: Observable<Texture> with get, set
        abstract _vrDisplay: obj with get, set
        abstract _vrSupported: obj with get, set
        abstract _oldSize: obj with get, set
        abstract _oldHardwareScaleFactor: obj with get, set
        abstract _vrExclusivePointerMode: obj with get, set
        abstract _webVRInitPromise: obj with get, set
        /// Gets a boolean indicating that the engine is currently in VR exclusive mode for the pointers
        abstract isInVRExclusivePointerMode: bool
        /// Gets or sets a boolean indicating that uniform buffers must be disabled even if they are supported
        abstract disableUniformBuffers: bool with get, set
        abstract _uniformBuffers: ResizeArray<UniformBuffer> with get, set
        /// Gets a boolean indicating that the engine supports uniform buffers
        abstract supportsUniformBuffers: bool
        /// Observable raised when the engine begins a new frame
        abstract onBeginFrameObservable: Observable<Engine> with get, set
        /// Observable raised when the engine ends the current frame
        abstract onEndFrameObservable: Observable<Engine> with get, set
        /// Observable raised when the engine is about to compile a shader
        abstract onBeforeShaderCompilationObservable: Observable<Engine> with get, set
        /// Observable raised when the engine has jsut compiled a shader
        abstract onAfterShaderCompilationObservable: Observable<Engine> with get, set
        abstract _gl: obj with get, set
        abstract _renderingCanvas: obj with get, set
        abstract _windowIsBackground: obj with get, set
        abstract _webGLVersion: obj with get, set
        /// Gets a boolean indicating that only power of 2 textures are supported
        /// Please note that you can still use non power of 2 textures but in this case the engine will forcefully convert them
        abstract needPOTTextures: bool
        abstract _badOS: bool with get, set
        abstract _badDesktopOS: bool with get, set
        /// Gets or sets a value indicating if we want to disable texture binding optmization.
        /// This could be required on some buggy drivers which wants to have textures bound in a progressive order.
        /// By default Babylon.js will try to let textures bound where they are and only update the samplers to point where the texture is
        abstract disableTextureBindingOptimization: bool with get, set
        /// Gets the audio engine
        abstract audioEngine: AudioEngine with get, set
        abstract _onFocus: obj with get, set
        abstract _onBlur: obj with get, set
        abstract _onCanvasPointerOut: obj with get, set
        abstract _onCanvasBlur: obj with get, set
        abstract _onCanvasFocus: obj with get, set
        abstract _onFullscreenChange: obj with get, set
        abstract _onPointerLockChange: obj with get, set
        abstract _onVRDisplayPointerRestricted: obj with get, set
        abstract _onVRDisplayPointerUnrestricted: obj with get, set
        abstract _onVrDisplayConnect: obj with get, set
        abstract _onVrDisplayDisconnect: obj with get, set
        abstract _onVrDisplayPresentChange: obj with get, set
        /// Observable signaled when VR display mode changes
        abstract onVRDisplayChangedObservable: Observable<IDisplayChangedEventArgs> with get, set
        /// Observable signaled when VR request present is complete
        abstract onVRRequestPresentComplete: Observable<bool> with get, set
        /// Observable signaled when VR request present starts
        abstract onVRRequestPresentStart: Observable<Engine> with get, set
        abstract _hardwareScalingLevel: obj with get, set
        abstract _caps: EngineCapabilities with get, set
        abstract _pointerLockRequested: obj with get, set
        abstract _isStencilEnable: obj with get, set
        abstract _colorWrite: obj with get, set
        abstract _loadingScreen: obj with get, set
        abstract _drawCalls: PerfCounter with get, set
        abstract _textureCollisions: PerfCounter with get, set
        abstract _glVersion: obj with get, set
        abstract _glRenderer: obj with get, set
        abstract _glVendor: obj with get, set
        abstract _videoTextureSupported: obj with get, set
        abstract _renderingQueueLaunched: obj with get, set
        abstract _activeRenderLoops: obj with get, set
        abstract _deterministicLockstep: obj with get, set
        abstract _lockstepMaxSteps: obj with get, set
        /// Observable signaled when a context lost event is raised
        abstract onContextLostObservable: Observable<Engine> with get, set
        /// Observable signaled when a context restored event is raised
        abstract onContextRestoredObservable: Observable<Engine> with get, set
        abstract _onContextLost: obj with get, set
        abstract _onContextRestored: obj with get, set
        abstract _contextWasLost: obj with get, set
        abstract _doNotHandleContextLost: obj with get, set
        abstract _performanceMonitor: obj with get, set
        abstract _fps: obj with get, set
        abstract _deltaTime: obj with get, set
        /// Turn this value on if you want to pause FPS computation when in background
        abstract disablePerformanceMonitorInBackground: bool with get, set
        /// Gets the performance monitor attached to this engine
        abstract performanceMonitor: PerformanceMonitor
        abstract _depthCullingState: _DepthCullingState with get, set
        abstract _stencilState: _StencilState with get, set
        abstract _alphaState: _AlphaState with get, set
        abstract _alphaMode: float with get, set
        abstract _internalTexturesCache: obj with get, set
        abstract _activeChannel: float with get, set
        abstract _currentTextureChannel: obj with get, set
        abstract _boundTexturesCache: obj with get, set
        abstract _currentEffect: Nullable<Effect> with get, set
        abstract _currentProgram: Nullable<WebGLProgram> with get, set
        abstract _compiledEffects: obj with get, set
        abstract _vertexAttribArraysEnabled: obj with get, set
        abstract _cachedViewport: Nullable<Viewport> with get, set
        abstract _cachedVertexArrayObject: obj with get, set
        abstract _cachedVertexBuffers: obj option with get, set
        abstract _cachedIndexBuffer: Nullable<WebGLBuffer> with get, set
        abstract _cachedEffectForVertexBuffers: Nullable<Effect> with get, set
        abstract _currentRenderTarget: Nullable<InternalTexture> with get, set
        abstract _uintIndicesCurrentlySet: obj with get, set
        abstract _currentBoundBuffer: obj with get, set
        abstract _currentFramebuffer: Nullable<WebGLFramebuffer> with get, set
        abstract _currentBufferPointers: obj with get, set
        abstract _currentInstanceLocations: obj with get, set
        abstract _currentInstanceBuffers: obj with get, set
        abstract _textureUnits: obj with get, set
        abstract _firstBoundInternalTextureTracker: obj with get, set
        abstract _lastBoundInternalTextureTracker: obj with get, set
        abstract _workingCanvas: obj with get, set
        abstract _workingContext: obj with get, set
        abstract _rescalePostProcess: obj with get, set
        abstract _dummyFramebuffer: obj with get, set
        abstract _externalData: obj with get, set
        abstract _bindedRenderFunction: obj with get, set
        abstract _vaoRecordInProgress: obj with get, set
        abstract _mustWipeVertexAttributes: obj with get, set
        abstract _emptyTexture: obj with get, set
        abstract _emptyCubeTexture: obj with get, set
        abstract _emptyTexture3D: obj with get, set
        abstract _frameHandler: obj with get, set
        abstract _nextFreeTextureSlots: obj with get, set
        abstract _maxSimultaneousTextures: obj with get, set
        abstract _activeRequests: obj with get, set
        abstract _texturesSupported: obj with get, set
        abstract _textureFormatInUse: obj with get, set
        /// Gets the list of texture formats supported
        abstract texturesSupported: Array<string>
        /// Gets the list of texture formats in use
        abstract textureFormatInUse: Nullable<string>
        /// Gets the current viewport
        abstract currentViewport: Nullable<Viewport>
        /// Gets the default empty texture
        abstract emptyTexture: InternalTexture
        /// Gets the default empty 3D texture
        abstract emptyTexture3D: InternalTexture
        /// Gets the default empty cube texture
        abstract emptyCubeTexture: InternalTexture
        abstract _rebuildInternalTextures: unit -> unit
        abstract _rebuildEffects: unit -> unit
        abstract _rebuildBuffers: unit -> unit
        abstract _initGLContext: unit -> unit
        /// Gets version of the current webGL context
        abstract webGLVersion: float
        /// Returns true if the stencil buffer has been enabled through the creation option of the context.
        abstract isStencilEnable: bool
        abstract _prepareWorkingCanvas: unit -> unit
        /// Reset the texture cache to empty state
        abstract resetTextureCache: unit -> unit
        /// Gets a boolean indicating that the engine is running in deterministic lock step mode
        abstract isDeterministicLockStep: unit -> bool
        /// Gets the max steps when engine is running in deterministic lock step
        abstract getLockstepMaxSteps: unit -> float
        /// Gets an object containing information about the current webGL context
        abstract getGlInfo: unit -> obj
        /// <summary>Gets current aspect ratio</summary>
        /// <param name="camera">defines the camera to use to get the aspect ratio</param>
        /// <param name="useScreen">defines if screen size must be used (or the current render target if any)</param>
        abstract getAspectRatio: camera: Camera * ?useScreen: bool -> float
        /// <summary>Gets the current render width</summary>
        /// <param name="useScreen">defines if screen size must be used (or the current render target if any)</param>
        abstract getRenderWidth: ?useScreen: bool -> float
        /// <summary>Gets the current render height</summary>
        /// <param name="useScreen">defines if screen size must be used (or the current render target if any)</param>
        abstract getRenderHeight: ?useScreen: bool -> float
        /// Gets the HTML canvas attached with the current webGL context
        abstract getRenderingCanvas: unit -> Nullable<HTMLCanvasElement>
        /// Gets the client rect of the HTML canvas attached with the current webGL context
        abstract getRenderingCanvasClientRect: unit -> Nullable<ClientRect>
        /// <summary>Defines the hardware scaling level.
        /// By default the hardware scaling level is computed from the window device ratio.
        /// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.</summary>
        /// <param name="level">defines the level to use</param>
        abstract setHardwareScalingLevel: level: float -> unit
        /// Gets the current hardware scaling level.
        /// By default the hardware scaling level is computed from the window device ratio.
        /// if level = 1 then the engine will render at the exact resolution of the canvas. If level = 0.5 then the engine will render at twice the size of the canvas.
        abstract getHardwareScalingLevel: unit -> float
        /// Gets the list of loaded textures
        abstract getLoadedTexturesCache: unit -> ResizeArray<InternalTexture>
        /// Gets the object containing all engine capabilities
        abstract getCaps: unit -> EngineCapabilities
        abstract drawCalls: float
        abstract drawCallsPerfCounter: Nullable<PerfCounter>
        /// Gets the current depth function
        abstract getDepthFunction: unit -> Nullable<float>
        /// <summary>Sets the current depth function</summary>
        /// <param name="depthFunc">defines the function to use</param>
        abstract setDepthFunction: depthFunc: float -> unit
        /// Sets the current depth function to GREATER
        abstract setDepthFunctionToGreater: unit -> unit
        /// Sets the current depth function to GEQUAL
        abstract setDepthFunctionToGreaterOrEqual: unit -> unit
        /// Sets the current depth function to LESS
        abstract setDepthFunctionToLess: unit -> unit
        /// Sets the current depth function to LEQUAL
        abstract setDepthFunctionToLessOrEqual: unit -> unit
        /// Gets a boolean indicating if stencil buffer is enabled
        abstract getStencilBuffer: unit -> bool
        /// <summary>Enable or disable the stencil buffer</summary>
        /// <param name="enable">defines if the stencil buffer must be enabled or disabled</param>
        abstract setStencilBuffer: enable: bool -> unit
        /// Gets the current stencil mask
        abstract getStencilMask: unit -> float
        /// <summary>Sets the current stencil mask</summary>
        /// <param name="mask">defines the new stencil mask to use</param>
        abstract setStencilMask: mask: float -> unit
        /// Gets the current stencil function
        abstract getStencilFunction: unit -> float
        /// Gets the current stencil reference value
        abstract getStencilFunctionReference: unit -> float
        /// Gets the current stencil mask
        abstract getStencilFunctionMask: unit -> float
        /// <summary>Sets the current stencil function</summary>
        /// <param name="stencilFunc">defines the new stencil function to use</param>
        abstract setStencilFunction: stencilFunc: float -> unit
        /// <summary>Sets the current stencil reference</summary>
        /// <param name="reference">defines the new stencil reference to use</param>
        abstract setStencilFunctionReference: reference: float -> unit
        /// <summary>Sets the current stencil mask</summary>
        /// <param name="mask">defines the new stencil mask to use</param>
        abstract setStencilFunctionMask: mask: float -> unit
        /// Gets the current stencil operation when stencil fails
        abstract getStencilOperationFail: unit -> float
        /// Gets the current stencil operation when depth fails
        abstract getStencilOperationDepthFail: unit -> float
        /// Gets the current stencil operation when stencil passes
        abstract getStencilOperationPass: unit -> float
        /// <summary>Sets the stencil operation to use when stencil fails</summary>
        /// <param name="operation">defines the stencil operation to use when stencil fails</param>
        abstract setStencilOperationFail: operation: float -> unit
        /// <summary>Sets the stencil operation to use when depth fails</summary>
        /// <param name="operation">defines the stencil operation to use when depth fails</param>
        abstract setStencilOperationDepthFail: operation: float -> unit
        /// <summary>Sets the stencil operation to use when stencil passes</summary>
        /// <param name="operation">defines the stencil operation to use when stencil passes</param>
        abstract setStencilOperationPass: operation: float -> unit
        /// <summary>Sets a boolean indicating if the dithering state is enabled or disabled</summary>
        /// <param name="value">defines the dithering state</param>
        abstract setDitheringState: value: bool -> unit
        /// <summary>Sets a boolean indicating if the rasterizer state is enabled or disabled</summary>
        /// <param name="value">defines the rasterizer state</param>
        abstract setRasterizerState: value: bool -> unit
        /// <summary>stop executing a render loop function and remove it from the execution array</summary>
        /// <param name="renderFunction">defines the function to be removed. If not provided all functions will be removed.</param>
        abstract stopRenderLoop: ?renderFunction: (unit -> unit) -> unit
        abstract _renderLoop: unit -> unit
        /// <summary>Register and execute a render loop. The engine can have more than one render function</summary>
        /// <param name="renderFunction">defines the function to continuously execute</param>
        abstract runRenderLoop: renderFunction: (unit -> unit) -> unit
        /// <summary>Toggle full screen mode</summary>
        /// <param name="requestPointerLock">defines if a pointer lock should be requested from the user</param>
        abstract switchFullscreen: requestPointerLock: bool -> unit
        /// <summary>Clear the current render buffer or the current render target (if any is set up)</summary>
        /// <param name="color">defines the color to use</param>
        /// <param name="backBuffer">defines if the back buffer must be cleared</param>
        /// <param name="depth">defines if the depth buffer must be cleared</param>
        /// <param name="stencil">defines if the stencil buffer must be cleared</param>
        abstract clear: color: Nullable<Color4> * backBuffer: bool * depth: bool * ?stencil: bool -> unit
        /// <summary>Executes a scissor clear (ie. a clear on a specific portion of the screen)</summary>
        /// <param name="x">defines the x-coordinate of the top left corner of the clear rectangle</param>
        /// <param name="y">defines the y-coordinate of the corner of the clear rectangle</param>
        /// <param name="width">defines the width of the clear rectangle</param>
        /// <param name="height">defines the height of the clear rectangle</param>
        /// <param name="clearColor">defines the clear color</param>
        abstract scissorClear: x: float * y: float * width: float * height: float * clearColor: Color4 -> unit
        /// <summary>Set the WebGL's viewport</summary>
        /// <param name="viewport">defines the viewport element to be used</param>
        /// <param name="requiredWidth">defines the width required for rendering. If not provided the rendering canvas' width is used</param>
        /// <param name="requiredHeight">defines the height required for rendering. If not provided the rendering canvas' height is used</param>
        abstract setViewport: viewport: Viewport * ?requiredWidth: float * ?requiredHeight: float -> unit
        /// <summary>Directly set the WebGL Viewport</summary>
        /// <param name="x">defines the x coordinate of the viewport (in screen space)</param>
        /// <param name="y">defines the y coordinate of the viewport (in screen space)</param>
        /// <param name="width">defines the width of the viewport (in screen space)</param>
        /// <param name="height">defines the height of the viewport (in screen space)</param>
        abstract setDirectViewport: x: float * y: float * width: float * height: float -> Nullable<Viewport>
        /// Begin a new frame
        abstract beginFrame: unit -> unit
        /// Enf the current frame
        abstract endFrame: unit -> unit
        /// Resize the view according to the canvas' size
        abstract resize: unit -> unit
        /// <summary>Force a specific size of the canvas</summary>
        /// <param name="width">defines the new canvas' width</param>
        /// <param name="height">defines the new canvas' height</param>
        abstract setSize: width: float * height: float -> unit
        /// Gets a boolean indicating if a webVR device was detected
        abstract isVRDevicePresent: unit -> bool
        /// Gets the current webVR device
        abstract getVRDevice: unit -> obj option
        /// Initializes a webVR display and starts listening to display change events
        /// The onVRDisplayChangedObservable will be notified upon these changes
        abstract initWebVR: unit -> Observable<IDisplayChangedEventArgs>
        /// Initializes a webVR display and starts listening to display change events
        /// The onVRDisplayChangedObservable will be notified upon these changes
        abstract initWebVRAsync: unit -> Promise<IDisplayChangedEventArgs>
        /// Call this function to switch to webVR mode
        /// Will do nothing if webVR is not supported or if there is no webVR device
        abstract enableVR: unit -> unit
        /// Call this function to leave webVR mode
        /// Will do nothing if webVR is not supported or if there is no webVR device
        abstract disableVR: unit -> unit
        abstract _onVRFullScreenTriggered: obj with get, set
        abstract _getVRDisplaysAsync: unit -> unit
        /// <summary>Binds the frame buffer to the specified texture.</summary>
        /// <param name="texture">The texture to render to or null for the default canvas</param>
        /// <param name="faceIndex">The face of the texture to render to in case of cube texture</param>
        /// <param name="requiredWidth">The width of the target to render to</param>
        /// <param name="requiredHeight">The height of the target to render to</param>
        /// <param name="forceFullscreenViewport">Forces the viewport to be the entire texture/screen if true</param>
        /// <param name="depthStencilTexture">The depth stencil texture to use to render</param>
        abstract bindFramebuffer: texture: InternalTexture * ?faceIndex: float * ?requiredWidth: float * ?requiredHeight: float * ?forceFullscreenViewport: bool * ?depthStencilTexture: InternalTexture -> unit
        abstract bindUnboundFramebuffer: framebuffer: obj -> unit
        /// <summary>Unbind the current render target texture from the webGL context</summary>
        /// <param name="texture">defines the render target texture to unbind</param>
        /// <param name="disableGenerateMipMaps">defines a boolean indicating that mipmaps must not be generated</param>
        /// <param name="onBeforeUnbind">defines a function which will be called before the effective unbind</param>
        abstract unBindFramebuffer: texture: InternalTexture * ?disableGenerateMipMaps: bool * ?onBeforeUnbind: (unit -> unit) -> unit
        /// <summary>Unbind a list of render target textures from the webGL context
        /// This is used only when drawBuffer extension or webGL2 are active</summary>
        /// <param name="textures">defines the render target textures to unbind</param>
        /// <param name="disableGenerateMipMaps">defines a boolean indicating that mipmaps must not be generated</param>
        /// <param name="onBeforeUnbind">defines a function which will be called before the effective unbind</param>
        abstract unBindMultiColorAttachmentFramebuffer: textures: ResizeArray<InternalTexture> * ?disableGenerateMipMaps: bool * ?onBeforeUnbind: (unit -> unit) -> unit
        /// <summary>Force the mipmap generation for the given render target texture</summary>
        /// <param name="texture">defines the render target texture to use</param>
        abstract generateMipMapsForCubemap: texture: InternalTexture -> unit
        /// Force a webGL flush (ie. a flush of all waiting webGL commands)
        abstract flushFramebuffer: unit -> unit
        /// Unbind the current render target and bind the default framebuffer
        abstract restoreDefaultFramebuffer: unit -> unit
        /// <summary>Create an uniform buffer</summary>
        /// <param name="elements">defines the content of the uniform buffer</param>
        abstract createUniformBuffer: elements: FloatArray -> WebGLBuffer
        /// <summary>Create a dynamic uniform buffer</summary>
        /// <param name="elements">defines the content of the uniform buffer</param>
        abstract createDynamicUniformBuffer: elements: FloatArray -> WebGLBuffer
        /// <summary>Update an existing uniform buffer</summary>
        /// <param name="uniformBuffer">defines the target uniform buffer</param>
        /// <param name="elements">defines the content to update</param>
        /// <param name="offset">defines the offset in the uniform buffer where update should start</param>
        /// <param name="count">defines the size of the data to update</param>
        abstract updateUniformBuffer: uniformBuffer: WebGLBuffer * elements: FloatArray * ?offset: float * ?count: float -> unit
        abstract _resetVertexBufferBinding: unit -> unit
        /// <summary>Creates a vertex buffer</summary>
        /// <param name="data">the data for the vertex buffer</param>
        abstract createVertexBuffer: data: DataArray -> WebGLBuffer
        /// <summary>Creates a dynamic vertex buffer</summary>
        /// <param name="data">the data for the dynamic vertex buffer</param>
        abstract createDynamicVertexBuffer: data: DataArray -> WebGLBuffer
        /// <summary>Update a dynamic index buffer</summary>
        /// <param name="indexBuffer">defines the target index buffer</param>
        /// <param name="indices">defines the data to update</param>
        /// <param name="offset">defines the offset in the target index buffer where update should start</param>
        abstract updateDynamicIndexBuffer: indexBuffer: WebGLBuffer * indices: IndicesArray * ?offset: float -> unit
        /// <summary>Updates a dynamic vertex buffer.</summary>
        /// <param name="vertexBuffer">the vertex buffer to update</param>
        /// <param name="data">the data used to update the vertex buffer</param>
        /// <param name="byteOffset">the byte offset of the data</param>
        /// <param name="byteLength">the byte length of the data</param>
        abstract updateDynamicVertexBuffer: vertexBuffer: WebGLBuffer * data: DataArray * ?byteOffset: float * ?byteLength: float -> unit
        abstract _resetIndexBufferBinding: unit -> unit
        /// <summary>Creates a new index buffer</summary>
        /// <param name="indices">defines the content of the index buffer</param>
        /// <param name="updatable">defines if the index buffer must be updatable</param>
        abstract createIndexBuffer: indices: IndicesArray * ?updatable: bool -> WebGLBuffer
        /// <summary>Bind a webGL buffer to the webGL context</summary>
        /// <param name="buffer">defines the buffer to bind</param>
        abstract bindArrayBuffer: buffer: Nullable<WebGLBuffer> -> unit
        /// <summary>Bind an uniform buffer to the current webGL context</summary>
        /// <param name="buffer">defines the buffer to bind</param>
        abstract bindUniformBuffer: buffer: Nullable<WebGLBuffer> -> unit
        /// <summary>Bind a buffer to the current webGL context at a given location</summary>
        /// <param name="buffer">defines the buffer to bind</param>
        /// <param name="location">defines the index where to bind the buffer</param>
        abstract bindUniformBufferBase: buffer: WebGLBuffer * location: float -> unit
        /// <summary>Bind a specific block at a given index in a specific shader program</summary>
        /// <param name="shaderProgram">defines the shader program</param>
        /// <param name="blockName">defines the block name</param>
        /// <param name="index">defines the index where to bind the block</param>
        abstract bindUniformBlock: shaderProgram: WebGLProgram * blockName: string * index: float -> unit
        abstract bindIndexBuffer: buffer: obj -> unit
        abstract bindBuffer: buffer: obj * target: obj -> unit
        /// <summary>update the bound buffer with the given data</summary>
        /// <param name="data">defines the data to update</param>
        abstract updateArrayBuffer: data: Float32Array -> unit
        abstract _vertexAttribPointer: buffer: obj * indx: obj * size: obj * ``type``: obj * normalized: obj * stride: obj * offset: obj -> unit
        abstract _bindIndexBufferWithCache: indexBuffer: obj -> unit
        abstract _bindVertexBuffersAttributes: vertexBuffers: obj * effect: obj -> unit
        /// <summary>Records a vertex array object</summary>
        /// <param name="vertexBuffers">defines the list of vertex buffers to store</param>
        /// <param name="indexBuffer">defines the index buffer to store</param>
        /// <param name="effect">defines the effect to store</param>
        abstract recordVertexArrayObject: vertexBuffers: EngineRecordVertexArrayObjectVertexBuffers * indexBuffer: Nullable<WebGLBuffer> * effect: Effect -> WebGLVertexArrayObject
        /// <summary>Bind a specific vertex array object</summary>
        /// <param name="vertexArrayObject">defines the vertex array object to bind</param>
        /// <param name="indexBuffer">defines the index buffer to bind</param>
        abstract bindVertexArrayObject: vertexArrayObject: WebGLVertexArrayObject * indexBuffer: Nullable<WebGLBuffer> -> unit
        /// <summary>Bind webGl buffers directly to the webGL context</summary>
        /// <param name="vertexBuffer">defines the vertex buffer to bind</param>
        /// <param name="indexBuffer">defines the index buffer to bind</param>
        /// <param name="vertexDeclaration">defines the vertex declaration to use with the vertex buffer</param>
        /// <param name="vertexStrideSize">defines the vertex stride of the vertex buffer</param>
        /// <param name="effect">defines the effect associated with the vertex buffer</param>
        abstract bindBuffersDirectly: vertexBuffer: WebGLBuffer * indexBuffer: WebGLBuffer * vertexDeclaration: ResizeArray<float> * vertexStrideSize: float * effect: Effect -> unit
        abstract _unbindVertexArrayObject: unit -> unit
        /// <summary>Bind a list of vertex buffers to the webGL context</summary>
        /// <param name="vertexBuffers">defines the list of vertex buffers to bind</param>
        /// <param name="indexBuffer">defines the index buffer to bind</param>
        /// <param name="effect">defines the effect associated with the vertex buffers</param>
        abstract bindBuffers: vertexBuffers: EngineBindBuffersVertexBuffers * indexBuffer: Nullable<WebGLBuffer> * effect: Effect -> unit
        /// Unbind all instance attributes
        abstract unbindInstanceAttributes: unit -> unit
        /// <summary>Release and free the memory of a vertex array object</summary>
        /// <param name="vao">defines the vertex array object to delete</param>
        abstract releaseVertexArrayObject: vao: WebGLVertexArrayObject -> unit
        abstract _releaseBuffer: buffer: WebGLBuffer -> bool
        /// <summary>Creates a webGL buffer to use with instanciation</summary>
        /// <param name="capacity">defines the size of the buffer</param>
        abstract createInstancesBuffer: capacity: float -> WebGLBuffer
        /// <summary>Delete a webGL buffer used with instanciation</summary>
        /// <param name="buffer">defines the webGL buffer to delete</param>
        abstract deleteInstancesBuffer: buffer: WebGLBuffer -> unit
        /// <summary>Update the content of a webGL buffer used with instanciation and bind it to the webGL context</summary>
        /// <param name="instancesBuffer">defines the webGL buffer to update and bind</param>
        /// <param name="data">defines the data to store in the buffer</param>
        /// <param name="offsetLocations">defines the offsets or attributes information used to determine where data must be stored in the buffer</param>
        abstract updateAndBindInstancesBuffer: instancesBuffer: WebGLBuffer * data: Float32Array * offsetLocations: U2<ResizeArray<float>, ResizeArray<InstancingAttributeInfo>> -> unit
        /// Apply all cached states (depth, culling, stencil and alpha)
        abstract applyStates: unit -> unit
        /// <summary>Send a draw order</summary>
        /// <param name="useTriangles">defines if triangles must be used to draw (else wireframe will be used)</param>
        /// <param name="indexStart">defines the starting index</param>
        /// <param name="indexCount">defines the number of index to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract draw: useTriangles: bool * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of points</summary>
        /// <param name="verticesStart">defines the index of first vertex to draw</param>
        /// <param name="verticesCount">defines the count of vertices to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawPointClouds: verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of unindexed primitives</summary>
        /// <param name="useTriangles">defines if triangles must be used to draw (else wireframe will be used)</param>
        /// <param name="verticesStart">defines the index of first vertex to draw</param>
        /// <param name="verticesCount">defines the count of vertices to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawUnIndexed: useTriangles: bool * verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of indexed primitives</summary>
        /// <param name="fillMode">defines the primitive to use</param>
        /// <param name="indexStart">defines the starting index</param>
        /// <param name="indexCount">defines the number of index to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawElementsType: fillMode: float * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        /// <summary>Draw a list of unindexed primitives</summary>
        /// <param name="fillMode">defines the primitive to use</param>
        /// <param name="verticesStart">defines the index of first vertex to draw</param>
        /// <param name="verticesCount">defines the count of vertices to draw</param>
        /// <param name="instancesCount">defines the number of instances to draw (if instanciation is enabled)</param>
        abstract drawArraysType: fillMode: float * verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        abstract _drawMode: fillMode: obj -> unit
        abstract _releaseEffect: effect: Effect -> unit
        abstract _deleteProgram: program: WebGLProgram -> unit
        /// <summary>Create a new effect (used to store vertex/fragment shaders)</summary>
        /// <param name="baseName">defines the base name of the effect (The name of file without .fragment.fx or .vertex.fx)</param>
        /// <param name="attributesNamesOrOptions">defines either a list of attribute names or an EffectCreationOptions object</param>
        /// <param name="uniformsNamesOrEngine">defines either a list of uniform names or the engine to use</param>
        /// <param name="samplers">defines an array of string used to represent textures</param>
        /// <param name="defines">defines the string containing the defines to use to compile the shaders</param>
        /// <param name="fallbacks">defines the list of potential fallbacks to use if shader conmpilation fails</param>
        /// <param name="onCompiled">defines a function to call when the effect creation is successful</param>
        /// <param name="onError">defines a function to call when the effect creation has failed</param>
        /// <param name="indexParameters">defines an object containing the index values to use to compile shaders (like the maximum number of simultaneous lights)</param>
        abstract createEffect: baseName: obj option * attributesNamesOrOptions: U2<ResizeArray<string>, EffectCreationOptions> * uniformsNamesOrEngine: U2<ResizeArray<string>, Engine> * ?samplers: ResizeArray<string> * ?defines: string * ?fallbacks: EffectFallbacks * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) * ?indexParameters: obj option -> Effect
        /// <summary>Create an effect to use with particle systems</summary>
        /// <param name="fragmentName">defines the base name of the effect (The name of file without .fragment.fx)</param>
        /// <param name="uniformsNames">defines a list of attribute names</param>
        /// <param name="samplers">defines an array of string used to represent textures</param>
        /// <param name="defines">defines the string containing the defines to use to compile the shaders</param>
        /// <param name="fallbacks">defines the list of potential fallbacks to use if shader conmpilation fails</param>
        /// <param name="onCompiled">defines a function to call when the effect creation is successful</param>
        /// <param name="onError">defines a function to call when the effect creation has failed</param>
        abstract createEffectForParticles: fragmentName: string * ?uniformsNames: ResizeArray<string> * ?samplers: ResizeArray<string> * ?defines: string * ?fallbacks: EffectFallbacks * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> Effect
        /// <summary>Directly creates a webGL program</summary>
        /// <param name="vertexCode">defines the vertex shader code to use</param>
        /// <param name="fragmentCode">defines the fragment shader code to use</param>
        /// <param name="context">defines the webGL context to use (if not set, the current one will be used)</param>
        /// <param name="transformFeedbackVaryings">defines the list of transform feedback varyings to use</param>
        abstract createRawShaderProgram: vertexCode: string * fragmentCode: string * ?context: WebGLRenderingContext * ?transformFeedbackVaryings: Nullable<ResizeArray<string>> -> WebGLProgram
        /// <summary>Creates a webGL program</summary>
        /// <param name="vertexCode">defines the vertex shader code to use</param>
        /// <param name="fragmentCode">defines the fragment shader code to use</param>
        /// <param name="defines">defines the string containing the defines to use to compile the shaders</param>
        /// <param name="context">defines the webGL context to use (if not set, the current one will be used)</param>
        /// <param name="transformFeedbackVaryings">defines the list of transform feedback varyings to use</param>
        abstract createShaderProgram: vertexCode: string * fragmentCode: string * defines: Nullable<string> * ?context: WebGLRenderingContext * ?transformFeedbackVaryings: Nullable<ResizeArray<string>> -> WebGLProgram
        abstract _createShaderProgram: vertexShader: obj * fragmentShader: obj * context: obj * ?transformFeedbackVaryings: obj -> unit
        /// <summary>Gets the list of webGL uniform locations associated with a specific program based on a list of uniform names</summary>
        /// <param name="shaderProgram">defines the webGL program to use</param>
        /// <param name="uniformsNames">defines the list of uniform names</param>
        abstract getUniforms: shaderProgram: WebGLProgram * uniformsNames: ResizeArray<string> -> ResizeArray<Nullable<WebGLUniformLocation>>
        /// <summary>Gets the lsit of active attributes for a given webGL program</summary>
        /// <param name="shaderProgram">defines the webGL program to use</param>
        /// <param name="attributesNames">defines the list of attribute names to get</param>
        abstract getAttributes: shaderProgram: WebGLProgram * attributesNames: ResizeArray<string> -> ResizeArray<float>
        /// <summary>Activates an effect, mkaing it the current one (ie. the one used for rendering)</summary>
        /// <param name="effect">defines the effect to activate</param>
        abstract enableEffect: effect: Nullable<Effect> -> unit
        /// <summary>Set the value of an uniform to an array of int32</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of int32 (stored as vec2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray2: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of int32 (stored as vec3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray3: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of int32 (stored as vec4)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of int32 to store</param>
        abstract setIntArray4: uniform: Nullable<WebGLUniformLocation> * array: Int32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as vec2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray2: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as vec3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray3: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as vec4)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of float32 to store</param>
        abstract setFloatArray4: uniform: Nullable<WebGLUniformLocation> * array: Float32Array -> unit
        /// <summary>Set the value of an uniform to an array of number</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of number (stored as vec2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray2: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of number (stored as vec3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray3: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of number (stored as vec4)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="array">defines the array of number to store</param>
        abstract setArray4: uniform: Nullable<WebGLUniformLocation> * array: ResizeArray<float> -> unit
        /// <summary>Set the value of an uniform to an array of float32 (stored as matrices)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrices">defines the array of float32 to store</param>
        abstract setMatrices: uniform: Nullable<WebGLUniformLocation> * matrices: Float32Array -> unit
        /// <summary>Set the value of an uniform to a matrix</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrix">defines the matrix to store</param>
        abstract setMatrix: uniform: Nullable<WebGLUniformLocation> * matrix: Matrix -> unit
        /// <summary>Set the value of an uniform to a matrix (3x3)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrix">defines the Float32Array representing the 3x3 matrix to store</param>
        abstract setMatrix3x3: uniform: Nullable<WebGLUniformLocation> * matrix: Float32Array -> unit
        /// <summary>Set the value of an uniform to a matrix (2x2)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="matrix">defines the Float32Array representing the 2x2 matrix to store</param>
        abstract setMatrix2x2: uniform: Nullable<WebGLUniformLocation> * matrix: Float32Array -> unit
        /// <summary>Set the value of an uniform to a number (int)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="value">defines the int number to store</param>
        abstract setInt: uniform: Nullable<WebGLUniformLocation> * value: float -> unit
        /// <summary>Set the value of an uniform to a number (float)</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="value">defines the float number to store</param>
        abstract setFloat: uniform: Nullable<WebGLUniformLocation> * value: float -> unit
        /// <summary>Set the value of an uniform to a vec2</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="x">defines the 1st component of the value</param>
        /// <param name="y">defines the 2nd component of the value</param>
        abstract setFloat2: uniform: Nullable<WebGLUniformLocation> * x: float * y: float -> unit
        /// <summary>Set the value of an uniform to a vec3</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="x">defines the 1st component of the value</param>
        /// <param name="y">defines the 2nd component of the value</param>
        /// <param name="z">defines the 3rd component of the value</param>
        abstract setFloat3: uniform: Nullable<WebGLUniformLocation> * x: float * y: float * z: float -> unit
        /// <summary>Set the value of an uniform to a boolean</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="bool">defines the boolean to store</param>
        abstract setBool: uniform: Nullable<WebGLUniformLocation> * bool: float -> unit
        /// <summary>Set the value of an uniform to a vec4</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="x">defines the 1st component of the value</param>
        /// <param name="y">defines the 2nd component of the value</param>
        /// <param name="z">defines the 3rd component of the value</param>
        /// <param name="w">defines the 4th component of the value</param>
        abstract setFloat4: uniform: Nullable<WebGLUniformLocation> * x: float * y: float * z: float * w: float -> unit
        /// <summary>Set the value of an uniform to a Color3</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="color3">defines the color to store</param>
        abstract setColor3: uniform: Nullable<WebGLUniformLocation> * color3: Color3 -> unit
        /// <summary>Set the value of an uniform to a Color3 and an alpha value</summary>
        /// <param name="uniform">defines the webGL uniform location where to store the value</param>
        /// <param name="color3">defines the color to store</param>
        /// <param name="alpha">defines the alpha component to store</param>
        abstract setColor4: uniform: Nullable<WebGLUniformLocation> * color3: Color3 * alpha: float -> unit
        /// <summary>Sets a Color4 on a uniform variable</summary>
        /// <param name="uniform">defines the uniform location</param>
        /// <param name="color4">defines the value to be set</param>
        abstract setDirectColor4: uniform: Nullable<WebGLUniformLocation> * color4: Color4 -> unit
        /// <summary>Set various states to the webGL context</summary>
        /// <param name="culling">defines backface culling state</param>
        /// <param name="zOffset">defines the value to apply to zOffset (0 by default)</param>
        /// <param name="force">defines if states must be applied even if cache is up to date</param>
        /// <param name="reverseSide">defines if culling must be reversed (CCW instead of CW and CW instead of CCW)</param>
        abstract setState: culling: bool * ?zOffset: float * ?force: bool * ?reverseSide: bool -> unit
        /// <summary>Set the z offset to apply to current rendering</summary>
        /// <param name="value">defines the offset to apply</param>
        abstract setZOffset: value: float -> unit
        /// Gets the current value of the zOffset
        abstract getZOffset: unit -> float
        /// <summary>Enable or disable depth buffering</summary>
        /// <param name="enable">defines the state to set</param>
        abstract setDepthBuffer: enable: bool -> unit
        /// Gets a boolean indicating if depth writing is enabled
        abstract getDepthWrite: unit -> bool
        /// <summary>Enable or disable depth writing</summary>
        /// <param name="enable">defines the state to set</param>
        abstract setDepthWrite: enable: bool -> unit
        /// <summary>Enable or disable color writing</summary>
        /// <param name="enable">defines the state to set</param>
        abstract setColorWrite: enable: bool -> unit
        /// Gets a boolean indicating if color writing is enabled
        abstract getColorWrite: unit -> bool
        /// <summary>Sets alpha constants used by some alpha blending modes</summary>
        /// <param name="r">defines the red component</param>
        /// <param name="g">defines the green component</param>
        /// <param name="b">defines the blue component</param>
        /// <param name="a">defines the alpha component</param>
        abstract setAlphaConstants: r: float * g: float * b: float * a: float -> unit
        /// <summary>Sets the current alpha mode</summary>
        /// <param name="mode">defines the mode to use (one of the BABYLON.Engine.ALPHA_XXX)</param>
        /// <param name="noDepthWriteChange">defines if depth writing state should remains unchanged (false by default)</param>
        abstract setAlphaMode: mode: float * ?noDepthWriteChange: bool -> unit
        /// Gets the current alpha mode
        abstract getAlphaMode: unit -> float
        /// <summary>Force the entire cache to be cleared
        /// You should not have to use this function unless your engine needs to share the webGL context with another engine</summary>
        /// <param name="bruteForce">defines a boolean to force clearing ALL caches (including stencil, detoh and alpha states)</param>
        abstract wipeCaches: ?bruteForce: bool -> unit
        /// <summary>Set the compressed texture format to use, based on the formats you have, and the formats
        /// supported by the hardware / browser.
        /// 
        /// Khronos Texture Container (.ktx) files are used to support this.  This format has the
        /// advantage of being specifically designed for OpenGL.  Header elements directly correspond
        /// to API arguments needed to compressed textures.  This puts the burden on the container
        /// generator to house the arcane code for determining these for current & future formats.
        /// 
        /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
        /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
        /// 
        /// Note: The result of this call is not taken into account when a texture is base64.</summary>
        /// <param name="formatsAvailable">defines the list of those format families you have created
        /// on your server.  Syntax: '-' + format family + '.ktx'.  (Case and order do not matter.)
        /// 
        /// Current families are astc, dxt, pvrtc, etc2, & etc1.</param>
        abstract setTextureFormatToUse: formatsAvailable: Array<string> -> Nullable<string>
        abstract _createTexture: unit -> WebGLTexture
        /// <summary>Usually called from BABYLON.Texture.ts.
        /// Passed information to create a WebGLTexture</summary>
        /// <param name="urlArg">defines a value which contains one of the following:
        /// * A conventional http URL, e.g. 'http://...' or 'file://...'
        /// * A base64 string of in-line texture data, e.g. 'data:image/jpg;base64,/...'
        /// * An indicator that data being passed using the buffer parameter, e.g. 'data:mytexture.jpg'</param>
        /// <param name="noMipmap">defines a boolean indicating that no mipmaps shall be generated.  Ignored for compressed textures.  They must be in the file</param>
        /// <param name="invertY">when true, image is flipped when loaded.  You probably want true. Ignored for compressed textures.  Must be flipped in the file</param>
        /// <param name="scene">needed for loading to the correct scene</param>
        /// <param name="samplingMode">mode with should be used sample / access the texture (Default: BABYLON.Texture.TRILINEAR_SAMPLINGMODE)</param>
        /// <param name="onLoad">optional callback to be called upon successful completion</param>
        /// <param name="onError">optional callback to be called upon failure</param>
        /// <param name="buffer">a source of a file previously fetched as either an ArrayBuffer (compressed or image format) or HTMLImageElement (image format)</param>
        /// <param name="fallback">an internal argument in case the function must be called again, due to etc1 not having alpha capabilities</param>
        /// <param name="format">internal format.  Default: RGB when extension is '.jpg' else RGBA.  Ignored for compressed textures</param>
        abstract createTexture: urlArg: Nullable<string> * noMipmap: bool * invertY: bool * scene: Nullable<Scene> * ?samplingMode: float * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?buffer: Nullable<U2<ArrayBuffer, HTMLImageElement>> * ?fallback: Nullable<InternalTexture> * ?format: Nullable<float> -> InternalTexture
        abstract _rescaleTexture: source: obj * destination: obj * scene: obj * internalFormat: obj * onComplete: obj -> unit
        /// <summary>Update a raw texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="data">defines the data to store in the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        /// <param name="type">defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        abstract updateRawTexture: texture: Nullable<InternalTexture> * data: Nullable<ArrayBufferView> * format: float * invertY: bool * ?compression: Nullable<string> * ?``type``: float -> unit
        /// <summary>Creates a raw texture</summary>
        /// <param name="data">defines the data to store in the texture</param>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="generateMipMaps">defines if the engine should generate the mip levels</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        /// <param name="type">defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        abstract createRawTexture: data: Nullable<ArrayBufferView> * width: float * height: float * format: float * generateMipMaps: bool * invertY: bool * samplingMode: float * ?compression: Nullable<string> * ?``type``: float -> InternalTexture
        /// <summary>Creates a dynamic texture</summary>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="generateMipMaps">defines if the engine should generate the mip levels</param>
        /// <param name="samplingMode">defines the required sampling mode (BABYLON.Texture.NEAREST_SAMPLINGMODE by default)</param>
        abstract createDynamicTexture: width: float * height: float * generateMipMaps: bool * samplingMode: float -> InternalTexture
        /// <summary>Update the sampling mode of a given texture</summary>
        /// <param name="samplingMode">defines the required sampling mode</param>
        /// <param name="texture">defines the texture to update</param>
        abstract updateTextureSamplingMode: samplingMode: float * texture: InternalTexture -> unit
        /// <summary>Update the content of a dynamic texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="canvas">defines the canvas containing the source</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="premulAlpha">defines if alpha is stored as premultiplied</param>
        /// <param name="format">defines the format of the data</param>
        abstract updateDynamicTexture: texture: Nullable<InternalTexture> * canvas: HTMLCanvasElement * invertY: bool * ?premulAlpha: bool * ?format: float -> unit
        /// <summary>Update a video texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="video">defines the video element to use</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        abstract updateVideoTexture: texture: Nullable<InternalTexture> * video: HTMLVideoElement * invertY: bool -> unit
        /// <summary>Updates a depth texture Comparison Mode and Function.
        /// If the comparison Function is equal to 0, the mode will be set to none.
        /// Otherwise, this only works in webgl 2 and requires a shadow sampler in the shader.</summary>
        /// <param name="texture">The texture to set the comparison function for</param>
        /// <param name="comparisonFunction">The comparison function to set, 0 if no comparison required</param>
        abstract updateTextureComparisonFunction: texture: InternalTexture * comparisonFunction: float -> unit
        abstract _setupDepthStencilTexture: internalTexture: obj * size: obj * generateStencil: obj * bilinearFiltering: obj * comparisonFunction: obj -> unit
        /// <summary>Creates a depth stencil texture.
        /// This is only available in WebGL 2 or with the depth texture extension available.</summary>
        /// <param name="size">The size of face edge in the texture.</param>
        /// <param name="options">The options defining the texture.</param>
        abstract createDepthStencilTexture: size: U2<float, obj> * options: DepthTextureCreationOptions -> InternalTexture
        /// <summary>Creates a depth stencil texture.
        /// This is only available in WebGL 2 or with the depth texture extension available.</summary>
        /// <param name="size">The size of face edge in the texture.</param>
        /// <param name="options">The options defining the texture.</param>
        abstract _createDepthStencilTexture: size: obj * options: obj -> unit
        /// <summary>Creates a depth stencil cube texture.
        /// This is only available in WebGL 2.</summary>
        /// <param name="size">The size of face edge in the cube texture.</param>
        /// <param name="options">The options defining the cube texture.</param>
        abstract _createDepthStencilCubeTexture: size: obj * options: obj -> unit
        /// <summary>Sets the frame buffer Depth / Stencil attachement of the render target to the defined depth stencil texture.</summary>
        /// <param name="renderTarget">The render target to set the frame buffer for</param>
        abstract setFrameBufferDepthStencilTexture: renderTarget: RenderTargetTexture -> unit
        /// <summary>Creates a new render target texture</summary>
        /// <param name="size">defines the size of the texture</param>
        /// <param name="options">defines the options used to create the texture</param>
        abstract createRenderTargetTexture: size: U2<float, obj> * options: U2<bool, RenderTargetCreationOptions> -> InternalTexture
        /// <summary>Create a multi render target texture</summary>
        /// <param name="size">defines the size of the texture</param>
        /// <param name="options">defines the creation options</param>
        abstract createMultipleRenderTarget: size: obj option * options: IMultiRenderTargetOptions -> ResizeArray<InternalTexture>
        abstract _setupFramebufferDepthAttachments: generateStencilBuffer: obj * generateDepthBuffer: obj * width: obj * height: obj * ?samples: obj -> unit
        /// <summary>Updates the sample count of a render target texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="samples">defines the sample count to set</param>
        abstract updateRenderTargetTextureSampleCount: texture: Nullable<InternalTexture> * samples: float -> float
        /// <summary>Update the sample count for a given multiple render target texture</summary>
        /// <param name="textures">defines the textures to update</param>
        /// <param name="samples">defines the sample count to set</param>
        abstract updateMultipleRenderTargetTextureSampleCount: textures: Nullable<ResizeArray<InternalTexture>> * samples: float -> float
        abstract _uploadDataToTexture: target: float * lod: float * internalFormat: float * width: float * height: float * format: float * ``type``: float * data: ArrayBufferView -> unit
        abstract _uploadCompressedDataToTexture: target: float * lod: float * internalFormat: float * width: float * height: float * data: ArrayBufferView -> unit
        /// <summary>Creates a new render target cube texture</summary>
        /// <param name="size">defines the size of the texture</param>
        /// <param name="options">defines the options used to create the texture</param>
        abstract createRenderTargetCubeTexture: size: float * ?options: obj -> InternalTexture
        /// <summary>Create a cube texture from prefiltered data (ie. the mipmaps contain ready to use data for PBR reflection)</summary>
        /// <param name="rootUrl">defines the url where the file to load is located</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="scale">defines scale to apply to the mip map selection</param>
        /// <param name="offset">defines offset to apply to the mip map selection</param>
        /// <param name="onLoad">defines an optional callback raised when the texture is loaded</param>
        /// <param name="onError">defines an optional callback raised if there is an issue to load the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="forcedExtension">defines the extension to use to pick the right loader</param>
        abstract createPrefilteredCubeTexture: rootUrl: string * scene: Nullable<Scene> * scale: float * offset: float * ?onLoad: Nullable<(Nullable<InternalTexture> -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?format: float * ?forcedExtension: obj option -> InternalTexture
        /// <summary>Creates a cube texture</summary>
        /// <param name="rootUrl">defines the url where the files to load is located</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="files">defines the list of files to load (1 per face)</param>
        /// <param name="noMipmap">defines a boolean indicating that no mipmaps shall be generated (false by default)</param>
        /// <param name="onLoad">defines an optional callback raised when the texture is loaded</param>
        /// <param name="onError">defines an optional callback raised if there is an issue to load the texture</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="forcedExtension">defines the extension to use to pick the right loader</param>
        abstract createCubeTexture: rootUrl: string * scene: Nullable<Scene> * files: Nullable<ResizeArray<string>> * ?noMipmap: bool * ?onLoad: Nullable<(obj option -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?format: float * ?forcedExtension: obj option -> InternalTexture
        abstract setCubeMapTextureParams: gl: obj * loadMipmap: obj -> unit
        /// <summary>Update a raw cube texture</summary>
        /// <param name="texture">defines the texture to udpdate</param>
        /// <param name="data">defines the data to store</param>
        /// <param name="format">defines the data format</param>
        /// <param name="type">defines the type fo the data (BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT by default)</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        /// <param name="level">defines which level of the texture to update</param>
        abstract updateRawCubeTexture: texture: InternalTexture * data: ResizeArray<ArrayBufferView> * format: float * ``type``: float * invertY: bool * ?compression: Nullable<string> * ?level: float -> unit
        /// <summary>Creates a new raw cube texture</summary>
        /// <param name="data">defines the array of data to use to create each face</param>
        /// <param name="size">defines the size of the textures</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="type">defines the type fo the data (like BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT)</param>
        /// <param name="generateMipMaps">defines if the engine should generate the mip levels</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)</param>
        /// <param name="compression">defines the compression used (null by default)</param>
        abstract createRawCubeTexture: data: Nullable<ResizeArray<ArrayBufferView>> * size: float * format: float * ``type``: float * generateMipMaps: bool * invertY: bool * samplingMode: float * ?compression: Nullable<string> -> InternalTexture
        /// <summary>Creates a new raw cube texture from a specified url</summary>
        /// <param name="url">defines the url where the data is located</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="size">defines the size of the textures</param>
        /// <param name="format">defines the format of the data</param>
        /// <param name="type">defines the type fo the data (like BABYLON.Engine.TEXTURETYPE_UNSIGNED_INT)</param>
        /// <param name="noMipmap">defines if the engine should avoid generating the mip levels</param>
        /// <param name="callback">defines a callback used to extract texture data from loaded data</param>
        /// <param name="mipmapGenerator">defines to provide an optional tool to generate mip levels</param>
        /// <param name="onLoad">defines a callback called when texture is loaded</param>
        /// <param name="onError">defines a callback called if there is an error</param>
        /// <param name="samplingMode">defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        abstract createRawCubeTextureFromUrl: url: string * scene: Scene * size: float * format: float * ``type``: float * noMipmap: bool * callback: (ArrayBuffer -> Nullable<ResizeArray<ArrayBufferView>>) * mipmapGenerator: Nullable<(ResizeArray<ArrayBufferView> -> ResizeArray<ResizeArray<ArrayBufferView>>)> * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?samplingMode: float * ?invertY: bool -> InternalTexture
        /// <summary>Update a raw 3D texture</summary>
        /// <param name="texture">defines the texture to update</param>
        /// <param name="data">defines the data to store</param>
        /// <param name="format">defines the data format</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="compression">defines the used compression (can be null)</param>
        abstract updateRawTexture3D: texture: InternalTexture * data: Nullable<ArrayBufferView> * format: float * invertY: bool * ?compression: Nullable<string> -> unit
        /// <summary>Creates a new raw 3D texture</summary>
        /// <param name="data">defines the data used to create the texture</param>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="depth">defines the depth of the texture</param>
        /// <param name="format">defines the format of the texture</param>
        /// <param name="generateMipMaps">defines if the engine must generate mip levels</param>
        /// <param name="invertY">defines if data must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the required sampling mode (like BABYLON.Texture.NEAREST_SAMPLINGMODE)</param>
        /// <param name="compression">defines the compressed used (can be null)</param>
        abstract createRawTexture3D: data: Nullable<ArrayBufferView> * width: float * height: float * depth: float * format: float * generateMipMaps: bool * invertY: bool * samplingMode: float * ?compression: Nullable<string> -> InternalTexture
        abstract _prepareWebGLTextureContinuation: texture: obj * scene: obj * noMipmap: obj * isCompressed: obj * samplingMode: obj -> unit
        abstract _prepareWebGLTexture: texture: obj * scene: obj * width: obj * height: obj * invertY: obj * noMipmap: obj * isCompressed: obj * processFunction: obj * ?samplingMode: obj -> unit
        abstract _convertRGBtoRGBATextureData: rgbData: obj * width: obj * height: obj * textureType: obj -> unit
        abstract _releaseFramebufferObjects: texture: InternalTexture -> unit
        abstract _releaseTexture: texture: InternalTexture -> unit
        abstract setProgram: program: obj -> unit
        abstract _boundUniforms: obj with get, set
        /// <summary>Binds an effect to the webGL context</summary>
        /// <param name="effect">defines the effect to bind</param>
        abstract bindSamplers: effect: Effect -> unit
        abstract _moveBoundTextureOnTop: internalTexture: obj -> unit
        abstract _getCorrectTextureChannel: channel: obj * internalTexture: obj -> unit
        abstract _linkTrackers: previous: obj * next: obj -> unit
        abstract _removeDesignatedSlot: internalTexture: obj -> unit
        abstract _activateCurrentTexture: unit -> unit
        abstract _bindTextureDirectly: target: float * texture: Nullable<InternalTexture> * ?forTextureDataUpdate: bool * ?force: bool -> unit
        abstract _bindTexture: channel: float * texture: Nullable<InternalTexture> -> unit
        /// <summary>Sets a texture to the webGL context from a postprocess</summary>
        /// <param name="channel">defines the channel to use</param>
        /// <param name="postProcess">defines the source postprocess</param>
        abstract setTextureFromPostProcess: channel: float * postProcess: Nullable<PostProcess> -> unit
        /// <summary>Binds the output of the passed in post process to the texture channel specified</summary>
        /// <param name="channel">The channel the texture should be bound to</param>
        /// <param name="postProcess">The post process which's output should be bound</param>
        abstract setTextureFromPostProcessOutput: channel: float * postProcess: Nullable<PostProcess> -> unit
        /// Unbind all textures from the webGL context
        abstract unbindAllTextures: unit -> unit
        /// <summary>Sets a texture to the according uniform.</summary>
        /// <param name="channel">The texture channel</param>
        /// <param name="uniform">The uniform to set</param>
        /// <param name="texture">The texture to apply</param>
        abstract setTexture: channel: float * uniform: Nullable<WebGLUniformLocation> * texture: Nullable<BaseTexture> -> unit
        /// <summary>Sets a depth stencil texture from a render target to the according uniform.</summary>
        /// <param name="channel">The texture channel</param>
        /// <param name="uniform">The uniform to set</param>
        /// <param name="texture">The render target texture containing the depth stencil texture to apply</param>
        abstract setDepthStencilTexture: channel: float * uniform: Nullable<WebGLUniformLocation> * texture: Nullable<RenderTargetTexture> -> unit
        abstract _bindSamplerUniformToChannel: sourceSlot: obj * destination: obj -> unit
        abstract _getTextureWrapMode: mode: obj -> unit
        abstract _setTexture: channel: obj * texture: obj * ?isPartOfTextureArray: obj * ?depthStencilTexture: obj -> unit
        /// <summary>Sets an array of texture to the webGL context</summary>
        /// <param name="channel">defines the channel where the texture array must be set</param>
        /// <param name="uniform">defines the associated uniform location</param>
        /// <param name="textures">defines the array of textures to bind</param>
        abstract setTextureArray: channel: float * uniform: Nullable<WebGLUniformLocation> * textures: ResizeArray<BaseTexture> -> unit
        abstract _setAnisotropicLevel: target: float * texture: BaseTexture -> unit
        abstract _setTextureParameterFloat: target: obj * parameter: obj * value: obj * texture: obj -> unit
        abstract _setTextureParameterInteger: target: obj * parameter: obj * value: obj * ?texture: obj -> unit
        /// <summary>Reads pixels from the current frame buffer. Please note that this function can be slow</summary>
        /// <param name="x">defines the x coordinate of the rectangle where pixels must be read</param>
        /// <param name="y">defines the y coordinate of the rectangle where pixels must be read</param>
        /// <param name="width">defines the width of the rectangle where pixels must be read</param>
        /// <param name="height">defines the height of the rectangle where pixels must be read</param>
        abstract readPixels: x: float * y: float * width: float * height: float -> Uint8Array
        /// <summary>Add an externaly attached data from its key.
        /// This method call will fail and return false, if such key already exists.
        /// If you don't care and just want to get the data no matter what, use the more convenient getOrAddExternalDataWithFactory() method.</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="data">the data object to associate to the key for this Engine instance</param>
        abstract addExternalData: key: string * data: 'T -> bool
        /// <summary>Get an externaly attached data from its key</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract getExternalData: key: string -> 'T
        /// <summary>Get an externaly attached data from its key, create it using a factory if it's not already present</summary>
        /// <param name="key">the unique key that identifies the data</param>
        /// <param name="factory">the factory that will be called to create the instance if and only if it doesn't exists</param>
        abstract getOrAddExternalDataWithFactory: key: string * factory: (string -> 'T) -> 'T
        /// <summary>Remove an externaly attached data from the Engine instance</summary>
        /// <param name="key">the unique key that identifies the data</param>
        abstract removeExternalData: key: string -> bool
        /// Unbind all vertex attributes from the webGL context
        abstract unbindAllAttributes: unit -> unit
        /// Force the engine to release all cached effects. This means that next effect compilation will have to be done completely even if a similar effect was already compiled
        abstract releaseEffects: unit -> unit
        /// Dispose and release all associated resources
        abstract dispose: unit -> unit
        /// Display the loading screen
        abstract displayLoadingUI: unit -> unit
        /// Hide the loading screen
        abstract hideLoadingUI: unit -> unit
        /// Gets the current loading screen object
        /// Sets the current loading screen object
        abstract loadingScreen: ILoadingScreen with get, set
        /// Sets the current loading screen text
        abstract loadingUIText: string with get, set
        /// Sets the current loading screen background color
        abstract loadingUIBackgroundColor: string with get, set
        /// <summary>Attach a new callback raised when context lost event is fired</summary>
        /// <param name="callback">defines the callback to call</param>
        abstract attachContextLostEvent: callback: (WebGLContextEvent -> unit) -> unit
        /// <summary>Attach a new callback raised when context restored event is fired</summary>
        /// <param name="callback">defines the callback to call</param>
        abstract attachContextRestoredEvent: callback: (WebGLContextEvent -> unit) -> unit
        /// <summary>Gets the source code of the vertex shader associated with a specific webGL program</summary>
        /// <param name="program">defines the program to use</param>
        abstract getVertexShaderSource: program: WebGLProgram -> Nullable<string>
        /// <summary>Gets the source code of the fragment shader associated with a specific webGL program</summary>
        /// <param name="program">defines the program to use</param>
        abstract getFragmentShaderSource: program: WebGLProgram -> Nullable<string>
        /// Get the current error code of the webGL context
        abstract getError: unit -> float
        /// Gets the current framerate
        abstract getFps: unit -> float
        /// Gets the time spent between current and previous frame
        abstract getDeltaTime: unit -> float
        abstract _measureFps: unit -> unit
        abstract _readTexturePixels: texture: InternalTexture * width: float * height: float * ?faceIndex: float -> ArrayBufferView
        abstract _canRenderToFloatFramebuffer: unit -> unit
        abstract _canRenderToHalfFloatFramebuffer: unit -> unit
        abstract _canRenderToFramebuffer: ``type``: obj -> unit
        abstract _getWebGLTextureType: ``type``: float -> float
        abstract _getInternalFormat: format: obj -> unit
        abstract _getRGBABufferInternalSizedFormat: ``type``: float * ?format: float -> float
        abstract _getRGBAMultiSampleBufferFormat: ``type``: float -> float
        /// Create a new webGL query (you must be sure that queries are supported by checking getCaps() function)
        abstract createQuery: unit -> WebGLQuery
        /// <summary>Delete and release a webGL query</summary>
        /// <param name="query">defines the query to delete</param>
        abstract deleteQuery: query: WebGLQuery -> Engine
        /// <summary>Check if a given query has resolved and got its value</summary>
        /// <param name="query">defines the query to check</param>
        abstract isQueryResultAvailable: query: WebGLQuery -> bool
        /// <summary>Gets the value of a given query</summary>
        /// <param name="query">defines the query to check</param>
        abstract getQueryResult: query: WebGLQuery -> float
        /// <summary>Initiates an occlusion query</summary>
        /// <param name="algorithmType">defines the algorithm to use</param>
        /// <param name="query">defines the query to use</param>
        abstract beginOcclusionQuery: algorithmType: float * query: WebGLQuery -> Engine
        /// <summary>Ends an occlusion query</summary>
        /// <param name="algorithmType">defines the algorithm to use</param>
        abstract endOcclusionQuery: algorithmType: float -> Engine
        abstract _createTimeQuery: unit -> unit
        abstract _deleteTimeQuery: query: obj -> unit
        abstract _getTimeQueryResult: query: obj -> unit
        abstract _getTimeQueryAvailability: query: obj -> unit
        abstract _currentNonTimestampToken: obj with get, set
        /// Starts a time query (used to measure time spent by the GPU on a specific frame)
        /// Please note that only one query can be issued at a time
        abstract startTimeQuery: unit -> Nullable<_TimeToken>
        /// <summary>Ends a time query</summary>
        /// <param name="token">defines the token used to measure the time span</param>
        abstract endTimeQuery: token: _TimeToken -> int
        abstract getGlAlgorithmType: algorithmType: obj -> unit
        /// Creates a webGL transform feedback object
        /// Please makes sure to check webGLVersion property to check if you are running webGL 2+
        abstract createTransformFeedback: unit -> WebGLTransformFeedback
        /// <summary>Delete a webGL transform feedback object</summary>
        /// <param name="value">defines the webGL transform feedback object to delete</param>
        abstract deleteTransformFeedback: value: WebGLTransformFeedback -> unit
        /// <summary>Bind a webGL transform feedback object to the webgl context</summary>
        /// <param name="value">defines the webGL transform feedback object to bind</param>
        abstract bindTransformFeedback: value: Nullable<WebGLTransformFeedback> -> unit
        /// <summary>Begins a transform feedback operation</summary>
        /// <param name="usePoints">defines if points or triangles must be used</param>
        abstract beginTransformFeedback: ?usePoints: bool -> unit
        /// Ends a transform feedback operation
        abstract endTransformFeedback: unit -> unit
        /// <summary>Specify the varyings to use with transform feedback</summary>
        /// <param name="program">defines the associated webGL program</param>
        /// <param name="value">defines the list of strings representing the varying names</param>
        abstract setTranformFeedbackVaryings: program: WebGLProgram * value: ResizeArray<string> -> unit
        /// <summary>Bind a webGL buffer for a transform feedback operation</summary>
        /// <param name="value">defines the webGL buffer to bind</param>
        abstract bindTransformFeedbackBuffer: value: Nullable<WebGLBuffer> -> unit
        abstract _loadFile: url: string * onSuccess: (U2<string, ArrayBuffer> -> string -> unit) * ?onProgress: (obj option -> unit) * ?database: Database * ?useArrayBuffer: bool * ?onError: (XMLHttpRequest -> obj option -> unit) -> IFileRequest
        abstract _loadFileAsync: url: string * ?database: Database * ?useArrayBuffer: bool -> Promise<U2<string, ArrayBuffer>>
        abstract _partialLoadFile: url: obj * index: obj * loadedFiles: obj * scene: obj * onfinish: obj * ?onErrorCallBack: obj -> unit
        abstract _cascadeLoadFiles: scene: obj * onfinish: obj * files: obj * ?onError: obj -> unit

    type [<AllowNullLiteral>] EngineRecordVertexArrayObjectVertexBuffers =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> VertexBuffer with get, set

    type [<AllowNullLiteral>] EngineBindBuffersVertexBuffers =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> Nullable<VertexBuffer> with get, set

    /// The engine class is responsible for interfacing with all lower-level APIs such as WebGL and Audio
    type [<AllowNullLiteral>] EngineStatic =
        /// <summary>Will flag all materials in all scenes in all engines as dirty to trigger new shader compilation</summary>
        /// <param name="flag">defines which part of the materials must be marked as dirty</param>
        /// <param name="predicate">defines a predicate used to filter which materials should be affected</param>
        abstract MarkAllMaterialsAsDirty: flag: float * ?predicate: (Material -> bool) -> unit
        /// <summary>Creates a new engine</summary>
        /// <param name="canvasOrContext">defines the canvas or WebGL context to use for rendering</param>
        /// <param name="antialias">defines enable antialiasing (default: false)</param>
        /// <param name="options">defines further options to be sent to the getContext() function</param>
        /// <param name="adaptToDeviceRatio">defines whether to adapt to the device's viewport characteristics (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: canvasOrContext: Nullable<U2<HTMLCanvasElement, WebGLRenderingContext>> * ?antialias: bool * ?options: EngineOptions * ?adaptToDeviceRatio: bool -> Engine
        /// Gets a boolean indicating if the engine can be instanciated (ie. if a webGL context can be found)
        abstract isSupported: unit -> bool

    type [<AllowNullLiteral>] NullEngineOptions =
        abstract renderWidth: float with get, set
        abstract renderHeight: float with get, set
        abstract textureSize: float with get, set
        abstract deterministicLockstep: bool with get, set
        abstract lockstepMaxSteps: float with get, set

    type [<AllowNullLiteral>] NullEngineOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> NullEngineOptions

    /// The null engine class provides support for headless version of babylon.js.
    /// This can be used in server side scenario or for testing purposes
    type [<AllowNullLiteral>] NullEngine =
        inherit Engine
        abstract _options: obj with get, set
        abstract isDeterministicLockStep: unit -> bool
        abstract getLockstepMaxSteps: unit -> float
        abstract getHardwareScalingLevel: unit -> float
        abstract createVertexBuffer: vertices: FloatArray -> WebGLBuffer
        abstract createIndexBuffer: indices: IndicesArray -> WebGLBuffer
        abstract clear: color: Color4 * backBuffer: bool * depth: bool * ?stencil: bool -> unit
        abstract getRenderWidth: ?useScreen: bool -> float
        abstract getRenderHeight: ?useScreen: bool -> float
        abstract setViewport: viewport: Viewport * ?requiredWidth: float * ?requiredHeight: float -> unit
        abstract createShaderProgram: vertexCode: string * fragmentCode: string * defines: string * ?context: WebGLRenderingContext -> WebGLProgram
        abstract getUniforms: shaderProgram: WebGLProgram * uniformsNames: ResizeArray<string> -> ResizeArray<WebGLUniformLocation>
        abstract getAttributes: shaderProgram: WebGLProgram * attributesNames: ResizeArray<string> -> ResizeArray<float>
        abstract bindSamplers: effect: Effect -> unit
        abstract enableEffect: effect: Effect -> unit
        abstract setState: culling: bool * ?zOffset: float * ?force: bool * ?reverseSide: bool -> unit
        abstract setIntArray: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setIntArray2: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setIntArray3: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setIntArray4: uniform: WebGLUniformLocation * array: Int32Array -> unit
        abstract setFloatArray: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setFloatArray2: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setFloatArray3: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setFloatArray4: uniform: WebGLUniformLocation * array: Float32Array -> unit
        abstract setArray: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setArray2: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setArray3: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setArray4: uniform: WebGLUniformLocation * array: ResizeArray<float> -> unit
        abstract setMatrices: uniform: WebGLUniformLocation * matrices: Float32Array -> unit
        abstract setMatrix: uniform: WebGLUniformLocation * matrix: Matrix -> unit
        abstract setMatrix3x3: uniform: WebGLUniformLocation * matrix: Float32Array -> unit
        abstract setMatrix2x2: uniform: WebGLUniformLocation * matrix: Float32Array -> unit
        abstract setFloat: uniform: WebGLUniformLocation * value: float -> unit
        abstract setFloat2: uniform: WebGLUniformLocation * x: float * y: float -> unit
        abstract setFloat3: uniform: WebGLUniformLocation * x: float * y: float * z: float -> unit
        abstract setBool: uniform: WebGLUniformLocation * bool: float -> unit
        abstract setFloat4: uniform: WebGLUniformLocation * x: float * y: float * z: float * w: float -> unit
        abstract setColor3: uniform: WebGLUniformLocation * color3: Color3 -> unit
        abstract setColor4: uniform: WebGLUniformLocation * color3: Color3 * alpha: float -> unit
        abstract setAlphaMode: mode: float * ?noDepthWriteChange: bool -> unit
        abstract bindBuffers: vertexBuffers: NullEngineBindBuffersVertexBuffers * indexBuffer: WebGLBuffer * effect: Effect -> unit
        abstract wipeCaches: ?bruteForce: bool -> unit
        abstract draw: useTriangles: bool * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        abstract drawElementsType: fillMode: float * indexStart: float * indexCount: float * ?instancesCount: float -> unit
        abstract drawArraysType: fillMode: float * verticesStart: float * verticesCount: float * ?instancesCount: float -> unit
        abstract _createTexture: unit -> WebGLTexture
        abstract _releaseTexture: texture: InternalTexture -> unit
        abstract createTexture: urlArg: string * noMipmap: bool * invertY: bool * scene: Scene * ?samplingMode: float * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?buffer: Nullable<U2<ArrayBuffer, HTMLImageElement>> * ?fallBack: InternalTexture * ?format: float -> InternalTexture
        abstract createRenderTargetTexture: size: obj option * options: U2<bool, RenderTargetCreationOptions> -> InternalTexture
        abstract updateTextureSamplingMode: samplingMode: float * texture: InternalTexture -> unit
        abstract bindFramebuffer: texture: InternalTexture * ?faceIndex: float * ?requiredWidth: float * ?requiredHeight: float * ?forceFullscreenViewport: bool -> unit
        abstract unBindFramebuffer: texture: InternalTexture * ?disableGenerateMipMaps: bool * ?onBeforeUnbind: (unit -> unit) -> unit
        abstract createDynamicVertexBuffer: vertices: FloatArray -> WebGLBuffer
        abstract updateDynamicIndexBuffer: indexBuffer: WebGLBuffer * indices: IndicesArray * ?offset: float -> unit
        /// <summary>Updates a dynamic vertex buffer.</summary>
        /// <param name="vertexBuffer">the vertex buffer to update</param>
        /// <param name="byteOffset">the byte offset of the data (optional)</param>
        /// <param name="byteLength">the byte length of the data (optional)</param>
        abstract updateDynamicVertexBuffer: vertexBuffer: WebGLBuffer * vertices: FloatArray * ?byteOffset: float * ?byteLength: float -> unit
        abstract _bindTextureDirectly: target: float * texture: InternalTexture -> unit
        abstract _bindTexture: channel: float * texture: InternalTexture -> unit
        abstract _releaseBuffer: buffer: WebGLBuffer -> bool

    type [<AllowNullLiteral>] NullEngineBindBuffersVertexBuffers =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: key: string -> VertexBuffer with get, set

    /// The null engine class provides support for headless version of babylon.js.
    /// This can be used in server side scenario or for testing purposes
    type [<AllowNullLiteral>] NullEngineStatic =
        [<Emit "new $0($1...)">] abstract Create: ?options: NullEngineOptions -> NullEngine

    type [<AllowNullLiteral>] KeyboardEventTypes =
        abstract _KEYDOWN: float with get, set
        abstract _KEYUP: float with get, set
        abstract KEYDOWN: float
        abstract KEYUP: float

    type [<AllowNullLiteral>] KeyboardEventTypesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> KeyboardEventTypes

    type [<AllowNullLiteral>] KeyboardInfo =
        abstract ``type``: float with get, set
        abstract ``event``: KeyboardEvent with get, set

    type [<AllowNullLiteral>] KeyboardInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: KeyboardEvent -> KeyboardInfo

    /// This class is used to store keyboard related info for the onPreKeyboardObservable event.
    /// Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
    type [<AllowNullLiteral>] KeyboardInfoPre =
        inherit KeyboardInfo
        abstract skipOnPointerObservable: bool with get, set

    /// This class is used to store keyboard related info for the onPreKeyboardObservable event.
    /// Set the skipOnKeyboardObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onKeyboardObservable
    type [<AllowNullLiteral>] KeyboardInfoPreStatic =
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: KeyboardEvent -> KeyboardInfoPre

    type [<AllowNullLiteral>] PointerEventTypes =
        abstract _POINTERDOWN: float with get, set
        abstract _POINTERUP: float with get, set
        abstract _POINTERMOVE: float with get, set
        abstract _POINTERWHEEL: float with get, set
        abstract _POINTERPICK: float with get, set
        abstract _POINTERTAP: float with get, set
        abstract _POINTERDOUBLETAP: float with get, set
        abstract POINTERDOWN: float
        abstract POINTERUP: float
        abstract POINTERMOVE: float
        abstract POINTERWHEEL: float
        abstract POINTERPICK: float
        abstract POINTERTAP: float
        abstract POINTERDOUBLETAP: float

    type [<AllowNullLiteral>] PointerEventTypesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PointerEventTypes

    type [<AllowNullLiteral>] PointerInfoBase =
        abstract ``type``: float with get, set
        abstract ``event``: U2<PointerEvent, MouseWheelEvent> with get, set

    type [<AllowNullLiteral>] PointerInfoBaseStatic =
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: U2<PointerEvent, MouseWheelEvent> -> PointerInfoBase

    /// This class is used to store pointer related info for the onPrePointerObservable event.
    /// Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
    type [<AllowNullLiteral>] PointerInfoPre =
        inherit PointerInfoBase
        abstract localPosition: Vector2 with get, set
        abstract skipOnPointerObservable: bool with get, set

    /// This class is used to store pointer related info for the onPrePointerObservable event.
    /// Set the skipOnPointerObservable property to true if you want the engine to stop any process after this event is triggered, even not calling onPointerObservable
    type [<AllowNullLiteral>] PointerInfoPreStatic =
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: U2<PointerEvent, MouseWheelEvent> * localX: float * localY: float -> PointerInfoPre

    /// This type contains all the data related to a pointer event in Babylon.js.
    /// The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
    type [<AllowNullLiteral>] PointerInfo =
        inherit PointerInfoBase
        abstract pickInfo: Nullable<PickingInfo> with get, set

    /// This type contains all the data related to a pointer event in Babylon.js.
    /// The event member is an instance of PointerEvent for all types except PointerWheel and is of type MouseWheelEvent when type equals PointerWheel. The different event types can be found in the PointerEventTypes class.
    type [<AllowNullLiteral>] PointerInfoStatic =
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * ``event``: U2<PointerEvent, MouseWheelEvent> * pickInfo: Nullable<PickingInfo> -> PointerInfo

    /// Represents the different options available during the creation of
    /// a Environment helper.
    /// 
    /// This can control the default ground, skybox and image processing setup of your scene.
    type [<AllowNullLiteral>] IEnvironmentHelperOptions =
        /// Specifies wether or not to create a ground.
        /// True by default.
        abstract createGround: bool with get, set
        /// Specifies the ground size.
        /// 15 by default.
        abstract groundSize: float with get, set
        /// The texture used on the ground for the main color.
        /// Comes from the BabylonJS CDN by default.
        /// 
        /// Remarks: Can be either a texture or a url.
        abstract groundTexture: U2<string, BaseTexture> with get, set
        /// The color mixed in the ground texture by default.
        /// BabylonJS clearColor by default.
        abstract groundColor: Color3 with get, set
        /// Specifies the ground opacity.
        /// 1 by default.
        abstract groundOpacity: float with get, set
        /// Enables the ground to receive shadows.
        /// True by default.
        abstract enableGroundShadow: bool with get, set
        /// Helps preventing the shadow to be fully black on the ground.
        /// 0.5 by default.
        abstract groundShadowLevel: float with get, set
        /// Creates a mirror texture attach to the ground.
        /// false by default.
        abstract enableGroundMirror: bool with get, set
        /// Specifies the ground mirror size ratio.
        /// 0.3 by default as the default kernel is 64.
        abstract groundMirrorSizeRatio: float with get, set
        /// Specifies the ground mirror blur kernel size.
        /// 64 by default.
        abstract groundMirrorBlurKernel: float with get, set
        /// Specifies the ground mirror visibility amount.
        /// 1 by default
        abstract groundMirrorAmount: float with get, set
        /// Specifies the ground mirror reflectance weight.
        /// This uses the standard weight of the background material to setup the fresnel effect
        /// of the mirror.
        /// 1 by default.
        abstract groundMirrorFresnelWeight: float with get, set
        /// Specifies the ground mirror Falloff distance.
        /// This can helps reducing the size of the reflection.
        /// 0 by Default.
        abstract groundMirrorFallOffDistance: float with get, set
        /// Specifies the ground mirror texture type.
        /// Unsigned Int by Default.
        abstract groundMirrorTextureType: float with get, set
        /// Specifies a bias applied to the ground vertical position to prevent z-fighyting with
        /// the shown objects.
        abstract groundYBias: float with get, set
        /// Specifies wether or not to create a skybox.
        /// True by default.
        abstract createSkybox: bool with get, set
        /// Specifies the skybox size.
        /// 20 by default.
        abstract skyboxSize: float with get, set
        /// The texture used on the skybox for the main color.
        /// Comes from the BabylonJS CDN by default.
        /// 
        /// Remarks: Can be either a texture or a url.
        abstract skyboxTexture: U2<string, BaseTexture> with get, set
        /// The color mixed in the skybox texture by default.
        /// BabylonJS clearColor by default.
        abstract skyboxColor: Color3 with get, set
        /// The background rotation around the Y axis of the scene.
        /// This helps aligning the key lights of your scene with the background.
        /// 0 by default.
        abstract backgroundYRotation: float with get, set
        /// Compute automatically the size of the elements to best fit with the scene.
        abstract sizeAuto: bool with get, set
        /// Default position of the rootMesh if autoSize is not true.
        abstract rootPosition: Vector3 with get, set
        /// Sets up the image processing in the scene.
        /// true by default.
        abstract setupImageProcessing: bool with get, set
        /// The texture used as your environment texture in the scene.
        /// Comes from the BabylonJS CDN by default and in use if setupImageProcessing is true.
        /// 
        /// Remarks: Can be either a texture or a url.
        abstract environmentTexture: U2<string, BaseTexture> with get, set
        /// The value of the exposure to apply to the scene.
        /// 0.6 by default if setupImageProcessing is true.
        abstract cameraExposure: float with get, set
        /// The value of the contrast to apply to the scene.
        /// 1.6 by default if setupImageProcessing is true.
        abstract cameraContrast: float with get, set
        /// Specifies wether or not tonemapping should be enabled in the scene.
        /// true by default if setupImageProcessing is true.
        abstract toneMappingEnabled: bool with get, set

    /// The Environment helper class can be used to add a fully featuread none expensive background to your scene.
    /// It includes by default a skybox and a ground relying on the BackgroundMaterial.
    /// It also helps with the default setup of your imageProcessing configuration.
    type [<AllowNullLiteral>] EnvironmentHelper =
        /// Default ground texture URL.
        abstract _groundTextureCDNUrl: obj with get, set
        /// Default skybox texture URL.
        abstract _skyboxTextureCDNUrl: obj with get, set
        /// Default environment texture URL.
        abstract _environmentTextureCDNUrl: obj with get, set
        abstract _rootMesh: obj with get, set
        /// Gets the root mesh created by the helper.
        abstract rootMesh: Mesh
        abstract _skybox: obj with get, set
        /// Gets the skybox created by the helper.
        abstract skybox: Nullable<Mesh>
        abstract _skyboxTexture: obj with get, set
        /// Gets the skybox texture created by the helper.
        abstract skyboxTexture: Nullable<BaseTexture>
        abstract _skyboxMaterial: obj with get, set
        /// Gets the skybox material created by the helper.
        abstract skyboxMaterial: Nullable<BackgroundMaterial>
        abstract _ground: obj with get, set
        /// Gets the ground mesh created by the helper.
        abstract ground: Nullable<Mesh>
        abstract _groundTexture: obj with get, set
        /// Gets the ground texture created by the helper.
        abstract groundTexture: Nullable<BaseTexture>
        abstract _groundMirror: obj with get, set
        /// Gets the ground mirror created by the helper.
        abstract groundMirror: Nullable<MirrorTexture>
        /// Gets the ground mirror render list to helps pushing the meshes
        /// you wish in the ground reflection.
        abstract groundMirrorRenderList: Nullable<ResizeArray<AbstractMesh>>
        abstract _groundMaterial: obj with get, set
        /// Gets the ground material created by the helper.
        abstract groundMaterial: Nullable<BackgroundMaterial>
        /// Stores the creation options.
        abstract _scene: obj
        abstract _options: obj with get, set
        /// This observable will be notified with any error during the creation of the environment,
        /// mainly texture creation errors.
        abstract onErrorObservable: Observable<obj> with get, set
        /// <summary>Updates the background according to the new options</summary>
        /// <param name="options"></param>
        abstract updateOptions: options: obj -> unit
        /// <summary>Sets the primary color of all the available elements.</summary>
        /// <param name="color">the main color to affect to the ground and the background</param>
        /// <param name="perceptual">Specifies wether the chosen color has been set as intented to be seen e.g. in gamma space not accounting for exposure and tone mapping</param>
        abstract setMainColor: color: Color3 * ?perceptual: bool -> unit
        /// Setup the image processing according to the specified options.
        abstract _setupImageProcessing: unit -> unit
        /// Setup the environment texture according to the specified options.
        abstract _setupEnvironmentTexture: unit -> unit
        /// Setup the background according to the specified options.
        abstract _setupBackground: unit -> unit
        /// Get the scene sizes according to the setup.
        abstract _getSceneSize: unit -> unit
        /// Setup the ground according to the specified options.
        abstract _setupGround: sceneSize: obj -> unit
        /// Setup the ground material according to the specified options.
        abstract _setupGroundMaterial: unit -> unit
        /// Setup the ground diffuse texture according to the specified options.
        abstract _setupGroundDiffuseTexture: unit -> unit
        /// Setup the ground mirror texture according to the specified options.
        abstract _setupGroundMirrorTexture: sceneSize: obj -> unit
        /// Setup the ground to receive the mirror texture.
        abstract _setupMirrorInGroundMaterial: unit -> unit
        /// Setup the skybox according to the specified options.
        abstract _setupSkybox: sceneSize: obj -> unit
        /// Setup the skybox material according to the specified options.
        abstract _setupSkyboxMaterial: unit -> unit
        /// Setup the skybox reflection texture according to the specified options.
        abstract _setupSkyboxReflectionTexture: unit -> unit
        abstract _errorHandler: obj with get, set
        /// Dispose all the elements created by the Helper.
        abstract dispose: unit -> unit

    /// The Environment helper class can be used to add a fully featuread none expensive background to your scene.
    /// It includes by default a skybox and a ground relying on the BackgroundMaterial.
    /// It also helps with the default setup of your imageProcessing configuration.
    type [<AllowNullLiteral>] EnvironmentHelperStatic =
        /// Creates the default options for the helper.
        abstract _getDefaultOptions: unit -> unit
        /// <summary>constructor</summary>
        /// <param name="options"></param>
        /// <param name="scene">The scene to add the material to</param>
        [<Emit "new $0($1...)">] abstract Create: options: obj * scene: Scene -> EnvironmentHelper

    /// Display a 360 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
    /// As a subclass of Node, this allow parenting to the camera or multiple videos with different locations in the scene.
    /// This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
    /// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
    type [<AllowNullLiteral>] VideoDome =
        inherit Node
        /// The video texture being displayed on the sphere
        abstract _videoTexture: VideoTexture with get, set
        /// The skybox material
        abstract _material: BackgroundMaterial with get, set
        /// The surface used for the skybox
        abstract _mesh: Mesh with get, set
        /// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
        /// Also see the options.resolution property.
        abstract fovMultiplier: float with get, set
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// Display a 360 degree video on an approximately spherical surface, useful for VR applications or skyboxes.
    /// As a subclass of Node, this allow parenting to the camera or multiple videos with different locations in the scene.
    /// This class achieves its effect with a VideoTexture and a correctly configured BackgroundMaterial on an inverted sphere.
    /// Potential additions to this helper include zoom and and non-infinite distance rendering effects.
    type [<AllowNullLiteral>] VideoDomeStatic =
        /// <summary>Create an instance of this class and pass through the parameters to the relevant classes, VideoTexture, StandardMaterial, and Mesh.</summary>
        /// <param name="name">Element's name, child elements will append suffixes for their own names.</param>
        /// <param name="urlsOrVideo"></param>
        /// <param name="options">An object containing optional or exposed sub element properties:</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * urlsOrVideo: U3<string, ResizeArray<string>, HTMLVideoElement> * options: VideoDomeStaticOptions * scene: Scene -> VideoDome

    type [<AllowNullLiteral>] VideoDomeStaticOptions =
        abstract resolution: float option with get, set
        abstract clickToPlay: bool option with get, set
        abstract autoPlay: bool option with get, set
        abstract loop: bool option with get, set
        abstract size: float option with get, set

    type [<AllowNullLiteral>] StickValues =
        abstract x: float with get, set
        abstract y: float with get, set

    type [<AllowNullLiteral>] StickValuesStatic =
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float -> StickValues

    type [<AllowNullLiteral>] GamepadButtonChanges =
        abstract changed: bool with get, set
        abstract pressChanged: bool with get, set
        abstract touchChanged: bool with get, set
        abstract valueChanged: bool with get, set

    type [<AllowNullLiteral>] Gamepad =
        abstract id: string with get, set
        abstract index: float with get, set
        abstract browserGamepad: obj option with get, set
        abstract ``type``: float with get, set
        abstract _leftStick: obj with get, set
        abstract _rightStick: obj with get, set
        abstract _isConnected: bool with get, set
        abstract _leftStickAxisX: obj with get, set
        abstract _leftStickAxisY: obj with get, set
        abstract _rightStickAxisX: obj with get, set
        abstract _rightStickAxisY: obj with get, set
        abstract _onleftstickchanged: obj with get, set
        abstract _onrightstickchanged: obj with get, set
        abstract GAMEPAD: float with get, set
        abstract GENERIC: float with get, set
        abstract XBOX: float with get, set
        abstract POSE_ENABLED: float with get, set
        abstract _invertLeftStickY: bool with get, set
        abstract isConnected: bool
        abstract onleftstickchanged: callback: (StickValues -> unit) -> unit
        abstract onrightstickchanged: callback: (StickValues -> unit) -> unit
        abstract leftStick: StickValues with get, set
        abstract rightStick: StickValues with get, set
        abstract update: unit -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] GamepadStatic =
        [<Emit "new $0($1...)">] abstract Create: id: string * index: float * browserGamepad: obj option * ?leftStickX: float * ?leftStickY: float * ?rightStickX: float * ?rightStickY: float -> Gamepad

    type [<AllowNullLiteral>] GenericPad =
        inherit Gamepad
        abstract _buttons: obj with get, set
        abstract _onbuttondown: obj with get, set
        abstract _onbuttonup: obj with get, set
        abstract onButtonDownObservable: Observable<float> with get, set
        abstract onButtonUpObservable: Observable<float> with get, set
        abstract onbuttondown: callback: (float -> unit) -> unit
        abstract onbuttonup: callback: (float -> unit) -> unit
        abstract _setButtonValue: newValue: obj * currentValue: obj * buttonIndex: obj -> unit
        abstract update: unit -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] GenericPadStatic =
        [<Emit "new $0($1...)">] abstract Create: id: string * index: float * browserGamepad: obj option -> GenericPad

    type [<AllowNullLiteral>] GamepadManager =
        abstract _scene: obj with get, set
        abstract _babylonGamepads: obj with get, set
        abstract _oneGamepadConnected: obj with get, set
        abstract _isMonitoring: bool with get, set
        abstract _gamepadEventSupported: obj with get, set
        abstract _gamepadSupport: obj with get, set
        abstract onGamepadConnectedObservable: Observable<Gamepad> with get, set
        abstract onGamepadDisconnectedObservable: Observable<Gamepad> with get, set
        abstract _onGamepadConnectedEvent: obj with get, set
        abstract _onGamepadDisconnectedEvent: obj with get, set
        abstract gamepads: ResizeArray<Gamepad>
        abstract getGamepadByType: ?``type``: float -> Nullable<Gamepad>
        abstract dispose: unit -> unit
        abstract _addNewGamepad: gamepad: obj -> unit
        abstract _startMonitoringGamepads: unit -> unit
        abstract _stopMonitoringGamepads: unit -> unit
        abstract _checkGamepadsStatus: unit -> unit
        abstract _updateGamepadObjects: unit -> unit

    type [<AllowNullLiteral>] GamepadManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: ?_scene: Scene option -> GamepadManager

    type [<RequireQualifiedAccess>] Xbox360Button =
        | A = 0
        | B = 1
        | X = 2
        | Y = 3
        | Start = 4
        | Back = 5
        | LB = 6
        | RB = 7
        | LeftStick = 8
        | RightStick = 9

    type [<RequireQualifiedAccess>] Xbox360Dpad =
        | Up = 0
        | Down = 1
        | Left = 2
        | Right = 3

    type [<AllowNullLiteral>] Xbox360Pad =
        inherit Gamepad
        abstract _leftTrigger: obj with get, set
        abstract _rightTrigger: obj with get, set
        abstract _onlefttriggerchanged: obj with get, set
        abstract _onrighttriggerchanged: obj with get, set
        abstract _onbuttondown: obj with get, set
        abstract _onbuttonup: obj with get, set
        abstract _ondpaddown: obj with get, set
        abstract _ondpadup: obj with get, set
        abstract onButtonDownObservable: Observable<Xbox360Button> with get, set
        abstract onButtonUpObservable: Observable<Xbox360Button> with get, set
        abstract onPadDownObservable: Observable<Xbox360Dpad> with get, set
        abstract onPadUpObservable: Observable<Xbox360Dpad> with get, set
        abstract _buttonA: obj with get, set
        abstract _buttonB: obj with get, set
        abstract _buttonX: obj with get, set
        abstract _buttonY: obj with get, set
        abstract _buttonBack: obj with get, set
        abstract _buttonStart: obj with get, set
        abstract _buttonLB: obj with get, set
        abstract _buttonRB: obj with get, set
        abstract _buttonLeftStick: obj with get, set
        abstract _buttonRightStick: obj with get, set
        abstract _dPadUp: obj with get, set
        abstract _dPadDown: obj with get, set
        abstract _dPadLeft: obj with get, set
        abstract _dPadRight: obj with get, set
        abstract _isXboxOnePad: obj with get, set
        abstract onlefttriggerchanged: callback: (float -> unit) -> unit
        abstract onrighttriggerchanged: callback: (float -> unit) -> unit
        abstract leftTrigger: float with get, set
        abstract rightTrigger: float with get, set
        abstract onbuttondown: callback: (Xbox360Button -> unit) -> unit
        abstract onbuttonup: callback: (Xbox360Button -> unit) -> unit
        abstract ondpaddown: callback: (Xbox360Dpad -> unit) -> unit
        abstract ondpadup: callback: (Xbox360Dpad -> unit) -> unit
        abstract _setButtonValue: newValue: obj * currentValue: obj * buttonType: obj -> unit
        abstract _setDPadValue: newValue: obj * currentValue: obj * buttonType: obj -> unit
        abstract buttonA: float with get, set
        abstract buttonB: float with get, set
        abstract buttonX: float with get, set
        abstract buttonY: float with get, set
        abstract buttonStart: float with get, set
        abstract buttonBack: float with get, set
        abstract buttonLB: float with get, set
        abstract buttonRB: float with get, set
        abstract buttonLeftStick: float with get, set
        abstract buttonRightStick: float with get, set
        abstract dPadUp: float with get, set
        abstract dPadDown: float with get, set
        abstract dPadLeft: float with get, set
        abstract dPadRight: float with get, set
        abstract update: unit -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] Xbox360PadStatic =
        [<Emit "new $0($1...)">] abstract Create: id: string * index: float * gamepad: obj option * ?xboxOne: bool -> Xbox360Pad

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] EngineInstrumentation =
        inherit IDisposable
        abstract engine: Engine with get, set
        abstract _captureGPUFrameTime: obj with get, set
        abstract _gpuFrameTimeToken: obj with get, set
        abstract _gpuFrameTime: obj with get, set
        abstract _captureShaderCompilationTime: obj with get, set
        abstract _shaderCompilationTime: obj with get, set
        abstract _onBeginFrameObserver: obj with get, set
        abstract _onEndFrameObserver: obj with get, set
        abstract _onBeforeShaderCompilationObserver: obj with get, set
        abstract _onAfterShaderCompilationObserver: obj with get, set
        /// Gets the perf counter used for GPU frame time
        abstract gpuFrameTimeCounter: PerfCounter
        /// Gets the GPU frame time capture status
        /// Enable or disable the GPU frame time capture
        abstract captureGPUFrameTime: bool with get, set
        /// Gets the perf counter used for shader compilation time
        abstract shaderCompilationTimeCounter: PerfCounter
        /// Gets the shader compilation time capture status
        /// Enable or disable the shader compilation time capture
        abstract captureShaderCompilationTime: bool with get, set
        abstract dispose: unit -> unit

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] EngineInstrumentationStatic =
        [<Emit "new $0($1...)">] abstract Create: engine: Engine -> EngineInstrumentation

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] SceneInstrumentation =
        inherit IDisposable
        abstract scene: Scene with get, set
        abstract _captureActiveMeshesEvaluationTime: obj with get, set
        abstract _activeMeshesEvaluationTime: obj with get, set
        abstract _captureRenderTargetsRenderTime: obj with get, set
        abstract _renderTargetsRenderTime: obj with get, set
        abstract _captureFrameTime: obj with get, set
        abstract _frameTime: obj with get, set
        abstract _captureRenderTime: obj with get, set
        abstract _renderTime: obj with get, set
        abstract _captureInterFrameTime: obj with get, set
        abstract _interFrameTime: obj with get, set
        abstract _captureParticlesRenderTime: obj with get, set
        abstract _particlesRenderTime: obj with get, set
        abstract _captureSpritesRenderTime: obj with get, set
        abstract _spritesRenderTime: obj with get, set
        abstract _capturePhysicsTime: obj with get, set
        abstract _physicsTime: obj with get, set
        abstract _captureAnimationsTime: obj with get, set
        abstract _animationsTime: obj with get, set
        abstract _onBeforeActiveMeshesEvaluationObserver: obj with get, set
        abstract _onAfterActiveMeshesEvaluationObserver: obj with get, set
        abstract _onBeforeRenderTargetsRenderObserver: obj with get, set
        abstract _onAfterRenderTargetsRenderObserver: obj with get, set
        abstract _onAfterRenderObserver: obj with get, set
        abstract _onBeforeDrawPhaseObserver: obj with get, set
        abstract _onAfterDrawPhaseObserver: obj with get, set
        abstract _onBeforeAnimationsObserver: obj with get, set
        abstract _onBeforeParticlesRenderingObserver: obj with get, set
        abstract _onAfterParticlesRenderingObserver: obj with get, set
        abstract _onBeforeSpritesRenderingObserver: obj with get, set
        abstract _onAfterSpritesRenderingObserver: obj with get, set
        abstract _onBeforePhysicsObserver: obj with get, set
        abstract _onAfterPhysicsObserver: obj with get, set
        abstract _onAfterAnimationsObserver: obj with get, set
        /// Gets the perf counter used for active meshes evaluation time
        abstract activeMeshesEvaluationTimeCounter: PerfCounter
        /// Gets the active meshes evaluation time capture status
        /// Enable or disable the active meshes evaluation time capture
        abstract captureActiveMeshesEvaluationTime: bool with get, set
        /// Gets the perf counter used for render targets render time
        abstract renderTargetsRenderTimeCounter: PerfCounter
        /// Gets the render targets render time capture status
        /// Enable or disable the render targets render time capture
        abstract captureRenderTargetsRenderTime: bool with get, set
        /// Gets the perf counter used for particles render time
        abstract particlesRenderTimeCounter: PerfCounter
        /// Gets the particles render time capture status
        /// Enable or disable the particles render time capture
        abstract captureParticlesRenderTime: bool with get, set
        /// Gets the perf counter used for sprites render time
        abstract spritesRenderTimeCounter: PerfCounter
        /// Gets the sprites render time capture status
        /// Enable or disable the sprites render time capture
        abstract captureSpritesRenderTime: bool with get, set
        /// Gets the perf counter used for physics time
        abstract physicsTimeCounter: PerfCounter
        /// Gets the physics time capture status
        /// Enable or disable the physics time capture
        abstract capturePhysicsTime: bool with get, set
        /// Gets the perf counter used for animations time
        abstract animationsTimeCounter: PerfCounter
        /// Gets the animations time capture status
        /// Enable or disable the animations time capture
        abstract captureAnimationsTime: bool with get, set
        /// Gets the perf counter used for frame time capture
        abstract frameTimeCounter: PerfCounter
        /// Gets the frame time capture status
        /// Enable or disable the frame time capture
        abstract captureFrameTime: bool with get, set
        /// Gets the perf counter used for inter-frames time capture
        abstract interFrameTimeCounter: PerfCounter
        /// Gets the inter-frames time capture status
        /// Enable or disable the inter-frames time capture
        abstract captureInterFrameTime: bool with get, set
        /// Gets the perf counter used for render time capture
        abstract renderTimeCounter: PerfCounter
        /// Gets the render time capture status
        /// Enable or disable the render time capture
        abstract captureRenderTime: bool with get, set
        /// Gets the perf counter used for draw calls
        abstract drawCallsCounter: PerfCounter
        /// Gets the perf counter used for texture collisions
        abstract textureCollisionsCounter: PerfCounter
        abstract dispose: unit -> unit

    /// This class can be used to get instrumentation data from a Babylon engine
    type [<AllowNullLiteral>] SceneInstrumentationStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> SceneInstrumentation

    type [<AllowNullLiteral>] _TimeToken =
        abstract _startTimeQuery: Nullable<WebGLQuery> with get, set
        abstract _endTimeQuery: Nullable<WebGLQuery> with get, set
        abstract _timeElapsedQuery: Nullable<WebGLQuery> with get, set
        abstract _timeElapsedQueryEnded: bool with get, set

    type [<AllowNullLiteral>] _TimeTokenStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _TimeToken

    /// Effect layer options. This helps customizing the behaviour
    /// of the effect layer.
    type [<AllowNullLiteral>] IEffectLayerOptions =
        /// Multiplication factor apply to the canvas size to compute the render target size
        /// used to generated the objects (the smaller the faster).
        abstract mainTextureRatio: float with get, set
        /// Enforces a fixed size texture to ensure effect stability across devices.
        abstract mainTextureFixedSize: float option with get, set
        /// Alpha blending mode used to apply the blur. Default depends of the implementation.
        abstract alphaBlendingMode: float with get, set
        /// The camera attached to the layer.
        abstract camera: Nullable<Camera> with get, set

    /// The effect layer Helps adding post process effect blended with the main pass.
    /// 
    /// This can be for instance use to generate glow or higlight effects on the scene.
    /// 
    /// The effect layer class can not be used directly and is intented to inherited from to be
    /// customized per effects.
    type [<AllowNullLiteral>] EffectLayer =
        abstract _vertexBuffers: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _cachedDefines: obj with get, set
        abstract _effectLayerMapGenerationEffect: obj with get, set
        abstract _effectLayerOptions: obj with get, set
        abstract _mergeEffect: obj with get, set
        abstract _scene: Scene with get, set
        abstract _engine: Engine with get, set
        abstract _maxSize: float with get, set
        abstract _mainTextureDesiredSize: ISize with get, set
        abstract _mainTexture: RenderTargetTexture with get, set
        abstract _shouldRender: bool with get, set
        abstract _postProcesses: ResizeArray<PostProcess> with get, set
        abstract _textures: ResizeArray<BaseTexture> with get, set
        abstract _emissiveTextureAndColor: obj with get, set
        /// The name of the layer
        abstract name: string with get, set
        /// The clear color of the texture used to generate the glow map.
        abstract neutralColor: Color4 with get, set
        /// Specifies wether the highlight layer is enabled or not.
        abstract isEnabled: bool with get, set
        /// Gets the camera attached to the layer.
        abstract camera: Nullable<Camera>
        /// An event triggered when the effect layer has been disposed.
        abstract onDisposeObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the effect layer is about rendering the main texture with the glowy parts.
        abstract onBeforeRenderMainTextureObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the generated texture is being merged in the scene.
        abstract onBeforeComposeObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the generated texture has been merged in the scene.
        abstract onAfterComposeObservable: Observable<EffectLayer> with get, set
        /// An event triggered when the efffect layer changes its size.
        abstract onSizeChangedObservable: Observable<EffectLayer> with get, set
        /// Get the effect name of the layer.
        abstract getEffectName: unit -> string
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
        abstract needStencil: unit -> bool
        /// Create the merge effect. This is the shader use to blit the information back
        /// to the main canvas at the end of the scene rendering.
        abstract _createMergeEffect: unit -> Effect
        /// Creates the render target textures and post processes used in the effect layer.
        abstract _createTextureAndPostProcesses: unit -> unit
        /// <summary>Implementation specific of rendering the generating effect on the main canvas.</summary>
        /// <param name="effect">The effect used to render through</param>
        abstract _internalRender: effect: Effect -> unit
        /// Sets the required values for both the emissive texture and and the main color.
        abstract _setEmissiveTextureAndColor: mesh: Mesh * subMesh: SubMesh * material: Material -> unit
        /// <summary>Free any resources and references associated to a mesh.
        /// Internal use</summary>
        /// <param name="mesh">The mesh to free.</param>
        abstract _disposeMesh: mesh: Mesh -> unit
        /// Serializes this layer (Glow or Highlight for example)
        abstract serialize: unit -> obj option
        /// <summary>Initializes the effect layer with the required options.</summary>
        /// <param name="options">Sets of none mandatory options to use with the layer (see IEffectLayerOptions for more information)</param>
        abstract _init: options: obj -> unit
        /// Generates the index buffer of the full screen quad blending to the main canvas.
        abstract _generateIndexBuffer: unit -> unit
        /// Generates the vertex buffer of the full screen quad blending to the main canvas.
        abstract _genrateVertexBuffer: unit -> unit
        /// Sets the main texture desired size which is the closest power of two
        /// of the engine canvas size.
        abstract _setMainTextureSize: unit -> unit
        /// Creates the main texture for the effect layer.
        abstract _createMainTexture: unit -> unit
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        /// <param name="emissiveTexture">the associated emissive texture used to generate the glow</param>
        abstract _isReady: subMesh: SubMesh * useInstances: bool * emissiveTexture: Nullable<BaseTexture> -> bool
        /// Renders the glowing part of the scene by blending the blurred glowing meshes on top of the rendered scene.
        abstract render: unit -> unit
        /// <summary>Determine if a given mesh will be used in the current effect.</summary>
        /// <param name="mesh">mesh to test</param>
        abstract hasMesh: mesh: AbstractMesh -> bool
        /// Returns true if the layer contains information to display, otherwise false.
        abstract shouldRender: unit -> bool
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderMesh: mesh: Mesh -> bool
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderEmissiveTextureForMesh: mesh: Mesh -> bool
        /// Renders the submesh passed in parameter to the generation map.
        abstract _renderSubMesh: subMesh: SubMesh -> unit
        /// Rebuild the required buffers.
        abstract _rebuild: unit -> unit
        /// Dispose only the render target textures and post process.
        abstract _disposeTextureAndPostProcesses: unit -> unit
        /// Dispose the highlight layer and free resources.
        abstract dispose: unit -> unit
        /// Gets the class name of the effect layer
        abstract getClassName: unit -> string

    /// The effect layer Helps adding post process effect blended with the main pass.
    /// 
    /// This can be for instance use to generate glow or higlight effects on the scene.
    /// 
    /// The effect layer class can not be used directly and is intented to inherited from to be
    /// customized per effects.
    type [<AllowNullLiteral>] EffectLayerStatic =
        /// <summary>Instantiates a new effect Layer and references it in the scene.</summary>
        /// <param name="name">The name of the layer</param>
        /// <param name="scene">The scene to use the layer in</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> EffectLayer
        /// <summary>Creates an effect layer from parsed effect layer data</summary>
        /// <param name="parsedEffectLayer">defines effect layer data</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="rootUrl">defines the root URL containing the effect layer information</param>
        abstract Parse: parsedEffectLayer: obj option * scene: Scene * rootUrl: string -> EffectLayer

    /// Glow layer options. This helps customizing the behaviour
    /// of the glow layer.
    type [<AllowNullLiteral>] IGlowLayerOptions =
        /// Multiplication factor apply to the canvas size to compute the render target size
        /// used to generated the glowing objects (the smaller the faster).
        abstract mainTextureRatio: float with get, set
        /// Enforces a fixed size texture to ensure resize independant blur.
        abstract mainTextureFixedSize: float option with get, set
        /// How big is the kernel of the blur texture.
        abstract blurKernelSize: float with get, set
        /// The camera attached to the layer.
        abstract camera: Nullable<Camera> with get, set
        /// Enable MSAA by chosing the number of samples.
        abstract mainTextureSamples: float option with get, set

    /// The glow layer Helps adding a glow effect around the emissive parts of a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// Documentation: https://doc.babylonjs.com/how_to/glow_layer
    type [<AllowNullLiteral>] GlowLayer =
        inherit EffectLayer
        /// Effect Name of the layer.
        abstract EffectName: string
        /// The default blur kernel size used for the glow.
        abstract DefaultBlurKernelSize: float with get, set
        /// The default texture size ratio used for the glow.
        abstract DefaultTextureRatio: float with get, set
        /// Gets the kernel size of the blur.
        /// Sets the kernel size of the blur.
        abstract blurKernelSize: float with get, set
        /// Gets the glow intensity.
        /// Sets the glow intensity.
        abstract intensity: float with get, set
        abstract _options: obj with get, set
        abstract _intensity: obj with get, set
        abstract _horizontalBlurPostprocess1: obj with get, set
        abstract _verticalBlurPostprocess1: obj with get, set
        abstract _horizontalBlurPostprocess2: obj with get, set
        abstract _verticalBlurPostprocess2: obj with get, set
        abstract _blurTexture1: obj with get, set
        abstract _blurTexture2: obj with get, set
        abstract _postProcesses1: obj with get, set
        abstract _postProcesses2: obj with get, set
        abstract _includedOnlyMeshes: obj with get, set
        abstract _excludedMeshes: obj with get, set
        /// Callback used to let the user override the color selection on a per mesh basis
        abstract customEmissiveColorSelector: (Mesh -> SubMesh -> Material -> Color4 -> unit) with get, set
        /// Callback used to let the user override the texture selection on a per mesh basis
        abstract customEmissiveTextureSelector: (Mesh -> SubMesh -> Material -> Texture) with get, set
        /// Get the effect name of the layer.
        abstract getEffectName: unit -> string
        /// Create the merge effect. This is the shader use to blit the information back
        /// to the main canvas at the end of the scene rendering.
        abstract _createMergeEffect: unit -> Effect
        /// Creates the render target textures and post processes used in the glow layer.
        abstract _createTextureAndPostProcesses: unit -> unit
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
        abstract needStencil: unit -> bool
        /// <summary>Implementation specific of rendering the generating effect on the main canvas.</summary>
        /// <param name="effect">The effect used to render through</param>
        abstract _internalRender: effect: Effect -> unit
        /// Sets the required values for both the emissive texture and and the main color.
        abstract _setEmissiveTextureAndColor: mesh: Mesh * subMesh: SubMesh * material: Material -> unit
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderMesh: mesh: Mesh -> bool
        /// <summary>Add a mesh in the exclusion list to prevent it to impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to exclude from the glow layer</param>
        abstract addExcludedMesh: mesh: Mesh -> unit
        /// <summary>Remove a mesh from the exclusion list to let it impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to remove</param>
        abstract removeExcludedMesh: mesh: Mesh -> unit
        /// <summary>Add a mesh in the inclusion list to impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to include in the glow layer</param>
        abstract addIncludedOnlyMesh: mesh: Mesh -> unit
        /// <summary>Remove a mesh from the Inclusion list to prevent it to impact or being impacted by the glow layer.</summary>
        /// <param name="mesh">The mesh to remove</param>
        abstract removeIncludedOnlyMesh: mesh: Mesh -> unit
        /// <summary>Determine if a given mesh will be used in the glow layer</summary>
        /// <param name="mesh">The mesh to test</param>
        abstract hasMesh: mesh: AbstractMesh -> bool
        /// <summary>Free any resources and references associated to a mesh.
        /// Internal use</summary>
        /// <param name="mesh">The mesh to free.</param>
        abstract _disposeMesh: mesh: Mesh -> unit
        /// Gets the class name of the effect layer
        abstract getClassName: unit -> string
        /// Serializes this glow layer
        abstract serialize: unit -> obj option

    /// The glow layer Helps adding a glow effect around the emissive parts of a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// Documentation: https://doc.babylonjs.com/how_to/glow_layer
    type [<AllowNullLiteral>] GlowLayerStatic =
        /// <summary>Instantiates a new glow Layer and references it to the scene.</summary>
        /// <param name="name">The name of the layer</param>
        /// <param name="scene">The scene to use the layer in</param>
        /// <param name="options">Sets of none mandatory options to use with the layer (see IGlowLayerOptions for more information)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?options: obj -> GlowLayer
        /// <summary>Creates a Glow Layer from parsed glow layer data</summary>
        /// <param name="parsedGlowLayer">defines glow layer data</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="rootUrl">defines the root URL containing the glow layer information</param>
        abstract Parse: parsedGlowLayer: obj option * scene: Scene * rootUrl: string -> GlowLayer

    /// Highlight layer options. This helps customizing the behaviour
    /// of the highlight layer.
    type [<AllowNullLiteral>] IHighlightLayerOptions =
        /// Multiplication factor apply to the canvas size to compute the render target size
        /// used to generated the glowing objects (the smaller the faster).
        abstract mainTextureRatio: float with get, set
        /// Enforces a fixed size texture to ensure resize independant blur.
        abstract mainTextureFixedSize: float option with get, set
        /// Multiplication factor apply to the main texture size in the first step of the blur to reduce the size
        /// of the picture to blur (the smaller the faster).
        abstract blurTextureSizeRatio: float with get, set
        /// How big in texel of the blur texture is the vertical blur.
        abstract blurVerticalSize: float with get, set
        /// How big in texel of the blur texture is the horizontal blur.
        abstract blurHorizontalSize: float with get, set
        /// Alpha blending mode used to apply the blur. Default is combine.
        abstract alphaBlendingMode: float with get, set
        /// The camera attached to the layer.
        abstract camera: Nullable<Camera> with get, set
        /// Should we display highlight as a solid stroke?
        abstract isStroke: bool option with get, set

    /// The highlight layer Helps adding a glow effect around a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
    type [<AllowNullLiteral>] HighlightLayer =
        inherit EffectLayer
        abstract name: string with get, set
        /// Effect Name of the highlight layer.
        abstract EffectName: string
        /// The neutral color used during the preparation of the glow effect.
        /// This is black by default as the blend operation is a blend operation.
        abstract NeutralColor: Color4 with get, set
        /// Stencil value used for glowing meshes.
        abstract GlowingMeshStencilReference: float with get, set
        /// Stencil value used for the other meshes in the scene.
        abstract NormalMeshStencilReference: float with get, set
        /// Specifies whether or not the inner glow is ACTIVE in the layer.
        abstract innerGlow: bool with get, set
        /// Specifies whether or not the outer glow is ACTIVE in the layer.
        abstract outerGlow: bool with get, set
        /// Gets the horizontal size of the blur.
        /// Specifies the horizontal size of the blur.
        abstract blurHorizontalSize: float with get, set
        /// Gets the vertical size of the blur.
        /// Specifies the vertical size of the blur.
        abstract blurVerticalSize: float with get, set
        /// An event triggered when the highlight layer is being blurred.
        abstract onBeforeBlurObservable: Observable<HighlightLayer> with get, set
        /// An event triggered when the highlight layer has been blurred.
        abstract onAfterBlurObservable: Observable<HighlightLayer> with get, set
        abstract _instanceGlowingMeshStencilReference: obj with get, set
        abstract _options: obj with get, set
        abstract _downSamplePostprocess: obj with get, set
        abstract _horizontalBlurPostprocess: obj with get, set
        abstract _verticalBlurPostprocess: obj with get, set
        abstract _blurTexture: obj with get, set
        abstract _meshes: obj with get, set
        abstract _excludedMeshes: obj with get, set
        /// Get the effect name of the layer.
        abstract getEffectName: unit -> string
        /// Create the merge effect. This is the shader use to blit the information back
        /// to the main canvas at the end of the scene rendering.
        abstract _createMergeEffect: unit -> Effect
        /// Creates the render target textures and post processes used in the highlight layer.
        abstract _createTextureAndPostProcesses: unit -> unit
        /// Returns wether or nood the layer needs stencil enabled during the mesh rendering.
        abstract needStencil: unit -> bool
        /// <summary>Checks for the readiness of the element composing the layer.</summary>
        /// <param name="subMesh">the mesh to check for</param>
        /// <param name="useInstances">specify wether or not to use instances to render the mesh</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// <summary>Implementation specific of rendering the generating effect on the main canvas.</summary>
        /// <param name="effect">The effect used to render through</param>
        abstract _internalRender: effect: Effect -> unit
        /// Returns true if the layer contains information to display, otherwise false.
        abstract shouldRender: unit -> bool
        /// <summary>Returns true if the mesh should render, otherwise false.</summary>
        /// <param name="mesh">The mesh to render</param>
        abstract _shouldRenderMesh: mesh: Mesh -> bool
        /// Sets the required values for both the emissive texture and and the main color.
        abstract _setEmissiveTextureAndColor: mesh: Mesh * subMesh: SubMesh * material: Material -> unit
        /// <summary>Add a mesh in the exclusion list to prevent it to impact or being impacted by the highlight layer.</summary>
        /// <param name="mesh">The mesh to exclude from the highlight layer</param>
        abstract addExcludedMesh: mesh: Mesh -> unit
        /// <summary>Remove a mesh from the exclusion list to let it impact or being impacted by the highlight layer.</summary>
        /// <param name="mesh">The mesh to highlight</param>
        abstract removeExcludedMesh: mesh: Mesh -> unit
        /// <summary>Determine if a given mesh will be highlighted by the current HighlightLayer</summary>
        /// <param name="mesh">mesh to test</param>
        abstract hasMesh: mesh: AbstractMesh -> bool
        /// <summary>Add a mesh in the highlight layer in order to make it glow with the chosen color.</summary>
        /// <param name="mesh">The mesh to highlight</param>
        /// <param name="color">The color of the highlight</param>
        /// <param name="glowEmissiveOnly">Extract the glow from the emissive texture</param>
        abstract addMesh: mesh: Mesh * color: Color3 * ?glowEmissiveOnly: bool -> unit
        /// <summary>Remove a mesh from the highlight layer in order to make it stop glowing.</summary>
        /// <param name="mesh">The mesh to highlight</param>
        abstract removeMesh: mesh: Mesh -> unit
        /// Force the stencil to the normal expected value for none glowing parts
        abstract _defaultStencilReference: mesh: obj -> unit
        /// <summary>Free any resources and references associated to a mesh.
        /// Internal use</summary>
        /// <param name="mesh">The mesh to free.</param>
        abstract _disposeMesh: mesh: Mesh -> unit
        /// Dispose the highlight layer and free resources.
        abstract dispose: unit -> unit
        /// Gets the class name of the effect layer
        abstract getClassName: unit -> string
        /// Serializes this Highlight layer
        abstract serialize: unit -> obj option

    /// The highlight layer Helps adding a glow effect around a mesh.
    /// 
    /// Once instantiated in a scene, simply use the pushMesh or removeMesh method to add or remove
    /// glowy meshes to your scene.
    /// 
    /// !!! THIS REQUIRES AN ACTIVE STENCIL BUFFER ON THE CANVAS !!!
    type [<AllowNullLiteral>] HighlightLayerStatic =
        /// <summary>Instantiates a new highlight Layer and references it to the scene..</summary>
        /// <param name="name">The name of the layer</param>
        /// <param name="scene">The scene to use the layer in</param>
        /// <param name="options">Sets of none mandatory options to use with the layer (see IHighlightLayerOptions for more information)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?options: obj -> HighlightLayer
        /// <summary>Creates a Highlight layer from parsed Highlight layer data</summary>
        /// <param name="parsedHightlightLayer">defines the Highlight layer data</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="rootUrl">defines the root URL containing the Highlight layer information</param>
        abstract Parse: parsedHightlightLayer: obj option * scene: Scene * rootUrl: string -> HighlightLayer

    type [<AllowNullLiteral>] Layer =
        abstract name: string with get, set
        abstract texture: Nullable<Texture> with get, set
        abstract isBackground: bool with get, set
        abstract color: Color4 with get, set
        abstract scale: Vector2 with get, set
        abstract offset: Vector2 with get, set
        abstract alphaBlendingMode: float with get, set
        abstract alphaTest: bool with get, set
        abstract layerMask: float with get, set
        abstract _scene: obj with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _effect: obj with get, set
        abstract _alphaTestEffect: obj with get, set
        /// An event triggered when the layer is disposed.
        abstract onDisposeObservable: Observable<Layer> with get, set
        abstract _onDisposeObserver: obj with get, set
        abstract onDispose: (unit -> unit) with get, set
        /// An event triggered before rendering the scene
        abstract onBeforeRenderObservable: Observable<Layer> with get, set
        abstract _onBeforeRenderObserver: obj with get, set
        abstract onBeforeRender: (unit -> unit) with get, set
        /// An event triggered after rendering the scene
        abstract onAfterRenderObservable: Observable<Layer> with get, set
        abstract _onAfterRenderObserver: obj with get, set
        abstract onAfterRender: (unit -> unit) with get, set
        abstract _createIndexBuffer: unit -> unit
        abstract _rebuild: unit -> unit
        abstract render: unit -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] LayerStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * imgUrl: Nullable<string> * scene: Nullable<Scene> * ?isBackground: bool * ?color: Color4 -> Layer

    type [<AllowNullLiteral>] ILoadingScreen =
        abstract displayLoadingUI: (unit -> unit) with get, set
        abstract hideLoadingUI: (unit -> unit) with get, set
        abstract loadingUIBackgroundColor: string with get, set
        abstract loadingUIText: string with get, set

    type [<AllowNullLiteral>] DefaultLoadingScreen =
        inherit ILoadingScreen
        abstract _renderingCanvas: obj with get, set
        abstract _loadingText: obj with get, set
        abstract _loadingDivBackgroundColor: obj with get, set
        abstract _loadingDiv: obj with get, set
        abstract _loadingTextDiv: obj with get, set
        abstract displayLoadingUI: unit -> unit
        abstract hideLoadingUI: unit -> unit
        abstract loadingUIText: string with get, set
        abstract loadingUIBackgroundColor: string with get, set
        abstract _resizeLoadingUI: obj with get, set

    type [<AllowNullLiteral>] DefaultLoadingScreenStatic =
        [<Emit "new $0($1...)">] abstract Create: _renderingCanvas: HTMLCanvasElement * ?_loadingText: string * ?_loadingDivBackgroundColor: string -> DefaultLoadingScreen

    type [<AllowNullLiteral>] SceneLoaderProgressEvent =
        abstract lengthComputable: bool
        abstract loaded: float
        abstract total: float

    type [<AllowNullLiteral>] SceneLoaderProgressEventStatic =
        [<Emit "new $0($1...)">] abstract Create: lengthComputable: bool * loaded: float * total: float -> SceneLoaderProgressEvent
        abstract FromProgressEvent: ``event``: ProgressEvent -> SceneLoaderProgressEvent

    type [<AllowNullLiteral>] ISceneLoaderPluginExtensions =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: extension: string -> obj with get, set

    type [<AllowNullLiteral>] ISceneLoaderPluginFactory =
        abstract name: string with get, set
        abstract createPlugin: unit -> U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>
        abstract canDirectLoad: (string -> bool) option with get, set

    type [<AllowNullLiteral>] ISceneLoaderPlugin =
        /// The friendly name of this plugin.
        abstract name: string with get, set
        /// The file extensions supported by this plugin.
        abstract extensions: U2<string, ISceneLoaderPluginExtensions> with get, set
        /// <summary>Import meshes into a scene.</summary>
        /// <param name="meshesNames">An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="scene">The scene to import into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="meshes">The meshes array to import into</param>
        /// <param name="particleSystems">The particle systems array to import into</param>
        /// <param name="skeletons">The skeletons array to import into</param>
        /// <param name="onError">The callback when import fails</param>
        abstract importMesh: meshesNames: obj option * scene: Scene * data: obj option * rootUrl: string * meshes: ResizeArray<AbstractMesh> * particleSystems: ResizeArray<ParticleSystem> * skeletons: ResizeArray<Skeleton> * ?onError: (string -> obj option -> unit) -> bool
        /// <summary>Load into a scene.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onError">The callback when import fails</param>
        abstract load: scene: Scene * data: string * rootUrl: string * ?onError: (string -> obj option -> unit) -> bool
        /// The callback that returns true if the data can be directly loaded.
        abstract canDirectLoad: (string -> bool) option with get, set
        /// The callback that allows custom handling of the root url based on the response url.
        abstract rewriteRootURL: (string -> string -> string) option with get, set
        /// <summary>Load into an asset container.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onError">The callback when import fails</param>
        abstract loadAssetContainer: scene: Scene * data: string * rootUrl: string * ?onError: (string -> obj option -> unit) -> AssetContainer

    type [<AllowNullLiteral>] ISceneLoaderPluginAsync =
        /// The friendly name of this plugin.
        abstract name: string with get, set
        /// The file extensions supported by this plugin.
        abstract extensions: U2<string, ISceneLoaderPluginExtensions> with get, set
        /// <summary>Import meshes into a scene.</summary>
        /// <param name="meshesNames">An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="scene">The scene to import into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onProgress">The callback when the load progresses</param>
        abstract importMeshAsync: meshesNames: obj option * scene: Scene * data: obj option * rootUrl: string * ?onProgress: (SceneLoaderProgressEvent -> unit) -> Promise<obj>
        /// <summary>Load into a scene.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onProgress">The callback when the load progresses</param>
        abstract loadAsync: scene: Scene * data: string * rootUrl: string * ?onProgress: (SceneLoaderProgressEvent -> unit) -> Promise<unit>
        /// The callback that returns true if the data can be directly loaded.
        abstract canDirectLoad: (string -> bool) option with get, set
        /// The callback that allows custom handling of the root url based on the response url.
        abstract rewriteRootURL: (string -> string -> string) option with get, set
        /// <summary>Load into an asset container.</summary>
        /// <param name="scene">The scene to load into</param>
        /// <param name="data">The data to import</param>
        /// <param name="rootUrl">The root url for scene and resources</param>
        /// <param name="onProgress">The callback when the load progresses</param>
        abstract loadAssetContainerAsync: scene: Scene * data: string * rootUrl: string * ?onProgress: (SceneLoaderProgressEvent -> unit) -> Promise<AssetContainer>

    type [<AllowNullLiteral>] SceneLoader =
        abstract _ForceFullSceneLoadingForIncremental: obj with get, set
        abstract _ShowLoadingScreen: obj with get, set
        abstract _CleanBoneMatrixWeights: obj with get, set
        abstract NO_LOGGING: float
        abstract MINIMAL_LOGGING: float
        abstract SUMMARY_LOGGING: float
        abstract DETAILED_LOGGING: float
        abstract _loggingLevel: obj with get, set
        abstract ForceFullSceneLoadingForIncremental: bool with get, set
        abstract ShowLoadingScreen: bool with get, set
        abstract loggingLevel: float with get, set
        abstract CleanBoneMatrixWeights: bool with get, set
        abstract OnPluginActivatedObservable: Observable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>> with get, set
        abstract _registeredPlugins: obj with get, set

    type [<AllowNullLiteral>] SceneLoaderStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SceneLoader
        abstract _getDefaultPlugin: unit -> unit
        abstract _getPluginForExtension: extension: obj -> unit
        abstract _getPluginForDirectLoad: data: obj -> unit
        abstract _getPluginForFilename: sceneFilename: obj -> unit
        abstract _getDirectLoad: sceneFilename: obj -> unit
        abstract _loadData: rootUrl: obj * sceneFilename: obj * scene: obj * onSuccess: obj * onProgress: obj * onError: obj * onDispose: obj * pluginExtension: obj -> unit
        abstract GetPluginForExtension: extension: string -> U3<ISceneLoaderPlugin, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory>
        abstract IsPluginForExtensionAvailable: extension: string -> bool
        abstract RegisterPlugin: plugin: U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync> -> unit
        /// <summary>Import meshes into a scene</summary>
        /// <param name="meshNames">an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="scene">the instance of BABYLON.Scene to append to</param>
        /// <param name="onSuccess">a callback with a list of imported meshes, particleSystems, and skeletons when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract ImportMesh: meshNames: obj option * rootUrl: string * sceneFilename: string * scene: Scene * ?onSuccess: Nullable<(ResizeArray<AbstractMesh> -> ResizeArray<ParticleSystem> -> ResizeArray<Skeleton> -> ResizeArray<AnimationGroup> -> unit)> * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?onError: Nullable<(Scene -> string -> obj option -> unit)> * ?pluginExtension: Nullable<string> -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Import meshes into a scene</summary>
        /// <param name="meshNames">an array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported</param>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="scene">the instance of BABYLON.Scene to append to</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract ImportMeshAsync: meshNames: obj option * rootUrl: string * sceneFilename: string * scene: Scene * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?pluginExtension: Nullable<string> -> Promise<obj>
        /// <summary>Load a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="engine">is the instance of BABYLON.Engine to use to create the scene</param>
        /// <param name="onSuccess">a callback with the scene when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract Load: rootUrl: string * sceneFilename: obj option * engine: Engine * ?onSuccess: Nullable<(Scene -> unit)> * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?onError: Nullable<(Scene -> string -> obj option -> unit)> * ?pluginExtension: Nullable<string> -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Load a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="engine">is the instance of BABYLON.Engine to use to create the scene</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract LoadAsync: rootUrl: string * sceneFilename: obj option * engine: Engine * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?pluginExtension: Nullable<string> -> Promise<Scene>
        /// <summary>Append a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to</param>
        /// <param name="onSuccess">a callback with the scene when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract Append: rootUrl: string * sceneFilename: obj option * scene: Scene * ?onSuccess: Nullable<(Scene -> unit)> * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?onError: Nullable<(Scene -> string -> obj option -> unit)> * ?pluginExtension: Nullable<string> -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Append a scene</summary>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract AppendAsync: rootUrl: string * sceneFilename: obj option * scene: Scene * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?pluginExtension: Nullable<string> -> Promise<Scene>
        /// <summary>Load a scene into an asset container</summary>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to</param>
        /// <param name="onSuccess">a callback with the scene when import succeeds</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="onError">a callback with the scene, a message, and possibly an exception when import fails</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract LoadAssetContainer: rootUrl: string * sceneFilename: obj option * scene: Scene * ?onSuccess: Nullable<(AssetContainer -> unit)> * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?onError: Nullable<(Scene -> string -> obj option -> unit)> * ?pluginExtension: Nullable<string> -> Nullable<U2<ISceneLoaderPlugin, ISceneLoaderPluginAsync>>
        /// <summary>Load a scene into an asset container</summary>
        /// <param name="rootUrl">a string that defines the root url for scene and resources</param>
        /// <param name="sceneFilename">a string that defines the name of the scene file. can start with "data:" following by the stringified version of the scene</param>
        /// <param name="scene">is the instance of BABYLON.Scene to append to</param>
        /// <param name="onProgress">a callback with a progress event for each file being loaded</param>
        /// <param name="pluginExtension">the extension used to determine the plugin</param>
        abstract LoadAssetContainerAsync: rootUrl: string * sceneFilename: obj option * scene: Scene * ?onProgress: Nullable<(SceneLoaderProgressEvent -> unit)> * ?pluginExtension: Nullable<string> -> Promise<AssetContainer>

    type [<AllowNullLiteral>] LensFlare =
        abstract size: float with get, set
        abstract position: float with get, set
        abstract color: Color3 with get, set
        abstract texture: Nullable<Texture> with get, set
        abstract alphaMode: float with get, set
        abstract _system: obj with get, set
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] LensFlareStatic =
        abstract AddFlare: size: float * position: float * color: Color3 * imgUrl: string * system: LensFlareSystem -> LensFlare
        [<Emit "new $0($1...)">] abstract Create: size: float * position: float * color: Color3 * imgUrl: string * system: LensFlareSystem -> LensFlare

    type [<AllowNullLiteral>] LensFlareSystem =
        abstract name: string with get, set
        abstract lensFlares: ResizeArray<LensFlare> with get, set
        abstract borderLimit: float with get, set
        abstract viewportBorder: float with get, set
        abstract meshesSelectionPredicate: (AbstractMesh -> bool) with get, set
        abstract layerMask: float with get, set
        abstract id: string with get, set
        abstract _scene: obj with get, set
        abstract _emitter: obj with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _effect: obj with get, set
        abstract _positionX: obj with get, set
        abstract _positionY: obj with get, set
        abstract _isEnabled: obj with get, set
        abstract isEnabled: bool with get, set
        abstract getScene: unit -> Scene
        abstract getEmitter: unit -> obj option
        abstract setEmitter: newEmitter: obj option -> unit
        abstract getEmitterPosition: unit -> Vector3
        abstract computeEffectivePosition: globalViewport: Viewport -> bool
        abstract _isVisible: unit -> bool
        abstract render: unit -> bool
        abstract dispose: unit -> unit
        abstract serialize: unit -> obj option

    type [<AllowNullLiteral>] LensFlareSystemStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * emitter: obj option * scene: Scene -> LensFlareSystem
        abstract Parse: parsedLensFlareSystem: obj option * scene: Scene * rootUrl: string -> LensFlareSystem

    /// A directional light is defined by a direction (what a surprise!).
    /// The light is emitted from everywhere in the specified direction, and has an infinite range.
    /// An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] DirectionalLight =
        inherit ShadowLight
        abstract _shadowFrustumSize: obj with get, set
        /// Fix frustum size for the shadow generation. This is disabled if the value is 0.
        /// Specifies a fix frustum size for the shadow generation.
        abstract shadowFrustumSize: float with get, set
        abstract _shadowOrthoScale: obj with get, set
        /// Gets the shadow projection scale against the optimal computed one.
        /// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
        /// This does not impact in fixed frustum size (shadowFrustumSize being set)
        /// Sets the shadow projection scale against the optimal computed one.
        /// 0.1 by default which means that the projection window is increase by 10% from the optimal size.
        /// This does not impact in fixed frustum size (shadowFrustumSize being set)
        abstract shadowOrthoScale: float with get, set
        /// Automatically compute the projection matrix to best fit (including all the casters)
        /// on each frame.
        abstract autoUpdateExtends: bool with get, set
        abstract _orthoLeft: obj with get, set
        abstract _orthoRight: obj with get, set
        abstract _orthoTop: obj with get, set
        abstract _orthoBottom: obj with get, set
        /// Returns the string "DirectionalLight".
        abstract getClassName: unit -> string
        /// Returns the integer 1.
        abstract getTypeID: unit -> float
        /// Sets the passed matrix "matrix" as projection matrix for the shadows cast by the light according to the passed view matrix.
        /// Returns the DirectionalLight Shadow projection matrix.
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        /// Sets the passed matrix "matrix" as fixed frustum projection matrix for the shadows cast by the light according to the passed view matrix.
        /// Returns the DirectionalLight Shadow projection matrix.
        abstract _setDefaultFixedFrustumShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix -> unit
        /// Sets the passed matrix "matrix" as auto extend projection matrix for the shadows cast by the light according to the passed view matrix.
        /// Returns the DirectionalLight Shadow projection matrix.
        abstract _setDefaultAutoExtendShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect object with the DirectionalLight transformed position (or position if not parented) and the passed name.</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> DirectionalLight
        /// <summary>Gets the minZ used for shadow according to both the scene and the light.
        /// 
        /// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
        /// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.</summary>
        /// <param name="activeCamera">The camera we are returning the min for</param>
        abstract getDepthMinZ: activeCamera: Camera -> float
        /// <summary>Gets the maxZ used for shadow according to both the scene and the light.
        /// 
        /// Values are fixed on directional lights as it relies on an ortho projection hence the need to convert being
        /// -1 and 1 to 0 and 1 doing (depth + min) / (min + max) -> (depth + 1) / (1 + 1) -> (depth * 0.5) + 0.5.</summary>
        /// <param name="activeCamera">The camera we are returning the max for</param>
        abstract getDepthMaxZ: activeCamera: Camera -> float

    /// A directional light is defined by a direction (what a surprise!).
    /// The light is emitted from everywhere in the specified direction, and has an infinite range.
    /// An example of a directional light is when a distance planet is lit by the apparently parallel lines of light from its sun. Light in a downward direction will light the top of an object.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] DirectionalLightStatic =
        /// <summary>Creates a DirectionalLight object in the scene, oriented towards the passed direction (Vector3).
        /// The directional light is emitted from everywhere in the given direction.
        /// It can cast shawdows.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The friendly name of the light</param>
        /// <param name="direction">The direction of the light</param>
        /// <param name="scene">The scene the light belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * direction: Vector3 * scene: Scene -> DirectionalLight

    /// The HemisphericLight simulates the ambient environment light,
    /// so the passed direction is the light reflection direction, not the incoming direction.
    type [<AllowNullLiteral>] HemisphericLight =
        inherit Light
        /// The groundColor is the light in the opposite direction to the one specified during creation.
        /// You can think of the diffuse and specular light as coming from the centre of the object in the given direction and the groundColor light in the opposite direction.
        abstract groundColor: Color3 with get, set
        /// The light reflection direction, not the incoming direction.
        abstract direction: Vector3 with get, set
        abstract _worldMatrix: obj with get, set
        abstract _buildUniformLayout: unit -> unit
        /// Returns the string "HemisphericLight".
        abstract getClassName: unit -> string
        /// <summary>Sets the HemisphericLight direction towards the passed target (Vector3).
        /// Returns the updated direction.</summary>
        /// <param name="target">The target the direction should point to</param>
        abstract setDirectionToTarget: target: Vector3 -> Vector3
        /// Returns the shadow generator associated to the light.
        abstract getShadowGenerator: unit -> Nullable<ShadowGenerator>
        /// <summary>Sets the passed Effect object with the HemisphericLight normalized direction and color and the passed name (string).</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> HemisphericLight
        abstract _getWorldMatrix: unit -> Matrix
        /// Returns the integer 3.
        abstract getTypeID: unit -> float

    /// The HemisphericLight simulates the ambient environment light,
    /// so the passed direction is the light reflection direction, not the incoming direction.
    type [<AllowNullLiteral>] HemisphericLightStatic =
        /// <summary>Creates a HemisphericLight object in the scene according to the passed direction (Vector3).
        /// The HemisphericLight simulates the ambient environment light, so the passed direction is the light reflection direction, not the incoming direction.
        /// The HemisphericLight can't cast shadows.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The friendly name of the light</param>
        /// <param name="direction">The direction of the light reflection</param>
        /// <param name="scene">The scene the light belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * direction: Vector3 * scene: Scene -> HemisphericLight

    /// Base class of all the lights in Babylon. It groups all the generic information about lights.
    /// Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
    /// All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
    type [<AllowNullLiteral>] Light =
        inherit Node
        abstract _LIGHTMAP_DEFAULT: obj with get, set
        abstract _LIGHTMAP_SPECULAR: obj with get, set
        abstract _LIGHTMAP_SHADOWSONLY: obj with get, set
        /// If every light affecting the material is in this lightmapMode,
        /// material.lightmapTexture adds or multiplies
        /// (depends on material.useLightmapAsShadowmap)
        /// after every other light calculations.
        abstract LIGHTMAP_DEFAULT: float
        /// material.lightmapTexture as only diffuse lighting from this light
        /// adds only specular lighting from this light
        /// adds dynamic shadows
        abstract LIGHTMAP_SPECULAR: float
        /// material.lightmapTexture as only lighting
        /// no light calculation from this light
        /// only adds dynamic shadows from this light
        abstract LIGHTMAP_SHADOWSONLY: float
        abstract _INTENSITYMODE_AUTOMATIC: obj with get, set
        abstract _INTENSITYMODE_LUMINOUSPOWER: obj with get, set
        abstract _INTENSITYMODE_LUMINOUSINTENSITY: obj with get, set
        abstract _INTENSITYMODE_ILLUMINANCE: obj with get, set
        abstract _INTENSITYMODE_LUMINANCE: obj with get, set
        /// Each light type uses the default quantity according to its type:
        ///       point/spot lights use luminous intensity
        ///       directional lights use illuminance
        abstract INTENSITYMODE_AUTOMATIC: float
        /// lumen (lm)
        abstract INTENSITYMODE_LUMINOUSPOWER: float
        /// candela (lm/sr)
        abstract INTENSITYMODE_LUMINOUSINTENSITY: float
        /// lux (lm/m^2)
        abstract INTENSITYMODE_ILLUMINANCE: float
        /// nit (cd/m^2)
        abstract INTENSITYMODE_LUMINANCE: float
        abstract _LIGHTTYPEID_POINTLIGHT: obj with get, set
        abstract _LIGHTTYPEID_DIRECTIONALLIGHT: obj with get, set
        abstract _LIGHTTYPEID_SPOTLIGHT: obj with get, set
        abstract _LIGHTTYPEID_HEMISPHERICLIGHT: obj with get, set
        /// Light type const id of the point light.
        abstract LIGHTTYPEID_POINTLIGHT: float
        /// Light type const id of the directional light.
        abstract LIGHTTYPEID_DIRECTIONALLIGHT: float
        /// Light type const id of the spot light.
        abstract LIGHTTYPEID_SPOTLIGHT: float
        /// Light type const id of the hemispheric light.
        abstract LIGHTTYPEID_HEMISPHERICLIGHT: float
        /// Diffuse gives the basic color to an object.
        abstract diffuse: Color3 with get, set
        /// Specular produces a highlight color on an object.
        /// Note: This is note affecting PBR materials.
        abstract specular: Color3 with get, set
        /// Strength of the light.
        /// Note: By default it is define in the framework own unit.
        /// Note: In PBR materials the intensityMode can be use to chose what unit the intensity is defined in.
        abstract intensity: float with get, set
        /// Defines how far from the source the light is impacting in scene units.
        /// Note: Unused in PBR material as the distance light falloff is defined following the inverse squared falloff.
        abstract range: float with get, set
        /// Cached photometric scale default to 1.0 as the automatic intensity mode defaults to 1.0 for every type
        /// of light.
        abstract _photometricScale: obj with get, set
        abstract _intensityMode: obj with get, set
        /// Gets the photometric scale used to interpret the intensity.
        /// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
        /// Sets the photometric scale used to interpret the intensity.
        /// This is only relevant with PBR Materials where the light intensity can be defined in a physical way.
        abstract intensityMode: float with get, set
        abstract _radius: obj with get, set
        /// Gets the light radius used by PBR Materials to simulate soft area lights.
        /// sets the light radius used by PBR Materials to simulate soft area lights.
        abstract radius: float with get, set
        abstract _renderPriority: obj with get, set
        /// Defines the rendering priority of the lights. It can help in case of fallback or number of lights
        /// exceeding the number allowed of the materials.
        abstract renderPriority: float with get, set
        /// Defines wether or not the shadows are enabled for this light. This can help turning off/on shadow without detaching
        /// the current shadow generator.
        abstract shadowEnabled: bool with get, set
        abstract _includedOnlyMeshes: obj with get, set
        /// Gets the only meshes impacted by this light.
        /// Sets the only meshes impacted by this light.
        abstract includedOnlyMeshes: ResizeArray<AbstractMesh> with get, set
        abstract _excludedMeshes: obj with get, set
        /// Gets the meshes not impacted by this light.
        /// Sets the meshes not impacted by this light.
        abstract excludedMeshes: ResizeArray<AbstractMesh> with get, set
        abstract _excludeWithLayerMask: obj with get, set
        /// Gets the layer id use to find what meshes are not impacted by the light.
        /// Inactive if 0
        /// Sets the layer id use to find what meshes are not impacted by the light.
        /// Inactive if 0
        abstract excludeWithLayerMask: float with get, set
        abstract _includeOnlyWithLayerMask: obj with get, set
        /// Gets the layer id use to find what meshes are impacted by the light.
        /// Inactive if 0
        /// Sets the layer id use to find what meshes are impacted by the light.
        /// Inactive if 0
        abstract includeOnlyWithLayerMask: float with get, set
        abstract _lightmapMode: obj with get, set
        /// Gets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
        /// Sets the lightmap mode of this light (should be one of the constants defined by Light.LIGHTMAP_x)
        abstract lightmapMode: float with get, set
        abstract _parentedWorldMatrix: obj with get, set
        /// Shadow generator associted to the light.
        /// Internal use only.
        abstract _shadowGenerator: Nullable<IShadowGenerator> with get, set
        abstract _excludedMeshesIds: ResizeArray<string> with get, set
        abstract _includedOnlyMeshesIds: ResizeArray<string> with get, set
        /// The current light unifom buffer.
        abstract _uniformBuffer: UniformBuffer with get, set
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect "effect" with the Light information.</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> Light
        abstract _getWorldMatrix: unit -> Matrix
        /// Returns the string "Light".
        abstract getClassName: unit -> string
        /// <summary>Converts the light information to a readable string for debug purpose.</summary>
        /// <param name="fullDetails">Supports for multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string
        /// <summary>Set the enabled state of this node.</summary>
        /// <param name="value">- the new enabled state</param>
        abstract setEnabled: value: bool -> unit
        /// Returns the Light associated shadow generator if any.
        abstract getShadowGenerator: unit -> Nullable<IShadowGenerator>
        /// Returns a Vector3, the absolute light position in the World.
        abstract getAbsolutePosition: unit -> Vector3
        /// <summary>Specifies if the light will affect the passed mesh.</summary>
        /// <param name="mesh">The mesh to test against the light</param>
        abstract canAffectMesh: mesh: AbstractMesh -> bool
        /// Computes and Returns the light World matrix.
        abstract getWorldMatrix: unit -> Matrix
        /// <summary>Releases resources associated with this node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        /// Returns the light type ID (integer).
        abstract getTypeID: unit -> float
        /// Returns the intensity scaled by the Photometric Scale according to the light type and intensity mode.
        abstract getScaledIntensity: unit -> float
        /// <summary>Returns a new Light object, named "name", from the current one.</summary>
        /// <param name="name">The name of the cloned light</param>
        abstract clone: name: string -> Nullable<Light>
        /// Serializes the current light into a Serialization object.
        abstract serialize: unit -> obj option
        abstract _hookArrayForExcluded: array: obj -> unit
        abstract _hookArrayForIncludedOnly: array: obj -> unit
        abstract _resyncMeshes: unit -> unit
        /// Forces the meshes to update their light related information in their rendering used effects
        abstract _markMeshesAsLightDirty: unit -> unit
        /// Recomputes the cached photometric scale if needed.
        abstract _computePhotometricScale: unit -> unit
        /// Returns the Photometric Scale according to the light type and intensity mode.
        abstract _getPhotometricScale: unit -> unit
        /// Reorder the light in the scene according to their defined priority.
        abstract _reorderLightsInScene: unit -> unit

    /// Base class of all the lights in Babylon. It groups all the generic information about lights.
    /// Lights are used, as you would expect, to affect how meshes are seen, in terms of both illumination and colour.
    /// All meshes allow light to pass through them unless shadow generation is activated. The default number of lights allowed is four but this can be increased.
    type [<AllowNullLiteral>] LightStatic =
        /// <summary>Creates a Light object in the scene.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The firendly name of the light</param>
        /// <param name="scene">The scene the light belongs too</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> Light
        /// <summary>Sort function to order lights for rendering.</summary>
        /// <param name="a">First Light object to compare to second.</param>
        /// <param name="b">Second Light object to compare first.</param>
        abstract CompareLightsPriority: a: Light * b: Light -> float
        /// <summary>Creates a new typed light from the passed type (integer) : point light = 0, directional light = 1, spot light = 2, hemispheric light = 3.
        /// This new light is named "name" and added to the passed scene.</summary>
        /// <param name="type">Type according to the types available in Light.LIGHTTYPEID_x</param>
        /// <param name="name">The friendly name of the light</param>
        /// <param name="scene">The scene the new light will belong to</param>
        abstract GetConstructorFromName: ``type``: float * name: string * scene: Scene -> Nullable<(unit -> Light)>
        /// <summary>Parses the passed "parsedLight" and returns a new instanced Light from this parsing.</summary>
        /// <param name="parsedLight">The JSON representation of the light</param>
        /// <param name="scene">The scene to create the parsed light in</param>
        abstract Parse: parsedLight: obj option * scene: Scene -> Nullable<Light>

    /// A point light is a light defined by an unique point in world space.
    /// The light is emitted in every direction from this point.
    /// A good example of a point light is a standard light bulb.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] PointLight =
        inherit ShadowLight
        abstract _shadowAngle: obj with get, set
        /// Getter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        /// This specifies what angle the shadow will use to be created.
        /// 
        /// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
        /// Setter: In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        /// This specifies what angle the shadow will use to be created.
        /// 
        /// It default to 90 degrees to work nicely with the cube texture generation for point lights shadow maps.
        abstract shadowAngle: float with get, set
        /// Gets the direction if it has been set.
        /// In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        /// In case of direction provided, the shadow will not use a cube texture but simulate a spot shadow as a fallback
        abstract direction: Vector3 with get, set
        /// Returns the string "PointLight"
        abstract getClassName: unit -> string
        /// Returns the integer 0.
        abstract getTypeID: unit -> float
        /// Specifies wether or not the shadowmap should be a cube texture.
        abstract needCube: unit -> bool
        /// <summary>Returns a new Vector3 aligned with the PointLight cube system according to the passed cube face index (integer).</summary>
        /// <param name="faceIndex">The index of the face we are computed the direction to generate shadow</param>
        abstract getShadowDirection: ?faceIndex: float -> Vector3
        /// Sets the passed matrix "matrix" as a left-handed perspective projection matrix with the following settings :
        /// - fov = PI / 2
        /// - aspect ratio : 1.0
        /// - z-near and far equal to the active camera minZ and maxZ.
        /// Returns the PointLight.
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect "effect" with the PointLight transformed position (or position, if none) and passed name (string).</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> PointLight

    /// A point light is a light defined by an unique point in world space.
    /// The light is emitted in every direction from this point.
    /// A good example of a point light is a standard light bulb.
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] PointLightStatic =
        /// <summary>Creates a PointLight object from the passed name and position (Vector3) and adds it in the scene.
        /// A PointLight emits the light in every direction.
        /// It can cast shadows.
        /// If the scene camera is already defined and you want to set your PointLight at the camera position, just set it :
        /// ```javascript
        /// var pointLight = new BABYLON.PointLight("pl", camera.position, scene);
        /// ```
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The light friendly name</param>
        /// <param name="position">The position of the point light in the scene</param>
        /// <param name="scene">The scene the lights belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene -> PointLight

    /// Interface describing all the common properties and methods a shadow light needs to implement.
    /// This helps both the shadow generator and materials to genrate the corresponding shadow maps
    /// as well as binding the different shadow properties to the effects.
    type [<AllowNullLiteral>] IShadowLight =
        inherit Light
        /// The light id in the scene (used in scene.findLighById for instance)
        abstract id: string with get, set
        /// The position the shdow will be casted from.
        abstract position: Vector3 with get, set
        /// In 2d mode (needCube being false), the direction used to cast the shadow.
        abstract direction: Vector3 with get, set
        /// The transformed position. Position of the light in world space taking parenting in account.
        abstract transformedPosition: Vector3 with get, set
        /// The transformed direction. Direction of the light in world space taking parenting in account.
        abstract transformedDirection: Vector3 with get, set
        /// The friendly name of the light in the scene.
        abstract name: string with get, set
        /// Defines the shadow projection clipping minimum z value.
        abstract shadowMinZ: float with get, set
        /// Defines the shadow projection clipping maximum z value.
        abstract shadowMaxZ: float with get, set
        /// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
        abstract computeTransformedInformation: unit -> bool
        /// Gets the scene the light belongs to.
        abstract getScene: unit -> Scene
        /// Callback defining a custom Projection Matrix Builder.
        /// This can be used to override the default projection matrix computation.
        abstract customProjectionMatrixBuilder: (Matrix -> Array<AbstractMesh> -> Matrix -> unit) with get, set
        /// <summary>Sets the shadow projection matrix in parameter to the generated projection matrix.</summary>
        /// <param name="matrix">The materix to updated with the projection information</param>
        /// <param name="viewMatrix">The transform matrix of the light</param>
        /// <param name="renderList">The list of mesh to render in the map</param>
        abstract setShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> IShadowLight
        /// Gets the current depth scale used in ESM.
        abstract getDepthScale: unit -> float
        /// Returns whether or not the shadow generation require a cube texture or a 2d texture.
        abstract needCube: unit -> bool
        /// Detects if the projection matrix requires to be recomputed this frame.
        abstract needProjectionMatrixCompute: unit -> bool
        /// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
        abstract forceProjectionMatrixCompute: unit -> unit
        /// <summary>Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.</summary>
        /// <param name="faceIndex">The index of the face we are computed the direction to generate shadow</param>
        abstract getShadowDirection: ?faceIndex: float -> Vector3
        /// <summary>Gets the minZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the min for</param>
        abstract getDepthMinZ: activeCamera: Camera -> float
        /// <summary>Gets the maxZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the max for</param>
        abstract getDepthMaxZ: activeCamera: Camera -> float

    /// Base implementation IShadowLight
    /// It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
    type [<AllowNullLiteral>] ShadowLight =
        inherit Light
        inherit IShadowLight
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _position: Vector3 with get, set
        abstract _setPosition: value: Vector3 -> unit
        /// Sets the position the shadow will be casted from. Also use as the light position for both
        /// point and spot lights.
        /// Sets the position the shadow will be casted from. Also use as the light position for both
        /// point and spot lights.
        abstract position: Vector3 with get, set
        abstract _direction: Vector3 with get, set
        abstract _setDirection: value: Vector3 -> unit
        /// In 2d mode (needCube being false), gets the direction used to cast the shadow.
        /// Also use as the light direction on spot and directional lights.
        /// In 2d mode (needCube being false), sets the direction used to cast the shadow.
        /// Also use as the light direction on spot and directional lights.
        abstract direction: Vector3 with get, set
        abstract _shadowMinZ: obj with get, set
        /// Gets the shadow projection clipping minimum z value.
        /// Sets the shadow projection clipping minimum z value.
        abstract shadowMinZ: float with get, set
        abstract _shadowMaxZ: obj with get, set
        /// Sets the shadow projection clipping maximum z value.
        /// Gets the shadow projection clipping maximum z value.
        abstract shadowMaxZ: float with get, set
        /// Callback defining a custom Projection Matrix Builder.
        /// This can be used to override the default projection matrix computation.
        abstract customProjectionMatrixBuilder: (Matrix -> Array<AbstractMesh> -> Matrix -> unit) with get, set
        /// The transformed position. Position of the light in world space taking parenting in account.
        abstract transformedPosition: Vector3 with get, set
        /// The transformed direction. Direction of the light in world space taking parenting in account.
        abstract transformedDirection: Vector3 with get, set
        abstract _worldMatrix: obj with get, set
        abstract _needProjectionMatrixCompute: obj with get, set
        /// Computes the transformed information (transformedPosition and transformedDirection in World space) of the current light
        abstract computeTransformedInformation: unit -> bool
        /// Return the depth scale used for the shadow map.
        abstract getDepthScale: unit -> float
        /// <summary>Get the direction to use to render the shadow map. In case of cube texture, the face index can be passed.</summary>
        /// <param name="faceIndex">The index of the face we are computed the direction to generate shadow</param>
        abstract getShadowDirection: ?faceIndex: float -> Vector3
        /// Returns the ShadowLight absolute position in the World.
        abstract getAbsolutePosition: unit -> Vector3
        /// <summary>Sets the ShadowLight direction toward the passed target.</summary>
        /// <param name="target">The point tot target in local space</param>
        abstract setDirectionToTarget: target: Vector3 -> Vector3
        /// Returns the light rotation in euler definition.
        abstract getRotation: unit -> Vector3
        /// Returns whether or not the shadow generation require a cube texture or a 2d texture.
        abstract needCube: unit -> bool
        /// Detects if the projection matrix requires to be recomputed this frame.
        abstract needProjectionMatrixCompute: unit -> bool
        /// Forces the shadow generator to recompute the projection matrix even if position and direction did not changed.
        abstract forceProjectionMatrixCompute: unit -> unit
        /// Get the world matrix of the sahdow lights.
        abstract _getWorldMatrix: unit -> Matrix
        /// <summary>Gets the minZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the min for</param>
        abstract getDepthMinZ: activeCamera: Camera -> float
        /// <summary>Gets the maxZ used for shadow according to both the scene and the light.</summary>
        /// <param name="activeCamera">The camera we are returning the max for</param>
        abstract getDepthMaxZ: activeCamera: Camera -> float
        /// <summary>Sets the shadow projection matrix in parameter to the generated projection matrix.</summary>
        /// <param name="matrix">The materix to updated with the projection information</param>
        /// <param name="viewMatrix">The transform matrix of the light</param>
        /// <param name="renderList">The list of mesh to render in the map</param>
        abstract setShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> IShadowLight

    /// Base implementation IShadowLight
    /// It groups all the common behaviour in order to reduce dupplication and better follow the DRY pattern.
    type [<AllowNullLiteral>] ShadowLightStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ShadowLight

    /// A spot light is defined by a position, a direction, an angle, and an exponent.
    /// These values define a cone of light starting from the position, emitting toward the direction.
    /// The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
    /// and the exponent defines the speed of the decay of the light with distance (reach).
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] SpotLight =
        inherit ShadowLight
        abstract _angle: obj with get, set
        /// Gets the cone angle of the spot light in Radians.
        /// Sets the cone angle of the spot light in Radians.
        abstract angle: float with get, set
        abstract _shadowAngleScale: obj with get, set
        /// Allows scaling the angle of the light for shadow generation only.
        /// Allows scaling the angle of the light for shadow generation only.
        abstract shadowAngleScale: float with get, set
        /// The light decay speed with the distance from the emission spot.
        abstract exponent: float with get, set
        abstract _projectionTextureMatrix: obj with get, set
        /// Allows reading the projecton texture
        abstract projectionTextureMatrix: Matrix
        abstract _projectionTextureLightNear: float with get, set
        /// Gets the near clip of the Spotlight for texture projection.
        /// Sets the near clip of the Spotlight for texture projection.
        abstract projectionTextureLightNear: float with get, set
        abstract _projectionTextureLightFar: float with get, set
        /// Gets the far clip of the Spotlight for texture projection.
        /// Sets the far clip of the Spotlight for texture projection.
        abstract projectionTextureLightFar: float with get, set
        abstract _projectionTextureUpDirection: Vector3 with get, set
        /// Gets the Up vector of the Spotlight for texture projection.
        /// Sets the Up vector of the Spotlight for texture projection.
        abstract projectionTextureUpDirection: Vector3 with get, set
        abstract _projectionTexture: obj with get, set
        /// Gets the projection texture of the light.
        /// Sets the projection texture of the light.
        abstract projectionTexture: Nullable<BaseTexture> with get, set
        abstract _projectionTextureViewLightDirty: obj with get, set
        abstract _projectionTextureProjectionLightDirty: obj with get, set
        abstract _projectionTextureDirty: obj with get, set
        abstract _projectionTextureViewTargetVector: obj with get, set
        abstract _projectionTextureViewLightMatrix: obj with get, set
        abstract _projectionTextureProjectionLightMatrix: obj with get, set
        abstract _projectionTextureScalingMatrix: obj with get, set
        /// Returns the string "SpotLight".
        abstract getClassName: unit -> string
        /// Returns the integer 2.
        abstract getTypeID: unit -> float
        /// Overrides the direction setter to recompute the projection texture view light Matrix.
        abstract _setDirection: value: Vector3 -> unit
        /// Overrides the position setter to recompute the projection texture view light Matrix.
        abstract _setPosition: value: Vector3 -> unit
        /// Sets the passed matrix "matrix" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.
        /// Returns the SpotLight.
        abstract _setDefaultShadowProjectionMatrix: matrix: Matrix * viewMatrix: Matrix * renderList: Array<AbstractMesh> -> unit
        abstract _computeProjectionTextureViewLightMatrix: unit -> unit
        abstract _computeProjectionTextureProjectionLightMatrix: unit -> unit
        /// Main function for light texture projection matrix computing.
        abstract _computeProjectionTextureMatrix: unit -> unit
        abstract _buildUniformLayout: unit -> unit
        /// <summary>Sets the passed Effect object with the SpotLight transfomed position (or position if not parented) and normalized direction.</summary>
        /// <param name="effect">The effect to update</param>
        /// <param name="lightIndex">The index of the light in the effect to update</param>
        abstract transferToEffect: effect: Effect * lightIndex: string -> SpotLight
        /// Disposes the light and the associated resources.
        abstract dispose: unit -> unit

    /// A spot light is defined by a position, a direction, an angle, and an exponent.
    /// These values define a cone of light starting from the position, emitting toward the direction.
    /// The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,
    /// and the exponent defines the speed of the decay of the light with distance (reach).
    /// Documentation: https://doc.babylonjs.com/babylon101/lights
    type [<AllowNullLiteral>] SpotLightStatic =
        /// <summary>Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.
        /// It can cast shadows.
        /// Documentation : http://doc.babylonjs.com/tutorials/lights</summary>
        /// <param name="name">The light friendly name</param>
        /// <param name="position">The position of the spot light in the scene</param>
        /// <param name="direction">The direction of the light in the scene</param>
        /// <param name="angle">The cone angle of the light in Radians</param>
        /// <param name="exponent">The light decay speed with the distance from the emission spot</param>
        /// <param name="scene">The scene the lights belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * direction: Vector3 * angle: float * exponent: float * scene: Scene -> SpotLight

    /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
    /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
    /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
    /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
    type [<AllowNullLiteral>] ColorCurves =
        abstract _dirty: obj with get, set
        abstract _tempColor: obj with get, set
        abstract _globalCurve: obj with get, set
        abstract _highlightsCurve: obj with get, set
        abstract _midtonesCurve: obj with get, set
        abstract _shadowsCurve: obj with get, set
        abstract _positiveCurve: obj with get, set
        abstract _negativeCurve: obj with get, set
        abstract _globalHue: obj with get, set
        abstract _globalDensity: obj with get, set
        abstract _globalSaturation: obj with get, set
        abstract _globalExposure: obj with get, set
        /// Gets the global Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the global Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract globalHue: float with get, set
        /// Gets the global Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the global Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract globalDensity: float with get, set
        /// Gets the global Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the global Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract globalSaturation: float with get, set
        abstract _highlightsHue: obj with get, set
        abstract _highlightsDensity: obj with get, set
        abstract _highlightsSaturation: obj with get, set
        abstract _highlightsExposure: obj with get, set
        /// Gets the highlights Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the highlights Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract highlightsHue: float with get, set
        /// Gets the highlights Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the highlights Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract highlightsDensity: float with get, set
        /// Gets the highlights Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the highlights Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract highlightsSaturation: float with get, set
        /// Gets the highlights Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        /// Sets the highlights Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        abstract highlightsExposure: float with get, set
        abstract _midtonesHue: obj with get, set
        abstract _midtonesDensity: obj with get, set
        abstract _midtonesSaturation: obj with get, set
        abstract _midtonesExposure: obj with get, set
        /// Gets the midtones Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the midtones Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract midtonesHue: float with get, set
        /// Gets the midtones Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the midtones Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract midtonesDensity: float with get, set
        /// Gets the midtones Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the midtones Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract midtonesSaturation: float with get, set
        /// Gets the midtones Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        /// Sets the midtones Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        abstract midtonesExposure: float with get, set
        abstract _shadowsHue: obj with get, set
        abstract _shadowsDensity: obj with get, set
        abstract _shadowsSaturation: obj with get, set
        abstract _shadowsExposure: obj with get, set
        /// Gets the shadows Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        /// Sets the shadows Hue value.
        /// The hue value is a standard HSB hue in the range [0,360] where 0=red, 120=green and 240=blue. The default value is 30 degrees (orange).
        abstract shadowsHue: float with get, set
        /// Gets the shadows Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        /// Sets the shadows Density value.
        /// The density value is in range [-100,+100] where 0 means the color filter has no effect and +100 means the color filter has maximum effect.
        /// Values less than zero provide a filter of opposite hue.
        abstract shadowsDensity: float with get, set
        /// Gets the shadows Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        /// Sets the shadows Saturation value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase saturation and negative values decrease saturation.
        abstract shadowsSaturation: float with get, set
        /// Gets the shadows Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        /// Sets the shadows Exposure value.
        /// This is an adjustment value in the range [-100,+100], where the default value of 0.0 makes no adjustment, positive values increase exposure and negative values decrease exposure.
        abstract shadowsExposure: float with get, set
        abstract getClassName: unit -> string
        /// <summary>Returns color grading data based on a hue, density, saturation and exposure value.</summary>
        /// <param name="saturation">The saturation.</param>
        /// <param name="exposure">The exposure.</param>
        /// <param name="result">The result data container.</param>
        abstract getColorGradingDataToRef: hue: obj * density: obj * saturation: obj * exposure: obj * result: obj -> unit
        /// Clones the current color curve instance.
        abstract clone: unit -> ColorCurves
        /// Serializes the current color curve instance to a json representation.
        abstract serialize: unit -> obj option

    /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
    /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
    /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
    /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
    type [<AllowNullLiteral>] ColorCurvesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ColorCurves
        /// <summary>Binds the color curves to the shader.</summary>
        /// <param name="colorCurves">The color curve to bind</param>
        /// <param name="effect">The effect to bind to</param>
        abstract Bind: colorCurves: ColorCurves * effect: Effect * ?positiveUniform: string * ?neutralUniform: string * ?negativeUniform: string -> unit
        /// <summary>Prepare the list of uniforms associated with the ColorCurves effects.</summary>
        /// <param name="uniformsList">The list of uniforms used in the effect</param>
        abstract PrepareUniforms: uniformsList: ResizeArray<string> -> unit
        /// <summary>Takes an input slider value and returns an adjusted value that provides extra control near the centre.</summary>
        /// <param name="value">The input slider value in range [-100,100].</param>
        abstract applyColorGradingSliderNonlinear: value: obj -> unit
        /// <summary>Returns an RGBA Color4 based on Hue, Saturation and Brightness (also referred to as value, HSV).</summary>
        /// <param name="hue">The hue (H) input.</param>
        /// <param name="saturation">The saturation (S) input.</param>
        /// <param name="brightness">The brightness (B) input.</param>
        abstract fromHSBToRef: hue: obj * saturation: obj * brightness: obj * result: obj -> unit
        /// <summary>Returns a value clamped between min and max</summary>
        /// <param name="value">The value to clamp</param>
        /// <param name="min">The minimum of value</param>
        /// <param name="max">The maximum of value</param>
        abstract clamp: value: obj * min: obj * max: obj -> unit
        /// <summary>Parses the color curve from a json representation.</summary>
        /// <param name="source">the JSON source to parse</param>
        abstract Parse: source: obj option -> ColorCurves

    /// EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
    /// (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
    type [<AllowNullLiteral>] EffectFallbacks =
        abstract _defines: obj with get, set
        abstract _currentRank: obj with get, set
        abstract _maxRank: obj with get, set
        abstract _mesh: obj with get, set
        /// Removes the fallback from the bound mesh.
        abstract unBindMesh: unit -> unit
        /// <summary>Adds a fallback on the specified property.</summary>
        /// <param name="rank">The rank of the fallback (Lower ranks will be fallbacked to first)</param>
        /// <param name="define">The name of the define in the shader</param>
        abstract addFallback: rank: float * define: string -> unit
        /// <summary>Sets the mesh to use CPU skinning when needing to fallback.</summary>
        /// <param name="rank">The rank of the fallback (Lower ranks will be fallbacked to first)</param>
        /// <param name="mesh">The mesh to use the fallbacks.</param>
        abstract addCPUSkinningFallback: rank: float * mesh: AbstractMesh -> unit
        /// Checks to see if more fallbacks are still availible.
        abstract isMoreFallbacks: bool
        /// <summary>Removes the defines that shoould be removed when falling back.</summary>
        /// <param name="currentDefines">defines the current define statements for the shader.</param>
        /// <param name="effect">defines the current effect we try to compile</param>
        abstract reduce: currentDefines: string * effect: Effect -> string

    /// EffectFallbacks can be used to add fallbacks (properties to disable) to certain properties when desired to improve performance.
    /// (Eg. Start at high quality with reflection and fog, if fps is low, remove reflection, if still low remove fog)
    type [<AllowNullLiteral>] EffectFallbacksStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EffectFallbacks

    /// Options to be used when creating an effect.
    type [<AllowNullLiteral>] EffectCreationOptions =
        /// Atrributes that will be used in the shader.
        abstract attributes: ResizeArray<string> with get, set
        /// Uniform varible names that will be set in the shader.
        abstract uniformsNames: ResizeArray<string> with get, set
        /// Uniform buffer varible names that will be set in the shader.
        abstract uniformBuffersNames: ResizeArray<string> with get, set
        /// Sampler texture variable names that will be set in the shader.
        abstract samplers: ResizeArray<string> with get, set
        /// Define statements that will be set in the shader.
        abstract defines: obj option with get, set
        /// Possible fallbacks for this effect to improve performance when needed.
        abstract fallbacks: Nullable<EffectFallbacks> with get, set
        /// Callback that will be called when the shader is compiled.
        abstract onCompiled: Nullable<(Effect -> unit)> with get, set
        /// Callback that will be called if an error occurs during shader compilation.
        abstract onError: Nullable<(Effect -> string -> unit)> with get, set
        /// Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})
        abstract indexParameters: obj option with get, set
        /// Max number of lights that can be used in the shader.
        abstract maxSimultaneousLights: float with get, set
        /// See https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/transformFeedbackVaryings
        abstract transformFeedbackVaryings: Nullable<ResizeArray<string>> with get, set

    /// Options to be used when creating an effect.
    type [<AllowNullLiteral>] EffectCreationOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> EffectCreationOptions

    /// Effect containing vertex and fragment shader that can be executed on an object.
    type [<AllowNullLiteral>] Effect =
        /// Name of the effect.
        abstract name: obj option with get, set
        /// String container all the define statements that should be set on the shader.
        abstract defines: string with get, set
        /// Callback that will be called when the shader is compiled.
        abstract onCompiled: Nullable<(Effect -> unit)> with get, set
        /// Callback that will be called if an error occurs during shader compilation.
        abstract onError: Nullable<(Effect -> string -> unit)> with get, set
        /// Callback that will be called when effect is bound.
        abstract onBind: Nullable<(Effect -> unit)> with get, set
        /// Unique ID of the effect.
        abstract uniqueId: float with get, set
        /// Observable that will be called when the shader is compiled.
        abstract onCompileObservable: Observable<Effect> with get, set
        /// Observable that will be called if an error occurs during shader compilation.
        abstract onErrorObservable: Observable<Effect> with get, set
        /// Observable that will be called when effect is bound.
        abstract onBindObservable: Observable<Effect> with get, set
        abstract _uniqueIdSeed: obj with get, set
        abstract _engine: obj with get, set
        abstract _uniformBuffersNames: obj with get, set
        abstract _uniformsNames: obj with get, set
        abstract _samplers: obj with get, set
        abstract _isReady: obj with get, set
        abstract _compilationError: obj with get, set
        abstract _attributesNames: obj with get, set
        abstract _attributes: obj with get, set
        abstract _uniforms: obj with get, set
        /// Key for the effect.
        abstract _key: string with get, set
        abstract _indexParameters: obj with get, set
        abstract _fallbacks: obj with get, set
        abstract _vertexSourceCode: obj with get, set
        abstract _fragmentSourceCode: obj with get, set
        abstract _vertexSourceCodeOverride: obj with get, set
        abstract _fragmentSourceCodeOverride: obj with get, set
        abstract _transformFeedbackVaryings: obj with get, set
        /// Compiled shader to webGL program.
        abstract _program: WebGLProgram with get, set
        abstract _valueCache: obj with get, set
        abstract _baseCache: obj with get, set
        /// Unique key for this effect
        abstract key: string
        /// If the effect has been compiled and prepared.
        abstract isReady: unit -> bool
        /// The engine the effect was initialized with.
        abstract getEngine: unit -> Engine
        /// The compiled webGL program for the effect
        abstract getProgram: unit -> WebGLProgram
        /// The set of names of attribute variables for the shader.
        abstract getAttributesNames: unit -> ResizeArray<string>
        /// <summary>Returns the attribute at the given index.</summary>
        /// <param name="index">The index of the attribute.</param>
        abstract getAttributeLocation: index: float -> float
        /// <summary>Returns the attribute based on the name of the variable.</summary>
        /// <param name="name">of the attribute to look up.</param>
        abstract getAttributeLocationByName: name: string -> float
        /// The number of attributes.
        abstract getAttributesCount: unit -> float
        /// <summary>Gets the index of a uniform variable.</summary>
        /// <param name="uniformName">of the uniform to look up.</param>
        abstract getUniformIndex: uniformName: string -> float
        /// <summary>Returns the attribute based on the name of the variable.</summary>
        /// <param name="uniformName">of the uniform to look up.</param>
        abstract getUniform: uniformName: string -> Nullable<WebGLUniformLocation>
        /// Returns an array of sampler variable names
        abstract getSamplers: unit -> ResizeArray<string>
        /// The error from the last compilation.
        abstract getCompilationError: unit -> string
        /// <summary>Adds a callback to the onCompiled observable and call the callback imediatly if already ready.</summary>
        /// <param name="func">The callback to be used.</param>
        abstract executeWhenCompiled: func: (Effect -> unit) -> unit
        abstract _loadVertexShader: vertex: obj option * callback: (obj option -> unit) -> unit
        abstract _loadFragmentShader: fragment: obj option * callback: (obj option -> unit) -> unit
        abstract _dumpShadersSource: vertexCode: obj * fragmentCode: obj * defines: obj -> unit
        abstract _processShaderConversion: sourceCode: obj * isFragment: obj * callback: obj -> unit
        abstract _processIncludes: sourceCode: obj * callback: obj -> unit
        abstract _processPrecision: source: obj -> unit
        /// <summary>Recompiles the webGL program</summary>
        /// <param name="vertexSourceCode">The source code for the vertex shader.</param>
        /// <param name="fragmentSourceCode">The source code for the fragment shader.</param>
        /// <param name="onCompiled">Callback called when completed.</param>
        /// <param name="onError">Callback called on error.</param>
        abstract _rebuildProgram: vertexSourceCode: string * fragmentSourceCode: string * onCompiled: (WebGLProgram -> unit) * onError: (string -> unit) -> unit
        /// <summary>Gets the uniform locations of the the specified variable names</summary>
        /// <param name="names">THe names of the variables to lookup.</param>
        abstract getSpecificUniformLocations: names: ResizeArray<string> -> ResizeArray<Nullable<WebGLUniformLocation>>
        /// Prepares the effect
        abstract _prepareEffect: unit -> unit
        /// Checks if the effect is supported. (Must be called after compilation)
        abstract isSupported: bool
        /// <summary>Binds a texture to the engine to be used as output of the shader.</summary>
        /// <param name="channel">Name of the output variable.</param>
        /// <param name="texture">Texture to bind.</param>
        abstract _bindTexture: channel: string * texture: InternalTexture -> unit
        /// <summary>Sets a texture on the engine to be used in the shader.</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="texture">Texture to set.</param>
        abstract setTexture: channel: string * texture: Nullable<BaseTexture> -> unit
        /// <summary>Sets a depth stencil texture from a render target on the engine to be used in the shader.</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="texture">Texture to set.</param>
        abstract setDepthStencilTexture: channel: string * texture: Nullable<RenderTargetTexture> -> unit
        /// <summary>Sets an array of textures on the engine to be used in the shader.</summary>
        /// <param name="channel">Name of the variable.</param>
        /// <param name="textures">Textures to set.</param>
        abstract setTextureArray: channel: string * textures: ResizeArray<BaseTexture> -> unit
        /// <summary>Sets a texture to be the input of the specified post process. (To use the output, pass in the next post process in the pipeline)</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="postProcess">Post process to get the input texture from.</param>
        abstract setTextureFromPostProcess: channel: string * postProcess: Nullable<PostProcess> -> unit
        /// <summary>(Warning! setTextureFromPostProcessOutput may be desired instead)
        /// Sets the input texture of the passed in post process to be input of this effect. (To use the output of the passed in post process use setTextureFromPostProcessOutput)</summary>
        /// <param name="channel">Name of the sampler variable.</param>
        /// <param name="postProcess">Post process to get the output texture from.</param>
        abstract setTextureFromPostProcessOutput: channel: string * postProcess: Nullable<PostProcess> -> unit
        abstract _cacheMatrix: uniformName: string * matrix: Matrix -> bool
        abstract _cacheFloat2: uniformName: string * x: float * y: float -> bool
        abstract _cacheFloat3: uniformName: string * x: float * y: float * z: float -> bool
        abstract _cacheFloat4: uniformName: string * x: float * y: float * z: float * w: float -> bool
        /// <summary>Binds a buffer to a uniform.</summary>
        /// <param name="buffer">Buffer to bind.</param>
        /// <param name="name">Name of the uniform variable to bind to.</param>
        abstract bindUniformBuffer: buffer: WebGLBuffer * name: string -> unit
        /// <summary>Binds block to a uniform.</summary>
        /// <param name="blockName">Name of the block to bind.</param>
        /// <param name="index">Index to bind.</param>
        abstract bindUniformBlock: blockName: string * index: float -> unit
        /// <summary>Sets an interger value on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="value">Value to be set.</param>
        abstract setInt: uniformName: string * value: float -> Effect
        /// <summary>Sets an int array on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an int array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray2: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an int array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray3: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an int array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setIntArray4: uniformName: string * array: Int32Array -> Effect
        /// <summary>Sets an float array on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an float array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray2: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an float array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray3: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an float array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setFloatArray4: uniformName: string * array: Float32Array -> Effect
        /// <summary>Sets an array on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets an array 2 on a uniform variable. (Array is specified as single array eg. [1,2,3,4] will result in [[1,2],[3,4]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray2: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets an array 3 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6] will result in [[1,2,3],[4,5,6]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray3: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets an array 4 on a uniform variable. (Array is specified as single array eg. [1,2,3,4,5,6,7,8] will result in [[1,2,3,4],[5,6,7,8]] in the shader)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="array">array to be set.</param>
        abstract setArray4: uniformName: string * array: ResizeArray<float> -> Effect
        /// <summary>Sets matrices on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrices">matrices to be set.</param>
        abstract setMatrices: uniformName: string * matrices: Float32Array -> Effect
        /// <summary>Sets matrix on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrix">matrix to be set.</param>
        abstract setMatrix: uniformName: string * matrix: Matrix -> Effect
        /// <summary>Sets a 3x3 matrix on a uniform variable. (Speicified as [1,2,3,4,5,6,7,8,9] will result in [1,2,3][4,5,6][7,8,9] matrix)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrix">matrix to be set.</param>
        abstract setMatrix3x3: uniformName: string * matrix: Float32Array -> Effect
        /// <summary>Sets a 2x2 matrix on a uniform variable. (Speicified as [1,2,3,4] will result in [1,2][3,4] matrix)</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="matrix">matrix to be set.</param>
        abstract setMatrix2x2: uniformName: string * matrix: Float32Array -> Effect
        /// <summary>Sets a float on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="value">value to be set.</param>
        abstract setFloat: uniformName: string * value: float -> Effect
        /// <summary>Sets a boolean on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="bool">value to be set.</param>
        abstract setBool: uniformName: string * bool: bool -> Effect
        /// <summary>Sets a Vector2 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="vector2">vector2 to be set.</param>
        abstract setVector2: uniformName: string * vector2: Vector2 -> Effect
        /// <summary>Sets a float2 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="x">First float in float2.</param>
        /// <param name="y">Second float in float2.</param>
        abstract setFloat2: uniformName: string * x: float * y: float -> Effect
        /// <summary>Sets a Vector3 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="vector3">Value to be set.</param>
        abstract setVector3: uniformName: string * vector3: Vector3 -> Effect
        /// <summary>Sets a float3 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="x">First float in float3.</param>
        /// <param name="y">Second float in float3.</param>
        /// <param name="z">Third float in float3.</param>
        abstract setFloat3: uniformName: string * x: float * y: float * z: float -> Effect
        /// <summary>Sets a Vector4 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="vector4">Value to be set.</param>
        abstract setVector4: uniformName: string * vector4: Vector4 -> Effect
        /// <summary>Sets a float4 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="x">First float in float4.</param>
        /// <param name="y">Second float in float4.</param>
        /// <param name="z">Third float in float4.</param>
        /// <param name="w">Fourth float in float4.</param>
        abstract setFloat4: uniformName: string * x: float * y: float * z: float * w: float -> Effect
        /// <summary>Sets a Color3 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="color3">Value to be set.</param>
        abstract setColor3: uniformName: string * color3: Color3 -> Effect
        /// <summary>Sets a Color4 on a uniform variable.</summary>
        /// <param name="uniformName">Name of the variable.</param>
        /// <param name="color3">Value to be set.</param>
        /// <param name="alpha">Alpha value to be set.</param>
        abstract setColor4: uniformName: string * color3: Color3 * alpha: float -> Effect
        /// <summary>Sets a Color4 on a uniform variable</summary>
        /// <param name="uniformName">defines the name of the variable</param>
        /// <param name="color4">defines the value to be set</param>
        abstract setDirectColor4: uniformName: string * color4: Color4 -> Effect
        /// Store of each shader (The can be looked up using effect.key)
        abstract ShadersStore: obj with get, set
        /// Store of each included file for a shader (The can be looked up using effect.key)
        abstract IncludesShadersStore: obj with get, set

    /// Effect containing vertex and fragment shader that can be executed on an object.
    type [<AllowNullLiteral>] EffectStatic =
        /// <summary>Instantiates an effect.
        /// An effect can be used to create/manage/execute vertex and fragment shaders.</summary>
        /// <param name="baseName">Name of the effect.</param>
        /// <param name="attributesNamesOrOptions">List of attribute names that will be passed to the shader or set of all options to create the effect.</param>
        /// <param name="uniformsNamesOrEngine">List of uniform variable names that will be passed to the shader or the engine that will be used to render effect.</param>
        /// <param name="samplers">List of sampler variables that will be passed to the shader.</param>
        /// <param name="engine">Engine to be used to render the effect</param>
        /// <param name="defines">Define statements to be added to the shader.</param>
        /// <param name="fallbacks">Possible fallbacks for this effect to improve performance when needed.</param>
        /// <param name="onCompiled">Callback that will be called when the shader is compiled.</param>
        /// <param name="onError">Callback that will be called if an error occurs during shader compilation.</param>
        /// <param name="indexParameters">Parameters to be used with Babylons include syntax to iterate over an array (eg. {lights: 10})</param>
        [<Emit "new $0($1...)">] abstract Create: baseName: obj option * attributesNamesOrOptions: U2<ResizeArray<string>, EffectCreationOptions> * uniformsNamesOrEngine: U2<ResizeArray<string>, Engine> * ?samplers: Nullable<ResizeArray<string>> * ?engine: Engine * ?defines: Nullable<string> * ?fallbacks: Nullable<EffectFallbacks> * ?onCompiled: Nullable<(Effect -> unit)> * ?onError: Nullable<(Effect -> string -> unit)> * ?indexParameters: obj option -> Effect
        /// Resets the cache of effects.
        abstract ResetCache: unit -> unit

    type [<AllowNullLiteral>] FresnelParameters =
        abstract _isEnabled: obj with get, set
        abstract isEnabled: bool with get, set
        abstract leftColor: Color3 with get, set
        abstract rightColor: Color3 with get, set
        abstract bias: float with get, set
        abstract power: float with get, set
        abstract clone: unit -> FresnelParameters
        abstract serialize: unit -> obj option

    type [<AllowNullLiteral>] FresnelParametersStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FresnelParameters
        abstract Parse: parsedFresnelParameters: obj option -> FresnelParameters

    /// Interface to follow in your material defines to integrate easily the
    /// Image proccessing functions.
    type [<AllowNullLiteral>] IImageProcessingConfigurationDefines =
        abstract IMAGEPROCESSING: bool with get, set
        abstract VIGNETTE: bool with get, set
        abstract VIGNETTEBLENDMODEMULTIPLY: bool with get, set
        abstract VIGNETTEBLENDMODEOPAQUE: bool with get, set
        abstract TONEMAPPING: bool with get, set
        abstract CONTRAST: bool with get, set
        abstract EXPOSURE: bool with get, set
        abstract COLORCURVES: bool with get, set
        abstract COLORGRADING: bool with get, set
        abstract COLORGRADING3D: bool with get, set
        abstract SAMPLER3DGREENDEPTH: bool with get, set
        abstract SAMPLER3DBGRMAP: bool with get, set
        abstract IMAGEPROCESSINGPOSTPROCESS: bool with get, set

    /// This groups together the common properties used for image processing either in direct forward pass
    /// or through post processing effect depending on the use of the image processing pipeline in your scene
    /// or not.
    type [<AllowNullLiteral>] ImageProcessingConfiguration =
        /// Color curves setup used in the effect if colorCurvesEnabled is set to true
        abstract colorCurves: Nullable<ColorCurves> with get, set
        abstract _colorCurvesEnabled: obj with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract colorCurvesEnabled: bool with get, set
        /// Color grading LUT texture used in the effect if colorGradingEnabled is set to true
        abstract colorGradingTexture: Nullable<BaseTexture> with get, set
        abstract _colorGradingEnabled: obj with get, set
        /// Gets wether the color grading effect is enabled.
        /// Sets wether the color grading effect is enabled.
        abstract colorGradingEnabled: bool with get, set
        abstract _colorGradingWithGreenDepth: obj with get, set
        /// Gets wether the color grading effect is using a green depth for the 3d Texture.
        /// Sets wether the color grading effect is using a green depth for the 3d Texture.
        abstract colorGradingWithGreenDepth: bool with get, set
        abstract _colorGradingBGR: obj with get, set
        /// Gets wether the color grading texture contains BGR values.
        /// Sets wether the color grading texture contains BGR values.
        abstract colorGradingBGR: bool with get, set
        abstract _exposure: float with get, set
        /// Gets the Exposure used in the effect.
        /// Sets the Exposure used in the effect.
        abstract exposure: float with get, set
        abstract _toneMappingEnabled: obj with get, set
        /// Gets wether the tone mapping effect is enabled.
        /// Sets wether the tone mapping effect is enabled.
        abstract toneMappingEnabled: bool with get, set
        abstract _contrast: float with get, set
        /// Gets the contrast used in the effect.
        /// Sets the contrast used in the effect.
        abstract contrast: float with get, set
        /// Vignette stretch size.
        abstract vignetteStretch: float with get, set
        /// Vignette centre X Offset.
        abstract vignetteCentreX: float with get, set
        /// Vignette centre Y Offset.
        abstract vignetteCentreY: float with get, set
        /// Vignette weight or intensity of the vignette effect.
        abstract vignetteWeight: float with get, set
        /// Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
        /// if vignetteEnabled is set to true.
        abstract vignetteColor: Color4 with get, set
        /// Camera field of view used by the Vignette effect.
        abstract vignetteCameraFov: float with get, set
        abstract _vignetteBlendMode: obj with get, set
        /// Gets the vignette blend mode allowing different kind of effect.
        /// Sets the vignette blend mode allowing different kind of effect.
        abstract vignetteBlendMode: float with get, set
        abstract _vignetteEnabled: obj with get, set
        /// Gets wether the vignette effect is enabled.
        /// Sets wether the vignette effect is enabled.
        abstract vignetteEnabled: bool with get, set
        abstract _applyByPostProcess: obj with get, set
        /// Gets wether the image processing is applied through a post process or not.
        /// Sets wether the image processing is applied through a post process or not.
        abstract applyByPostProcess: bool with get, set
        abstract _isEnabled: obj with get, set
        /// Gets wether the image processing is enabled or not.
        /// Sets wether the image processing is enabled or not.
        abstract isEnabled: bool with get, set
        /// An event triggered when the configuration changes and requires Shader to Update some parameters.
        abstract onUpdateParameters: Observable<ImageProcessingConfiguration> with get, set
        /// Method called each time the image processing information changes requires to recompile the effect.
        abstract _updateParameters: unit -> unit
        abstract getClassName: unit -> string
        /// <summary>Prepare the list of defines associated to the shader.</summary>
        /// <param name="defines">the list of defines to complete</param>
        abstract prepareDefines: defines: IImageProcessingConfigurationDefines * ?forPostProcess: bool -> unit
        /// Returns true if all the image processing information are ready.
        abstract isReady: unit -> bool
        /// <summary>Binds the image processing to the shader.</summary>
        /// <param name="effect">The effect to bind to</param>
        abstract bind: effect: Effect * ?aspectRatio: float -> unit
        /// Clones the current image processing instance.
        abstract clone: unit -> ImageProcessingConfiguration
        /// Serializes the current image processing instance to a json representation.
        abstract serialize: unit -> obj option
        abstract _VIGNETTEMODE_MULTIPLY: obj with get, set
        abstract _VIGNETTEMODE_OPAQUE: obj with get, set
        /// Used to apply the vignette as a mix with the pixel color.
        abstract VIGNETTEMODE_MULTIPLY: float
        /// Used to apply the vignette as a replacement of the pixel color.
        abstract VIGNETTEMODE_OPAQUE: float

    /// This groups together the common properties used for image processing either in direct forward pass
    /// or through post processing effect depending on the use of the image processing pipeline in your scene
    /// or not.
    type [<AllowNullLiteral>] ImageProcessingConfigurationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ImageProcessingConfiguration
        /// <summary>Prepare the list of uniforms associated with the Image Processing effects.</summary>
        /// <param name="defines">the list of defines currently in use</param>
        abstract PrepareUniforms: uniforms: ResizeArray<string> * defines: IImageProcessingConfigurationDefines -> unit
        /// <summary>Prepare the list of samplers associated with the Image Processing effects.</summary>
        /// <param name="defines">the list of defines currently in use</param>
        abstract PrepareSamplers: samplersList: ResizeArray<string> * defines: IImageProcessingConfigurationDefines -> unit
        /// <summary>Parses the image processing from a json representation.</summary>
        /// <param name="source">the JSON source to parse</param>
        abstract Parse: source: obj option -> ImageProcessingConfiguration

    /// Manages the defines for the Material
    type [<AllowNullLiteral>] MaterialDefines =
        abstract _keys: obj with get, set
        abstract _isDirty: obj with get, set
        abstract _renderId: float with get, set
        abstract _areLightsDirty: bool with get, set
        abstract _areAttributesDirty: bool with get, set
        abstract _areTexturesDirty: bool with get, set
        abstract _areFresnelDirty: bool with get, set
        abstract _areMiscDirty: bool with get, set
        abstract _areImageProcessingDirty: bool with get, set
        abstract _normals: bool with get, set
        abstract _uvs: bool with get, set
        abstract _needNormals: bool with get, set
        abstract _needUVs: bool with get, set
        /// Specifies if the material needs to be re-calculated
        abstract isDirty: bool
        /// Marks the material to indicate that it has been re-calculated
        abstract markAsProcessed: unit -> unit
        /// Marks the material to indicate that it needs to be re-calculated
        abstract markAsUnprocessed: unit -> unit
        /// Marks the material to indicate all of its defines need to be re-calculated
        abstract markAllAsDirty: unit -> unit
        /// Marks the material to indicate that image processing needs to be re-calculated
        abstract markAsImageProcessingDirty: unit -> unit
        /// Marks the material to indicate the lights need to be re-calculated
        abstract markAsLightDirty: unit -> unit
        /// Marks the attribute state as changed
        abstract markAsAttributesDirty: unit -> unit
        /// Marks the texture state as changed
        abstract markAsTexturesDirty: unit -> unit
        /// Marks the fresnel state as changed
        abstract markAsFresnelDirty: unit -> unit
        /// Marks the misc state as changed
        abstract markAsMiscDirty: unit -> unit
        /// Rebuilds the material defines
        abstract rebuild: unit -> unit
        /// <summary>Specifies if two material defines are equal</summary>
        /// <param name="other">- A material define instance to compare to</param>
        abstract isEqual: other: MaterialDefines -> bool
        /// <summary>Clones this instance's defines to another instance</summary>
        /// <param name="other">- material defines to clone values to</param>
        abstract cloneTo: other: MaterialDefines -> unit
        /// Resets the material define values
        abstract reset: unit -> unit
        /// Converts the material define values to a string
        abstract toString: unit -> string

    /// Manages the defines for the Material
    type [<AllowNullLiteral>] MaterialDefinesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MaterialDefines

    /// Base class for the main features of a material in Babylon.js
    type [<AllowNullLiteral>] Material =
        inherit IAnimatable
        abstract _TriangleFillMode: obj with get, set
        abstract _WireFrameFillMode: obj with get, set
        abstract _PointFillMode: obj with get, set
        abstract _PointListDrawMode: obj with get, set
        abstract _LineListDrawMode: obj with get, set
        abstract _LineLoopDrawMode: obj with get, set
        abstract _LineStripDrawMode: obj with get, set
        abstract _TriangleStripDrawMode: obj with get, set
        abstract _TriangleFanDrawMode: obj with get, set
        /// Returns the triangle fill mode
        abstract TriangleFillMode: float
        /// Returns the wireframe mode
        abstract WireFrameFillMode: float
        /// Returns the point fill mode
        abstract PointFillMode: float
        /// Returns the point list draw mode
        abstract PointListDrawMode: float
        /// Returns the line list draw mode
        abstract LineListDrawMode: float
        /// Returns the line loop draw mode
        abstract LineLoopDrawMode: float
        /// Returns the line strip draw mode
        abstract LineStripDrawMode: float
        /// Returns the triangle strip draw mode
        abstract TriangleStripDrawMode: float
        /// Returns the triangle fan draw mode
        abstract TriangleFanDrawMode: float
        /// Stores the clock-wise side orientation
        abstract _ClockWiseSideOrientation: obj with get, set
        /// Stores the counter clock-wise side orientation
        abstract _CounterClockWiseSideOrientation: obj with get, set
        /// Returns the clock-wise side orientation
        abstract ClockWiseSideOrientation: float
        /// Returns the counter clock-wise side orientation
        abstract CounterClockWiseSideOrientation: float
        /// The dirty texture flag value
        abstract _TextureDirtyFlag: obj with get, set
        /// The dirty light flag value
        abstract _LightDirtyFlag: obj with get, set
        /// The dirty fresnel flag value
        abstract _FresnelDirtyFlag: obj with get, set
        /// The dirty attribute flag value
        abstract _AttributesDirtyFlag: obj with get, set
        /// The dirty misc flag value
        abstract _MiscDirtyFlag: obj with get, set
        /// Returns the dirty texture flag value
        abstract TextureDirtyFlag: float
        /// Returns the dirty light flag value
        abstract LightDirtyFlag: float
        /// Returns the dirty fresnel flag value
        abstract FresnelDirtyFlag: float
        /// Returns the dirty attributes flag value
        abstract AttributesDirtyFlag: float
        /// Returns the dirty misc flag value
        abstract MiscDirtyFlag: float
        /// The ID of the material
        abstract id: string with get, set
        /// The name of the material
        abstract name: string with get, set
        /// Specifies if the ready state should be checked on each call
        abstract checkReadyOnEveryCall: bool with get, set
        /// Specifies if the ready state should be checked once
        abstract checkReadyOnlyOnce: bool with get, set
        /// The state of the material
        abstract state: string with get, set
        /// The alpha value of the material
        abstract _alpha: float with get, set
        /// Gets the alpha value of the material
        /// Sets the alpha value of the material
        abstract alpha: float with get, set
        /// Specifies if back face culling is enabled
        abstract _backFaceCulling: bool with get, set
        /// Gets the back-face culling state
        /// Sets the back-face culling state
        abstract backFaceCulling: bool with get, set
        /// Stores the value for side orientation
        abstract sideOrientation: float with get, set
        /// Callback triggered when the material is compiled
        abstract onCompiled: (Effect -> unit) with get, set
        /// Callback triggered when an error occurs
        abstract onError: (Effect -> string -> unit) with get, set
        /// Callback triggered to get the render target textures
        abstract getRenderTargetTextures: (unit -> SmartArray<RenderTargetTexture>) with get, set
        /// Specifies if the material should be serialized
        abstract doNotSerialize: bool with get, set
        /// Specifies if the effect should be stored on sub meshes
        abstract storeEffectOnSubMeshes: bool with get, set
        /// Stores the animations for the material
        abstract animations: Array<Animation> with get, set
        /// An event triggered when the material is disposed
        abstract onDisposeObservable: Observable<Material> with get, set
        /// An observer which watches for dispose events
        abstract _onDisposeObserver: obj with get, set
        /// Called during a dispose event
        abstract onDispose: (unit -> unit) with get, set
        /// An event triggered when the material is bound
        abstract onBindObservable: Observable<AbstractMesh> with get, set
        /// An observer which watches for bind events
        abstract _onBindObserver: obj with get, set
        /// Called during a bind event
        abstract onBind: (AbstractMesh -> unit) with get, set
        /// An event triggered when the material is unbound
        abstract onUnBindObservable: Observable<Material> with get, set
        /// Stores the value of the alpha mode
        abstract _alphaMode: obj with get, set
        /// Gets the value of the alpha mode
        /// Sets the value of the alpha mode.
        /// 
        /// | Value | Type | Description |
        /// | --- | --- | --- |
        /// | 0 | ALPHA_DISABLE |   |
        /// | 1 | ALPHA_ADD |   |
        /// | 2 | ALPHA_COMBINE |   |
        /// | 3 | ALPHA_SUBTRACT |   |
        /// | 4 | ALPHA_MULTIPLY |   |
        /// | 5 | ALPHA_MAXIMIZED |   |
        /// | 6 | ALPHA_ONEONE |   |
        /// | 7 | ALPHA_PREMULTIPLIED |   |
        /// | 8 | ALPHA_PREMULTIPLIED_PORTERDUFF |   |
        /// | 9 | ALPHA_INTERPOLATE |   |
        /// | 10 | ALPHA_SCREENMODE |   |
        abstract alphaMode: float with get, set
        /// Stores the state of the need depth pre-pass value
        abstract _needDepthPrePass: obj with get, set
        /// Gets the depth pre-pass value
        /// Sets the need depth pre-pass value
        abstract needDepthPrePass: bool with get, set
        /// Specifies if depth writing should be disabled
        abstract disableDepthWrite: bool with get, set
        /// Specifies if depth writing should be forced
        abstract forceDepthWrite: bool with get, set
        /// Specifies if there should be a separate pass for culling
        abstract separateCullingPass: bool with get, set
        /// Stores the state specifing if fog should be enabled
        abstract _fogEnabled: obj with get, set
        /// Gets the value of the fog enabled state
        /// Sets the state for enabling fog
        abstract fogEnabled: bool with get, set
        /// Stores the size of points
        abstract pointSize: float with get, set
        /// Stores the z offset value
        abstract zOffset: float with get, set
        /// Gets a value specifying if wireframe mode is enabled
        /// Sets the state of wireframe mode
        abstract wireframe: bool with get, set
        /// Gets the value specifying if point clouds are enabled
        /// Sets the state of point cloud mode
        abstract pointsCloud: bool with get, set
        /// Gets the material fill mode
        /// Sets the material fill mode
        abstract fillMode: float with get, set
        /// Stores the effects for the material
        abstract _effect: Nullable<Effect> with get, set
        /// Specifies if the material was previously ready
        abstract _wasPreviouslyReady: bool with get, set
        /// Specifies if uniform buffers should be used
        abstract _useUBO: obj with get, set
        /// Stores a reference to the scene
        abstract _scene: obj with get, set
        /// Stores the fill mode state
        abstract _fillMode: obj with get, set
        /// Specifies if the depth write state should be cached
        abstract _cachedDepthWriteState: obj with get, set
        /// Stores the uniform buffer
        abstract _uniformBuffer: UniformBuffer with get, set
        /// <summary>Returns a string representation of the current material</summary>
        /// <param name="fullDetails">defines a boolean indicating which levels of logging is desired</param>
        abstract toString: ?fullDetails: bool -> string
        /// Gets the class name of the material
        abstract getClassName: unit -> string
        /// Specifies if updates for the material been locked
        abstract isFrozen: bool
        /// Locks updates for the material
        abstract freeze: unit -> unit
        /// Unlocks updates for the material
        abstract unfreeze: unit -> unit
        /// <summary>Specifies if the material is ready to be used</summary>
        /// <param name="mesh">defines the mesh to check</param>
        /// <param name="useInstances">specifies if instances should be used</param>
        abstract isReady: ?mesh: AbstractMesh * ?useInstances: bool -> bool
        /// <summary>Specifies that the submesh is ready to be used</summary>
        /// <param name="mesh">defines the mesh to check</param>
        /// <param name="subMesh">defines which submesh to check</param>
        /// <param name="useInstances">specifies that instances should be used</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: BaseSubMesh * ?useInstances: bool -> bool
        /// Returns the material effect
        abstract getEffect: unit -> Nullable<Effect>
        /// Returns the current scene
        abstract getScene: unit -> Scene
        /// Specifies if the material will require alpha blending
        abstract needAlphaBlending: unit -> bool
        /// <summary>Specifies if the mesh will require alpha blending</summary>
        /// <param name="mesh">defines the mesh to check</param>
        abstract needAlphaBlendingForMesh: mesh: AbstractMesh -> bool
        /// Specifies if this material should be rendered in alpha test mode
        abstract needAlphaTesting: unit -> bool
        /// Gets the texture used for the alpha test
        abstract getAlphaTestTexture: unit -> Nullable<BaseTexture>
        /// Marks the material to indicate that it needs to be re-calculated
        abstract markDirty: unit -> unit
        abstract _preBind: ?effect: Effect * ?overrideOrientation: Nullable<float> -> bool
        /// <summary>Binds the material to the mesh</summary>
        /// <param name="world">defines the world transformation matrix</param>
        /// <param name="mesh">defines the mesh to bind the material to</param>
        abstract bind: world: Matrix * ?mesh: Mesh -> unit
        /// <summary>Binds the submesh to the material</summary>
        /// <param name="world">defines the world transformation matrix</param>
        /// <param name="mesh">defines the mesh containing the submesh</param>
        /// <param name="subMesh">defines the submesh to bind the material to</param>
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        /// <summary>Binds the world matrix to the material</summary>
        /// <param name="world">defines the world transformation matrix</param>
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        /// <summary>Binds the scene's uniform buffer to the effect.</summary>
        /// <param name="effect">defines the effect to bind to the scene uniform buffer</param>
        /// <param name="sceneUbo">defines the uniform buffer storing scene data</param>
        abstract bindSceneUniformBuffer: effect: Effect * sceneUbo: UniformBuffer -> unit
        /// <summary>Binds the view matrix to the effect</summary>
        /// <param name="effect">defines the effect to bind the view matrix to</param>
        abstract bindView: effect: Effect -> unit
        /// <summary>Binds the view projection matrix to the effect</summary>
        /// <param name="effect">defines the effect to bind the view projection matrix to</param>
        abstract bindViewProjection: effect: Effect -> unit
        /// <summary>Specifies if material alpha testing should be turned on for the mesh</summary>
        /// <param name="mesh">defines the mesh to check</param>
        abstract _shouldTurnAlphaTestOn: mesh: AbstractMesh -> bool
        /// <summary>Processes to execute after binding the material to a mesh</summary>
        /// <param name="mesh">defines the rendered mesh</param>
        abstract _afterBind: ?mesh: Mesh -> unit
        /// Unbinds the material from the mesh
        abstract unbind: unit -> unit
        /// Gets the active textures from the material
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Specifies if the material uses a texture</summary>
        /// <param name="texture">defines the texture to check against the material</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the material, and gives it a new name</summary>
        /// <param name="name">defines the new name for the duplicated material</param>
        abstract clone: name: string -> Nullable<Material>
        /// Gets the meshes bound to the material
        abstract getBindedMeshes: unit -> ResizeArray<AbstractMesh>
        /// <summary>Force shader compilation</summary>
        /// <param name="mesh">defines the mesh associated with this material</param>
        /// <param name="onCompiled">defines a function to execute once the material is compiled</param>
        /// <param name="options">defines the options to configure the compilation</param>
        abstract forceCompilation: mesh: AbstractMesh * ?onCompiled: (Material -> unit) * ?options: obj -> unit
        /// <summary>Force shader compilation</summary>
        /// <param name="mesh">defines the mesh that will use this material</param>
        /// <param name="options">defines additional options for compiling the shaders</param>
        abstract forceCompilationAsync: mesh: AbstractMesh * ?options: obj -> Promise<unit>
        /// <summary>Marks a define in the material to indicate that it needs to be re-computed</summary>
        /// <param name="flag">defines a flag used to determine which parts of the material have to be marked as dirty</param>
        abstract markAsDirty: flag: float -> unit
        /// <summary>Marks all submeshes of a material to indicate that their material defines need to be re-calculated</summary>
        /// <param name="func">defines a function which checks material defines against the submeshes</param>
        abstract _markAllSubMeshesAsDirty: func: (MaterialDefines -> unit) -> unit
        /// Indicates that image processing needs to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsImageProcessingDirty: unit -> unit
        /// Indicates that textures need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsTexturesDirty: unit -> unit
        /// Indicates that fresnel needs to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsFresnelDirty: unit -> unit
        /// Indicates that fresnel and misc need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsFresnelAndMiscDirty: unit -> unit
        /// Indicates that lights need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsLightsDirty: unit -> unit
        /// Indicates that attributes need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsAttributesDirty: unit -> unit
        /// Indicates that misc needs to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsMiscDirty: unit -> unit
        /// Indicates that textures and misc need to be re-calculated for all submeshes
        abstract _markAllSubMeshesAsTexturesAndMiscDirty: unit -> unit
        /// <summary>Disposes the material</summary>
        /// <param name="forceDisposeEffect">specifies if effects should be forcefully disposed</param>
        /// <param name="forceDisposeTextures">specifies if textures should be forcefully disposed</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        /// Serializes this material
        abstract serialize: unit -> obj option

    /// Base class for the main features of a material in Babylon.js
    type [<AllowNullLiteral>] MaterialStatic =
        /// <summary>Creates a material instance</summary>
        /// <param name="name">defines the name of the material</param>
        /// <param name="scene">defines the scene to reference</param>
        /// <param name="doNotAdd">specifies if the material should be added to the scene</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?doNotAdd: bool -> Material
        /// <summary>Creates a MultiMaterial from parsed MultiMaterial data.</summary>
        /// <param name="parsedMultiMaterial">defines parsed MultiMaterial data.</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ParseMultiMaterial: parsedMultiMaterial: obj option * scene: Scene -> MultiMaterial
        /// <summary>Creates a material from parsed material data</summary>
        /// <param name="parsedMaterial">defines parsed material data</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root URL to use to load textures</param>
        abstract Parse: parsedMaterial: obj option * scene: Scene * rootUrl: string -> obj option

    /// "Static Class" containing the most commonly used helper while dealing with material for
    /// rendering purpose.
    /// 
    /// It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
    /// 
    /// This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
    type [<AllowNullLiteral>] MaterialHelper =
        interface end

    /// "Static Class" containing the most commonly used helper while dealing with material for
    /// rendering purpose.
    /// 
    /// It contains the basic tools to help defining defines, binding uniform for the common part of the materials.
    /// 
    /// This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.
    type [<AllowNullLiteral>] MaterialHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MaterialHelper
        /// <summary>Bind the current view position to an effect.</summary>
        /// <param name="effect">The effect to be bound</param>
        /// <param name="scene">The scene the eyes position is used from</param>
        abstract BindEyePosition: effect: Effect * scene: Scene -> unit
        /// <summary>Helps preparing the defines values about the UVs in used in the effect.
        /// UVs are shared as much as we can accross chanels in the shaders.</summary>
        /// <param name="texture">The texture we are preparing the UVs for</param>
        /// <param name="defines">The defines to update</param>
        /// <param name="key">The chanel key "diffuse", "specular"... used in the shader</param>
        abstract PrepareDefinesForMergedUV: texture: BaseTexture * defines: obj option * key: string -> unit
        /// <summary>Binds a texture matrix value to its corrsponding uniform</summary>
        /// <param name="texture">The texture to bind the matrix for</param>
        /// <param name="uniformBuffer">The uniform buffer receivin the data</param>
        /// <param name="key">The chanel key "diffuse", "specular"... used in the shader</param>
        abstract BindTextureMatrix: texture: BaseTexture * uniformBuffer: UniformBuffer * key: string -> unit
        /// <summary>Helper used to prepare the list of defines associated with misc. values for shader compilation</summary>
        /// <param name="mesh">defines the current mesh</param>
        /// <param name="scene">defines the current scene</param>
        /// <param name="useLogarithmicDepth">defines if logarithmic depth has to be turned on</param>
        /// <param name="pointsCloud">defines if point cloud rendering has to be turned on</param>
        /// <param name="fogEnabled">defines if fog has to be turned on</param>
        /// <param name="alphaTest">defines if alpha testing has to be turned on</param>
        /// <param name="defines">defines the current list of defines</param>
        abstract PrepareDefinesForMisc: mesh: AbstractMesh * scene: Scene * useLogarithmicDepth: bool * pointsCloud: bool * fogEnabled: bool * alphaTest: bool * defines: obj option -> unit
        /// <summary>Helper used to prepare the list of defines associated with frame values for shader compilation</summary>
        /// <param name="scene">defines the current scene</param>
        /// <param name="engine">defines the current engine</param>
        /// <param name="defines">specifies the list of active defines</param>
        /// <param name="useInstances">defines if instances have to be turned on</param>
        /// <param name="useClipPlane">defines if clip plane have to be turned on</param>
        abstract PrepareDefinesForFrameBoundValues: scene: Scene * engine: Engine * defines: obj option * useInstances: bool * ?useClipPlane: Nullable<bool> -> unit
        /// <summary>Prepares the defines used in the shader depending on the attributes data available in the mesh</summary>
        /// <param name="mesh">The mesh containing the geometry data we will draw</param>
        /// <param name="defines">The defines to update</param>
        /// <param name="useVertexColor">Precise whether vertex colors should be used or not (override mesh info)</param>
        /// <param name="useBones">Precise whether bones should be used or not (override mesh info)</param>
        /// <param name="useMorphTargets">Precise whether morph targets should be used or not (override mesh info)</param>
        /// <param name="useVertexAlpha">Precise whether vertex alpha should be used or not (override mesh info)</param>
        abstract PrepareDefinesForAttributes: mesh: AbstractMesh * defines: obj option * useVertexColor: bool * useBones: bool * ?useMorphTargets: bool * ?useVertexAlpha: bool -> bool
        /// <summary>Prepares the defines related to the light information passed in parameter</summary>
        /// <param name="scene">The scene we are intending to draw</param>
        /// <param name="mesh">The mesh the effect is compiling for</param>
        /// <param name="defines">The defines to update</param>
        /// <param name="specularSupported">Specifies whether specular is supported or not (override lights data)</param>
        /// <param name="maxSimultaneousLights">Specfies how manuy lights can be added to the effect at max</param>
        /// <param name="disableLighting">Specifies whether the lighting is disabled (override scene and light)</param>
        abstract PrepareDefinesForLights: scene: Scene * mesh: AbstractMesh * defines: obj option * specularSupported: bool * ?maxSimultaneousLights: float * ?disableLighting: bool -> bool
        /// <summary>Prepares the uniforms and samplers list to be used in the effect. This can automatically remove from the list uniforms
        /// that won t be acctive due to defines being turned off.</summary>
        /// <param name="uniformsListOrOptions">The uniform names to prepare or an EffectCreationOptions containing the liist and extra information</param>
        /// <param name="samplersList">The samplers list</param>
        /// <param name="defines">The defines helping in the list generation</param>
        /// <param name="maxSimultaneousLights">The maximum number of simultanous light allowed in the effect</param>
        abstract PrepareUniformsAndSamplersList: uniformsListOrOptions: U2<ResizeArray<string>, EffectCreationOptions> * ?samplersList: ResizeArray<string> * ?defines: obj option * ?maxSimultaneousLights: float -> unit
        /// <summary>This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)</summary>
        /// <param name="defines">The defines to update while falling back</param>
        /// <param name="fallbacks">The authorized effect fallbacks</param>
        /// <param name="maxSimultaneousLights">The maximum number of lights allowed</param>
        /// <param name="rank">the current rank of the Effect</param>
        abstract HandleFallbacksForShadows: defines: obj option * fallbacks: EffectFallbacks * ?maxSimultaneousLights: float * ?rank: float -> float
        /// <summary>Prepares the list of attributes required for morph targets according to the effect defines.</summary>
        /// <param name="attribs">The current list of supported attribs</param>
        /// <param name="mesh">The mesh to prepare the morph targets attributes for</param>
        /// <param name="defines">The current Defines of the effect</param>
        abstract PrepareAttributesForMorphTargets: attribs: ResizeArray<string> * mesh: AbstractMesh * defines: obj option -> unit
        /// <summary>Prepares the list of attributes required for bones according to the effect defines.</summary>
        /// <param name="attribs">The current list of supported attribs</param>
        /// <param name="mesh">The mesh to prepare the bones attributes for</param>
        /// <param name="defines">The current Defines of the effect</param>
        /// <param name="fallbacks">The current efffect fallback strategy</param>
        abstract PrepareAttributesForBones: attribs: ResizeArray<string> * mesh: AbstractMesh * defines: obj option * fallbacks: EffectFallbacks -> unit
        /// <summary>Prepares the list of attributes required for instances according to the effect defines.</summary>
        /// <param name="attribs">The current list of supported attribs</param>
        /// <param name="defines">The current Defines of the effect</param>
        abstract PrepareAttributesForInstances: attribs: ResizeArray<string> * defines: obj option -> unit
        /// <summary>Binds the light shadow information to the effect for the given mesh.</summary>
        /// <param name="light">The light containing the generator</param>
        /// <param name="scene">The scene the lights belongs to</param>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="lightIndex">The light index in the effect used to render the mesh</param>
        /// <param name="effect">The effect we are binding the data to</param>
        abstract BindLightShadow: light: Light * scene: Scene * mesh: AbstractMesh * lightIndex: string * effect: Effect -> unit
        /// <summary>Binds the light information to the effect.</summary>
        /// <param name="light">The light containing the generator</param>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="lightIndex">The light index in the effect used to render</param>
        abstract BindLightProperties: light: Light * effect: Effect * lightIndex: float -> unit
        /// <summary>Binds the lights information from the scene to the effect for the given mesh.</summary>
        /// <param name="scene">The scene the lights belongs to</param>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="defines">The generated defines for the effect</param>
        /// <param name="maxSimultaneousLights">The maximum number of light that can be bound to the effect</param>
        /// <param name="usePhysicalLightFalloff">Specifies whether the light falloff is defined physically or not</param>
        abstract BindLights: scene: Scene * mesh: AbstractMesh * effect: Effect * defines: obj option * ?maxSimultaneousLights: float * ?usePhysicalLightFalloff: bool -> unit
        /// <summary>Binds the fog information from the scene to the effect for the given mesh.</summary>
        /// <param name="scene">The scene the lights belongs to</param>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        abstract BindFogParameters: scene: Scene * mesh: AbstractMesh * effect: Effect -> unit
        /// <summary>Binds the bones information from the mesh to the effect.</summary>
        /// <param name="mesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        abstract BindBonesParameters: ?mesh: AbstractMesh * ?effect: Effect -> unit
        /// <summary>Binds the morph targets information from the mesh to the effect.</summary>
        /// <param name="abstractMesh">The mesh we are binding the information to render</param>
        /// <param name="effect">The effect we are binding the data to</param>
        abstract BindMorphTargetParameters: abstractMesh: AbstractMesh * effect: Effect -> unit
        /// <summary>Binds the logarithmic depth information from the scene to the effect for the given defines.</summary>
        /// <param name="defines">The generated defines used in the effect</param>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="scene">The scene we are willing to render with logarithmic scale for</param>
        abstract BindLogDepth: defines: obj option * effect: Effect * scene: Scene -> unit
        /// <summary>Binds the clip plane information from the scene to the effect.</summary>
        /// <param name="effect">The effect we are binding the data to</param>
        /// <param name="scene">The scene the clip plane information are extracted from</param>
        abstract BindClipPlane: effect: Effect * scene: Scene -> unit

    type [<AllowNullLiteral>] MultiMaterial =
        inherit Material
        abstract _subMaterials: obj with get, set
        abstract subMaterials: ResizeArray<Nullable<Material>> with get, set
        abstract _hookArray: array: obj -> unit
        abstract getSubMaterial: index: float -> Nullable<Material>
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        abstract getClassName: unit -> string
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: BaseSubMesh * ?useInstances: bool -> bool
        abstract clone: name: string * ?cloneChildren: bool -> MultiMaterial
        abstract serialize: unit -> obj option
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit

    type [<AllowNullLiteral>] MultiMaterialStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> MultiMaterial

    type [<AllowNullLiteral>] PushMaterial =
        inherit Material
        abstract _activeEffect: Effect with get, set
        abstract _normalMatrix: Matrix with get, set
        abstract getEffect: unit -> Effect
        abstract isReady: ?mesh: AbstractMesh * ?useInstances: bool -> bool
        /// <summary>Binds the given world matrix to the active effect</summary>
        /// <param name="world">the matrix to bind</param>
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        /// <summary>Binds the given normal matrix to the active effect</summary>
        /// <param name="normalMatrix">the matrix to bind</param>
        abstract bindOnlyNormalMatrix: normalMatrix: Matrix -> unit
        abstract bind: world: Matrix * ?mesh: Mesh -> unit
        abstract _afterBind: mesh: Mesh * ?effect: Nullable<Effect> -> unit
        abstract _mustRebind: scene: Scene * effect: Effect * ?visibility: float -> bool

    type [<AllowNullLiteral>] PushMaterialStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PushMaterial

    type [<AllowNullLiteral>] ShaderMaterial =
        inherit Material
        abstract _shaderPath: obj with get, set
        abstract _options: obj with get, set
        abstract _textures: obj with get, set
        abstract _textureArrays: obj with get, set
        abstract _floats: obj with get, set
        abstract _ints: obj with get, set
        abstract _floatsArrays: obj with get, set
        abstract _colors3: obj with get, set
        abstract _colors3Arrays: obj with get, set
        abstract _colors4: obj with get, set
        abstract _vectors2: obj with get, set
        abstract _vectors3: obj with get, set
        abstract _vectors4: obj with get, set
        abstract _matrices: obj with get, set
        abstract _matrices3x3: obj with get, set
        abstract _matrices2x2: obj with get, set
        abstract _vectors2Arrays: obj with get, set
        abstract _vectors3Arrays: obj with get, set
        abstract _cachedWorldViewMatrix: obj with get, set
        abstract _renderId: obj with get, set
        abstract getClassName: unit -> string
        abstract needAlphaBlending: unit -> bool
        abstract needAlphaTesting: unit -> bool
        abstract _checkUniform: uniformName: obj -> unit
        abstract setTexture: name: string * texture: Texture -> ShaderMaterial
        abstract setTextureArray: name: string * textures: ResizeArray<Texture> -> ShaderMaterial
        abstract setFloat: name: string * value: float -> ShaderMaterial
        abstract setInt: name: string * value: float -> ShaderMaterial
        abstract setFloats: name: string * value: ResizeArray<float> -> ShaderMaterial
        abstract setColor3: name: string * value: Color3 -> ShaderMaterial
        abstract setColor3Array: name: string * value: ResizeArray<Color3> -> ShaderMaterial
        abstract setColor4: name: string * value: Color4 -> ShaderMaterial
        abstract setVector2: name: string * value: Vector2 -> ShaderMaterial
        abstract setVector3: name: string * value: Vector3 -> ShaderMaterial
        abstract setVector4: name: string * value: Vector4 -> ShaderMaterial
        abstract setMatrix: name: string * value: Matrix -> ShaderMaterial
        abstract setMatrix3x3: name: string * value: Float32Array -> ShaderMaterial
        abstract setMatrix2x2: name: string * value: Float32Array -> ShaderMaterial
        abstract setArray2: name: string * value: ResizeArray<float> -> ShaderMaterial
        abstract setArray3: name: string * value: ResizeArray<float> -> ShaderMaterial
        abstract _checkCache: scene: obj * ?mesh: obj * ?useInstances: obj -> unit
        abstract isReady: ?mesh: AbstractMesh * ?useInstances: bool -> bool
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        abstract bind: world: Matrix * ?mesh: Mesh -> unit
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        abstract hasTexture: texture: BaseTexture -> bool
        abstract clone: name: string -> ShaderMaterial
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        abstract serialize: unit -> obj option

    type [<AllowNullLiteral>] ShaderMaterialStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * shaderPath: obj option * options: obj option -> ShaderMaterial
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> ShaderMaterial

    type [<AllowNullLiteral>] StandardMaterialDefines =
        inherit MaterialDefines
        inherit IImageProcessingConfigurationDefines
        abstract MAINUV1: bool with get, set
        abstract MAINUV2: bool with get, set
        abstract DIFFUSE: bool with get, set
        abstract DIFFUSEDIRECTUV: float with get, set
        abstract AMBIENT: bool with get, set
        abstract AMBIENTDIRECTUV: float with get, set
        abstract OPACITY: bool with get, set
        abstract OPACITYDIRECTUV: float with get, set
        abstract OPACITYRGB: bool with get, set
        abstract REFLECTION: bool with get, set
        abstract EMISSIVE: bool with get, set
        abstract EMISSIVEDIRECTUV: float with get, set
        abstract SPECULAR: bool with get, set
        abstract SPECULARDIRECTUV: float with get, set
        abstract BUMP: bool with get, set
        abstract BUMPDIRECTUV: float with get, set
        abstract PARALLAX: bool with get, set
        abstract PARALLAXOCCLUSION: bool with get, set
        abstract SPECULAROVERALPHA: bool with get, set
        abstract CLIPPLANE: bool with get, set
        abstract ALPHATEST: bool with get, set
        abstract DEPTHPREPASS: bool with get, set
        abstract ALPHAFROMDIFFUSE: bool with get, set
        abstract POINTSIZE: bool with get, set
        abstract FOG: bool with get, set
        abstract SPECULARTERM: bool with get, set
        abstract DIFFUSEFRESNEL: bool with get, set
        abstract OPACITYFRESNEL: bool with get, set
        abstract REFLECTIONFRESNEL: bool with get, set
        abstract REFRACTIONFRESNEL: bool with get, set
        abstract EMISSIVEFRESNEL: bool with get, set
        abstract FRESNEL: bool with get, set
        abstract NORMAL: bool with get, set
        abstract UV1: bool with get, set
        abstract UV2: bool with get, set
        abstract VERTEXCOLOR: bool with get, set
        abstract VERTEXALPHA: bool with get, set
        abstract NUM_BONE_INFLUENCERS: float with get, set
        abstract BonesPerMesh: float with get, set
        abstract INSTANCES: bool with get, set
        abstract GLOSSINESS: bool with get, set
        abstract ROUGHNESS: bool with get, set
        abstract EMISSIVEASILLUMINATION: bool with get, set
        abstract LINKEMISSIVEWITHDIFFUSE: bool with get, set
        abstract REFLECTIONFRESNELFROMSPECULAR: bool with get, set
        abstract LIGHTMAP: bool with get, set
        abstract LIGHTMAPDIRECTUV: float with get, set
        abstract OBJECTSPACE_NORMALMAP: bool with get, set
        abstract USELIGHTMAPASSHADOWMAP: bool with get, set
        abstract REFLECTIONMAP_3D: bool with get, set
        abstract REFLECTIONMAP_SPHERICAL: bool with get, set
        abstract REFLECTIONMAP_PLANAR: bool with get, set
        abstract REFLECTIONMAP_CUBIC: bool with get, set
        abstract USE_LOCAL_REFLECTIONMAP_CUBIC: bool with get, set
        abstract REFLECTIONMAP_PROJECTION: bool with get, set
        abstract REFLECTIONMAP_SKYBOX: bool with get, set
        abstract REFLECTIONMAP_EXPLICIT: bool with get, set
        abstract REFLECTIONMAP_EQUIRECTANGULAR: bool with get, set
        abstract REFLECTIONMAP_EQUIRECTANGULAR_FIXED: bool with get, set
        abstract REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED: bool with get, set
        abstract INVERTCUBICMAP: bool with get, set
        abstract LOGARITHMICDEPTH: bool with get, set
        abstract REFRACTION: bool with get, set
        abstract REFRACTIONMAP_3D: bool with get, set
        abstract REFLECTIONOVERALPHA: bool with get, set
        abstract TWOSIDEDLIGHTING: bool with get, set
        abstract SHADOWFLOAT: bool with get, set
        abstract MORPHTARGETS: bool with get, set
        abstract MORPHTARGETS_NORMAL: bool with get, set
        abstract MORPHTARGETS_TANGENT: bool with get, set
        abstract NUM_MORPH_INFLUENCERS: float with get, set
        abstract NONUNIFORMSCALING: bool with get, set
        abstract PREMULTIPLYALPHA: bool with get, set
        abstract IMAGEPROCESSING: bool with get, set
        abstract VIGNETTE: bool with get, set
        abstract VIGNETTEBLENDMODEMULTIPLY: bool with get, set
        abstract VIGNETTEBLENDMODEOPAQUE: bool with get, set
        abstract TONEMAPPING: bool with get, set
        abstract CONTRAST: bool with get, set
        abstract COLORCURVES: bool with get, set
        abstract COLORGRADING: bool with get, set
        abstract COLORGRADING3D: bool with get, set
        abstract SAMPLER3DGREENDEPTH: bool with get, set
        abstract SAMPLER3DBGRMAP: bool with get, set
        abstract IMAGEPROCESSINGPOSTPROCESS: bool with get, set
        /// If the reflection texture on this material is in linear color space
        abstract IS_REFLECTION_LINEAR: bool with get, set
        /// If the refraction texture on this material is in linear color space
        abstract IS_REFRACTION_LINEAR: bool with get, set
        abstract EXPOSURE: bool with get, set
        abstract setReflectionMode: modeToEnable: string -> unit

    type [<AllowNullLiteral>] StandardMaterialDefinesStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> StandardMaterialDefines

    type [<AllowNullLiteral>] StandardMaterial =
        inherit PushMaterial
        abstract _diffuseTexture: obj with get, set
        abstract diffuseTexture: Nullable<BaseTexture> with get, set
        abstract _ambientTexture: obj with get, set
        abstract ambientTexture: Nullable<BaseTexture> with get, set
        abstract _opacityTexture: obj with get, set
        abstract opacityTexture: Nullable<BaseTexture> with get, set
        abstract _reflectionTexture: obj with get, set
        abstract reflectionTexture: Nullable<BaseTexture> with get, set
        abstract _emissiveTexture: obj with get, set
        abstract emissiveTexture: Nullable<BaseTexture> with get, set
        abstract _specularTexture: obj with get, set
        abstract specularTexture: Nullable<BaseTexture> with get, set
        abstract _bumpTexture: obj with get, set
        abstract bumpTexture: Nullable<BaseTexture> with get, set
        abstract _lightmapTexture: obj with get, set
        abstract lightmapTexture: Nullable<BaseTexture> with get, set
        abstract _refractionTexture: obj with get, set
        abstract refractionTexture: Nullable<BaseTexture> with get, set
        abstract ambientColor: Color3 with get, set
        abstract diffuseColor: Color3 with get, set
        abstract specularColor: Color3 with get, set
        abstract emissiveColor: Color3 with get, set
        abstract specularPower: float with get, set
        abstract _useAlphaFromDiffuseTexture: obj with get, set
        abstract useAlphaFromDiffuseTexture: bool with get, set
        abstract _useEmissiveAsIllumination: obj with get, set
        abstract useEmissiveAsIllumination: bool with get, set
        abstract _linkEmissiveWithDiffuse: obj with get, set
        abstract linkEmissiveWithDiffuse: bool with get, set
        abstract _useSpecularOverAlpha: obj with get, set
        abstract useSpecularOverAlpha: bool with get, set
        abstract _useReflectionOverAlpha: obj with get, set
        abstract useReflectionOverAlpha: bool with get, set
        abstract _disableLighting: obj with get, set
        abstract disableLighting: bool with get, set
        abstract _useObjectSpaceNormalMap: obj with get, set
        /// Allows using an object space normal map (instead of tangent space).
        abstract useObjectSpaceNormalMap: bool with get, set
        abstract _useParallax: obj with get, set
        abstract useParallax: bool with get, set
        abstract _useParallaxOcclusion: obj with get, set
        abstract useParallaxOcclusion: bool with get, set
        abstract parallaxScaleBias: float with get, set
        abstract _roughness: obj with get, set
        abstract roughness: float with get, set
        abstract indexOfRefraction: float with get, set
        abstract invertRefractionY: bool with get, set
        abstract _useLightmapAsShadowmap: obj with get, set
        abstract useLightmapAsShadowmap: bool with get, set
        abstract _diffuseFresnelParameters: obj with get, set
        abstract diffuseFresnelParameters: FresnelParameters with get, set
        abstract _opacityFresnelParameters: obj with get, set
        abstract opacityFresnelParameters: FresnelParameters with get, set
        abstract _reflectionFresnelParameters: obj with get, set
        abstract reflectionFresnelParameters: FresnelParameters with get, set
        abstract _refractionFresnelParameters: obj with get, set
        abstract refractionFresnelParameters: FresnelParameters with get, set
        abstract _emissiveFresnelParameters: obj with get, set
        abstract emissiveFresnelParameters: FresnelParameters with get, set
        abstract _useReflectionFresnelFromSpecular: obj with get, set
        abstract useReflectionFresnelFromSpecular: bool with get, set
        abstract _useGlossinessFromSpecularMapAlpha: obj with get, set
        abstract useGlossinessFromSpecularMapAlpha: bool with get, set
        abstract _maxSimultaneousLights: obj with get, set
        abstract maxSimultaneousLights: float with get, set
        /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
        abstract _invertNormalMapX: obj with get, set
        abstract invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
        abstract _invertNormalMapY: obj with get, set
        abstract invertNormalMapY: bool with get, set
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract _twoSidedLighting: obj with get, set
        abstract twoSidedLighting: bool with get, set
        /// Default configuration related to image processing available in the standard Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Keep track of the image processing observer to allow dispose and replace.
        abstract _imageProcessingObserver: obj with get, set
        /// <summary>Attaches a new image processing configuration to the Standard Material.</summary>
        /// <param name="configuration"></param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> -> unit
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract cameraColorCurvesEnabled: bool with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract cameraColorGradingEnabled: bool with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract cameraToneMappingEnabled: bool with get, set
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        abstract cameraExposure: float with get, set
        /// Gets The camera contrast used on this material.
        /// Sets The camera contrast used on this material.
        abstract cameraContrast: float with get, set
        /// Gets the Color Grading 2D Lookup Texture.
        /// Sets the Color Grading 2D Lookup Texture.
        abstract cameraColorGradingTexture: Nullable<BaseTexture> with get, set
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        abstract cameraColorCurves: Nullable<ColorCurves> with get, set
        abstract customShaderNameResolve: (string -> ResizeArray<string> -> ResizeArray<string> -> ResizeArray<string> -> StandardMaterialDefines -> string) with get, set
        abstract _renderTargets: SmartArray<RenderTargetTexture> with get, set
        abstract _worldViewProjectionMatrix: Matrix with get, set
        abstract _globalAmbientColor: Color3 with get, set
        abstract _useLogarithmicDepth: bool with get, set
        abstract getClassName: unit -> string
        abstract useLogarithmicDepth: bool with get, set
        abstract needAlphaBlending: unit -> bool
        abstract needAlphaTesting: unit -> bool
        abstract _shouldUseAlphaFromDiffuseTexture: unit -> bool
        abstract getAlphaTestTexture: unit -> Nullable<BaseTexture>
        /// Child classes can use it to update shaders
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: SubMesh * ?useInstances: bool -> bool
        abstract buildUniformLayout: unit -> unit
        abstract unbind: unit -> unit
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        abstract hasTexture: texture: BaseTexture -> bool
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        abstract clone: name: string -> StandardMaterial
        abstract serialize: unit -> obj option
        abstract _DiffuseTextureEnabled: bool with get, set
        abstract DiffuseTextureEnabled: bool with get, set
        abstract _AmbientTextureEnabled: bool with get, set
        abstract AmbientTextureEnabled: bool with get, set
        abstract _OpacityTextureEnabled: bool with get, set
        abstract OpacityTextureEnabled: bool with get, set
        abstract _ReflectionTextureEnabled: bool with get, set
        abstract ReflectionTextureEnabled: bool with get, set
        abstract _EmissiveTextureEnabled: bool with get, set
        abstract EmissiveTextureEnabled: bool with get, set
        abstract _SpecularTextureEnabled: bool with get, set
        abstract SpecularTextureEnabled: bool with get, set
        abstract _BumpTextureEnabled: bool with get, set
        abstract BumpTextureEnabled: bool with get, set
        abstract _LightmapTextureEnabled: bool with get, set
        abstract LightmapTextureEnabled: bool with get, set
        abstract _RefractionTextureEnabled: bool with get, set
        abstract RefractionTextureEnabled: bool with get, set
        abstract _ColorGradingTextureEnabled: bool with get, set
        abstract ColorGradingTextureEnabled: bool with get, set
        abstract _FresnelEnabled: bool with get, set
        abstract FresnelEnabled: bool with get, set

    type [<AllowNullLiteral>] StandardMaterialStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> StandardMaterial
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> StandardMaterial

    type [<AllowNullLiteral>] UniformBuffer =
        abstract _engine: obj with get, set
        abstract _buffer: obj with get, set
        abstract _data: obj with get, set
        abstract _bufferData: obj with get, set
        abstract _dynamic: obj option with get, set
        abstract _uniformLocations: obj with get, set
        abstract _uniformSizes: obj with get, set
        abstract _uniformLocationPointer: obj with get, set
        abstract _needSync: obj with get, set
        abstract _noUBO: obj with get, set
        abstract _currentEffect: obj with get, set
        abstract _MAX_UNIFORM_SIZE: obj with get, set
        abstract _tempBuffer: obj with get, set
        /// Wrapper for updateUniform.
        abstract updateMatrix3x3: (string -> Float32Array -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateMatrix2x2: (string -> Float32Array -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateFloat: (string -> float -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateFloat2: (string -> float -> float -> string -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateFloat3: (string -> float -> float -> float -> string -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateFloat4: (string -> float -> float -> float -> float -> string -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateMatrix: (string -> Matrix -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateVector3: (string -> Vector3 -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateVector4: (string -> Vector4 -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateColor3: (string -> Color3 -> string -> unit) with get, set
        /// Wrapper for updateUniform.
        abstract updateColor4: (string -> Color3 -> float -> string -> unit) with get, set
        /// Indicates if the buffer is using the WebGL2 UBO implementation,
        /// or just falling back on setUniformXXX calls.
        abstract useUbo: bool
        /// Indicates if the WebGL underlying uniform buffer is in sync
        /// with the javascript cache data.
        abstract isSync: bool
        /// Indicates if the WebGL underlying uniform buffer is dynamic.
        /// Also, a dynamic UniformBuffer will disable cache verification and always
        /// update the underlying WebGL uniform buffer to the GPU.
        abstract isDynamic: unit -> bool
        /// The data cache on JS side.
        abstract getData: unit -> Float32Array
        /// The underlying WebGL Uniform buffer.
        abstract getBuffer: unit -> Nullable<WebGLBuffer>
        /// std140 layout specifies how to align data within an UBO structure.
        /// See https://khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159
        /// for specs.
        abstract _fillAlignment: size: obj -> unit
        /// <summary>Adds an uniform in the buffer.
        /// Warning : the subsequents calls of this function must be in the same order as declared in the shader
        /// for the layout to be correct !</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="size">Data size, or data directly.</param>
        abstract addUniform: name: string * size: U2<float, ResizeArray<float>> -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="mat">A 4x4 matrix.</param>
        abstract addMatrix: name: string * mat: Matrix -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        abstract addFloat2: name: string * x: float * y: float -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="z"></param>
        abstract addFloat3: name: string * x: float * y: float * z: float -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="color"></param>
        abstract addColor3: name: string * color: Color3 -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="color"></param>
        /// <param name="alpha"></param>
        abstract addColor4: name: string * color: Color3 * alpha: float -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="vector"></param>
        abstract addVector3: name: string * vector: Vector3 -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        abstract addMatrix3x3: name: string -> unit
        /// <summary>Wrapper for addUniform.</summary>
        /// <param name="name">Name of the uniform, as used in the uniform block in the shader.</param>
        abstract addMatrix2x2: name: string -> unit
        /// Effectively creates the WebGL Uniform Buffer, once layout is completed with `addUniform`.
        abstract create: unit -> unit
        abstract _rebuild: unit -> unit
        /// Updates the WebGL Uniform Buffer on the GPU.
        /// If the `dynamic` flag is set to true, no cache comparison is done.
        /// Otherwise, the buffer will be updated only if the cache differs.
        abstract update: unit -> unit
        /// <summary>Updates the value of an uniform. The `update` method must be called afterwards to make it effective in the GPU.</summary>
        /// <param name="uniformName">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="data">Flattened data</param>
        /// <param name="size">Size of the data.</param>
        abstract updateUniform: uniformName: string * data: FloatArray * size: float -> unit
        abstract _updateMatrix3x3ForUniform: name: obj * matrix: obj -> unit
        abstract _updateMatrix3x3ForEffect: name: obj * matrix: obj -> unit
        abstract _updateMatrix2x2ForEffect: name: obj * matrix: obj -> unit
        abstract _updateMatrix2x2ForUniform: name: obj * matrix: obj -> unit
        abstract _updateFloatForEffect: name: obj * x: obj -> unit
        abstract _updateFloatForUniform: name: obj * x: obj -> unit
        abstract _updateFloat2ForEffect: name: obj * x: obj * y: obj * ?suffix: obj -> unit
        abstract _updateFloat2ForUniform: name: obj * x: obj * y: obj * ?suffix: obj -> unit
        abstract _updateFloat3ForEffect: name: obj * x: obj * y: obj * z: obj * ?suffix: obj -> unit
        abstract _updateFloat3ForUniform: name: obj * x: obj * y: obj * z: obj * ?suffix: obj -> unit
        abstract _updateFloat4ForEffect: name: obj * x: obj * y: obj * z: obj * w: obj * ?suffix: obj -> unit
        abstract _updateFloat4ForUniform: name: obj * x: obj * y: obj * z: obj * w: obj * ?suffix: obj -> unit
        abstract _updateMatrixForEffect: name: obj * mat: obj -> unit
        abstract _updateMatrixForUniform: name: obj * mat: obj -> unit
        abstract _updateVector3ForEffect: name: obj * vector: obj -> unit
        abstract _updateVector3ForUniform: name: obj * vector: obj -> unit
        abstract _updateVector4ForEffect: name: obj * vector: obj -> unit
        abstract _updateVector4ForUniform: name: obj * vector: obj -> unit
        abstract _updateColor3ForEffect: name: obj * color: obj * ?suffix: obj -> unit
        abstract _updateColor3ForUniform: name: obj * color: obj * ?suffix: obj -> unit
        abstract _updateColor4ForEffect: name: obj * color: obj * alpha: obj * ?suffix: obj -> unit
        abstract _updateColor4ForUniform: name: obj * color: obj * alpha: obj * ?suffix: obj -> unit
        /// <summary>Sets a sampler uniform on the effect.</summary>
        /// <param name="name">Name of the sampler.</param>
        /// <param name="texture"></param>
        abstract setTexture: name: string * texture: Nullable<BaseTexture> -> unit
        /// <summary>Directly updates the value of the uniform in the cache AND on the GPU.</summary>
        /// <param name="uniformName">Name of the uniform, as used in the uniform block in the shader.</param>
        /// <param name="data">Flattened data</param>
        abstract updateUniformDirectly: uniformName: string * data: FloatArray -> unit
        /// <summary>Binds this uniform buffer to an effect.</summary>
        /// <param name="effect"></param>
        /// <param name="name">Name of the uniform block in the shader.</param>
        abstract bindToEffect: effect: Effect * name: string -> unit
        /// Disposes the uniform buffer.
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] UniformBufferStatic =
        /// Uniform buffer objects.
        /// 
        /// Handles blocks of uniform on the GPU.
        /// 
        /// If WebGL 2 is not available, this class falls back on traditionnal setUniformXXX calls.
        /// 
        /// For more information, please refer to :
        /// https://www.khronos.org/opengl/wiki/Uniform_Buffer_Object
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * ?data: ResizeArray<float> * ?dynamic: bool -> UniformBuffer

    type [<AllowNullLiteral>] Scalar =
        /// Two pi constants convenient for computation.
        abstract TwoPi: float with get, set

    type [<AllowNullLiteral>] ScalarStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Scalar
        /// Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)
        abstract WithinEpsilon: a: float * b: float * ?epsilon: float -> bool
        /// Returns a string : the upper case translation of the number i to hexadecimal.
        abstract ToHex: i: float -> string
        /// Returns -1 if value is negative and +1 is value is positive.
        /// Returns the value itself if it's equal to zero.
        abstract Sign: value: float -> float
        /// Returns the value itself if it's between min and max.
        /// Returns min if the value is lower than min.
        /// Returns max if the value is greater than max.
        abstract Clamp: value: float * ?min: float * ?max: float -> float
        /// Returns the log2 of value.
        abstract Log2: value: float -> float
        /// Loops the value, so that it is never larger than length and never smaller than 0.
        /// 
        /// This is similar to the modulo operator but it works with floating point numbers.
        /// For example, using 3.0 for t and 2.5 for length, the result would be 0.5.
        /// With t = 5 and length = 2.5, the result would be 0.0.
        /// Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator
        abstract Repeat: value: float * length: float -> float
        /// Normalize the value between 0.0 and 1.0 using min and max values
        abstract Normalize: value: float * min: float * max: float -> float
        /// Denormalize the value from 0.0 and 1.0 using min and max values
        abstract Denormalize: normalized: float * min: float * max: float -> float
        /// Calculates the shortest difference between two given angles given in degrees.
        abstract DeltaAngle: current: float * target: float -> float
        /// PingPongs the value t, so that it is never larger than length and never smaller than 0.
        /// 
        /// The returned value will move back and forth between 0 and length
        abstract PingPong: tx: float * length: float -> float
        /// Interpolates between min and max with smoothing at the limits.
        /// 
        /// This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up
        /// from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.
        abstract SmoothStep: from: float * ``to``: float * tx: float -> float
        /// Moves a value current towards target.
        /// 
        /// This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.
        /// Negative values of maxDelta pushes the value away from target.
        abstract MoveTowards: current: float * target: float * maxDelta: float -> float
        /// Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.
        /// 
        /// Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta
        ///   are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.
        abstract MoveTowardsAngle: current: float * target: float * maxDelta: float -> float
        /// Creates a new scalar with values linearly interpolated of "amount" between the start scalar and the end scalar.
        abstract Lerp: start: float * ``end``: float * amount: float -> float
        /// Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.
        /// The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.
        abstract LerpAngle: start: float * ``end``: float * amount: float -> float
        /// Calculates the linear parameter t that produces the interpolant value within the range [a, b].
        abstract InverseLerp: a: float * b: float * value: float -> float
        /// Returns a new scalar located for "amount" (float) on the Hermite spline defined by the scalars "value1", "value3", "tangent1", "tangent2".
        abstract Hermite: value1: float * tangent1: float * value2: float * tangent2: float * amount: float -> float
        /// Returns a random float number between and min and max values
        abstract RandomRange: min: float * max: float -> float
        /// This function returns percentage of a number in a given range.
        /// 
        /// RangeToPercent(40,20,60) will return 0.5 (50%)
        /// RangeToPercent(34,0,100) will return 0.34 (34%)
        abstract RangeToPercent: number: float * min: float * max: float -> float
        /// This function returns number that corresponds to the percentage in a given range.
        /// 
        /// PercentToRange(0.34,0,100) will return 34.
        abstract PercentToRange: percent: float * min: float * max: float -> float
        /// <summary>Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.</summary>
        /// <param name="angle">The angle to normalize in radian.</param>
        abstract NormalizeRadians: angle: float -> float

    /// Class used to hold a RBG color
    type [<AllowNullLiteral>] Color3 =
        /// Defines the red component (between 0 and 1, default is 0)
        abstract r: float with get, set
        /// Defines the green component (between 0 and 1, default is 0)
        abstract g: float with get, set
        /// Defines the blue component (between 0 and 1, default is 0)
        abstract b: float with get, set
        /// Creates a string with the Color3 current values
        abstract toString: unit -> string
        /// Returns the string "Color3"
        abstract getClassName: unit -> string
        /// Compute the Color3 hash code
        abstract getHashCode: unit -> float
        /// <summary>Stores in the given array from the given starting index the red, green, blue values as successive elements</summary>
        /// <param name="array">defines the array where to store the r,g,b components</param>
        /// <param name="index">defines an optional index in the target array to define where to start storing values</param>
        abstract toArray: array: FloatArray * ?index: float -> Color3
        /// <summary>Returns a new {BABYLON.Color4} object from the current Color3 and the given alpha</summary>
        /// <param name="alpha">defines the alpha component on the new {BABYLON.Color4} object (default is 1)</param>
        abstract toColor4: ?alpha: float -> Color4
        /// Returns a new array populated with 3 numeric elements : red, green and blue values
        abstract asArray: unit -> ResizeArray<float>
        /// Returns the luminance value
        abstract toLuminance: unit -> float
        /// <summary>Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract multiply: otherColor: Color3 -> Color3
        /// <summary>Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object "result"</summary>
        /// <param name="otherColor">defines the second operand</param>
        /// <param name="result">defines the Color3 object where to store the result</param>
        abstract multiplyToRef: otherColor: Color3 * result: Color3 -> Color3
        /// <summary>Determines equality between Color3 objects</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract equals: otherColor: Color3 -> bool
        /// <summary>Determines equality between the current Color3 object and a set of r,b,g values</summary>
        /// <param name="r">defines the red component to check</param>
        /// <param name="g">defines the green component to check</param>
        /// <param name="b">defines the blue component to check</param>
        abstract equalsFloats: r: float * g: float * b: float -> bool
        /// <summary>Multiplies in place each rgb value by scale</summary>
        /// <param name="scale">defines the scaling factor</param>
        abstract scale: scale: float -> Color3
        /// <summary>Multiplies the rgb values by scale and stores the result into "result"</summary>
        /// <param name="scale">defines the scaling factor</param>
        /// <param name="result">defines the Color3 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Color3 -> Color3
        /// <summary>Scale the current Color3 values by a factor and add the result to a given Color3</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines color to store the result into</param>
        abstract scaleAndAddToRef: scale: float * result: Color3 -> Color3
        /// <summary>Clamps the rgb values by the min and max values and stores the result into "result"</summary>
        /// <param name="min">defines minimum clamping value (default is 0)</param>
        /// <param name="max">defines maximum clamping value (default is 1)</param>
        /// <param name="result">defines color to store the result into</param>
        abstract clampToRef: min: float option * max: float option * result: Color3 -> Color3
        /// <summary>Creates a new Color3 set with the added values of the current Color3 and of the given one</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract add: otherColor: Color3 -> Color3
        /// <summary>Stores the result of the addition of the current Color3 and given one rgb values into "result"</summary>
        /// <param name="otherColor">defines the second operand</param>
        /// <param name="result">defines Color3 object to store the result into</param>
        abstract addToRef: otherColor: Color3 * result: Color3 -> Color3
        /// <summary>Returns a new Color3 set with the subtracted values of the given one from the current Color3</summary>
        /// <param name="otherColor">defines the second operand</param>
        abstract subtract: otherColor: Color3 -> Color3
        /// <summary>Stores the result of the subtraction of given one from the current Color3 rgb values into "result"</summary>
        /// <param name="otherColor">defines the second operand</param>
        /// <param name="result">defines Color3 object to store the result into</param>
        abstract subtractToRef: otherColor: Color3 * result: Color3 -> Color3
        /// Copy the current object
        abstract clone: unit -> Color3
        /// <summary>Copies the rgb values from the source in the current Color3</summary>
        /// <param name="source">defines the source Color3 object</param>
        abstract copyFrom: source: Color3 -> Color3
        /// <summary>Updates the Color3 rgb values from the given floats</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        abstract copyFromFloats: r: float * g: float * b: float -> Color3
        /// <summary>Updates the Color3 rgb values from the given floats</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        abstract set: r: float * g: float * b: float -> Color3
        /// Compute the Color3 hexadecimal code as a string
        abstract toHexString: unit -> string
        /// Computes a new Color3 converted from the current one to linear space
        abstract toLinearSpace: unit -> Color3
        /// <summary>Converts the Color3 values to linear space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color3 object where to store the linear space version</param>
        abstract toLinearSpaceToRef: convertedColor: Color3 -> Color3
        /// Computes a new Color3 converted from the current one to gamma space
        abstract toGammaSpace: unit -> Color3
        /// <summary>Converts the Color3 values to gamma space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color3 object where to store the gamma space version</param>
        abstract toGammaSpaceToRef: convertedColor: Color3 -> Color3

    /// Class used to hold a RBG color
    type [<AllowNullLiteral>] Color3Static =
        /// <summary>Creates a new Color3 object from red, green, blue values, all between 0 and 1</summary>
        /// <param name="r">defines the red component (between 0 and 1, default is 0)</param>
        /// <param name="g">defines the green component (between 0 and 1, default is 0)</param>
        /// <param name="b">defines the blue component (between 0 and 1, default is 0)</param>
        [<Emit "new $0($1...)">] abstract Create: ?r: float * ?g: float * ?b: float -> Color3
        /// <summary>Creates a new Color3 from the string containing valid hexadecimal values</summary>
        /// <param name="hex">defines a string containing valid hexadecimal values</param>
        abstract FromHexString: hex: string -> Color3
        /// <summary>Creates a new Vector3 from the starting index of the given array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines an offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Color3
        /// <summary>Creates a new Color3 from integer values (< 256)</summary>
        /// <param name="r">defines the red component to read from (value between 0 and 255)</param>
        /// <param name="g">defines the green component to read from (value between 0 and 255)</param>
        /// <param name="b">defines the blue component to read from (value between 0 and 255)</param>
        abstract FromInts: r: float * g: float * b: float -> Color3
        /// <summary>Creates a new Color3 with values linearly interpolated of "amount" between the start Color3 and the end Color3</summary>
        /// <param name="start">defines the start Color3 value</param>
        /// <param name="end">defines the end Color3 value</param>
        /// <param name="amount">defines the gradient value between start and end</param>
        abstract Lerp: start: Color3 * ``end``: Color3 * amount: float -> Color3
        /// Returns a Color3 value containing a red color
        abstract Red: unit -> Color3
        /// Returns a Color3 value containing a green color
        abstract Green: unit -> Color3
        /// Returns a Color3 value containing a blue color
        abstract Blue: unit -> Color3
        /// Returns a Color3 value containing a black color
        abstract Black: unit -> Color3
        /// Returns a Color3 value containing a white color
        abstract White: unit -> Color3
        /// Returns a Color3 value containing a purple color
        abstract Purple: unit -> Color3
        /// Returns a Color3 value containing a magenta color
        abstract Magenta: unit -> Color3
        /// Returns a Color3 value containing a yellow color
        abstract Yellow: unit -> Color3
        /// Returns a Color3 value containing a gray color
        abstract Gray: unit -> Color3
        /// Returns a Color3 value containing a teal color
        abstract Teal: unit -> Color3
        /// Returns a Color3 value containing a random color
        abstract Random: unit -> Color3

    /// Class used to hold a RBGA color
    type [<AllowNullLiteral>] Color4 =
        /// Defines the red component (between 0 and 1, default is 0)
        abstract r: float with get, set
        /// Defines the green component (between 0 and 1, default is 0)
        abstract g: float with get, set
        /// Defines the blue component (between 0 and 1, default is 0)
        abstract b: float with get, set
        /// Defines the alpha component (between 0 and 1, default is 1)
        abstract a: float with get, set
        /// <summary>Adds in place the given Color4 values to the current Color4 object</summary>
        /// <param name="right">defines the second operand</param>
        abstract addInPlace: right: Color4 -> Color4
        /// Creates a new array populated with 4 numeric elements : red, green, blue, alpha values
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Stores from the starting index in the given array the Color4 successive values</summary>
        /// <param name="array">defines the array where to store the r,g,b components</param>
        /// <param name="index">defines an optional index in the target array to define where to start storing values</param>
        abstract toArray: array: ResizeArray<float> * ?index: float -> Color4
        /// <summary>Creates a new Color4 set with the added values of the current Color4 and of the given one</summary>
        /// <param name="right">defines the second operand</param>
        abstract add: right: Color4 -> Color4
        /// <summary>Creates a new Color4 set with the subtracted values of the given one from the current Color4</summary>
        /// <param name="right">defines the second operand</param>
        abstract subtract: right: Color4 -> Color4
        /// <summary>Subtracts the given ones from the current Color4 values and stores the results in "result"</summary>
        /// <param name="right">defines the second operand</param>
        /// <param name="result">defines the Color4 object where to store the result</param>
        abstract subtractToRef: right: Color4 * result: Color4 -> Color4
        /// <summary>Creates a new Color4 with the current Color4 values multiplied by scale</summary>
        /// <param name="scale">defines the scaling factor to apply</param>
        abstract scale: scale: float -> Color4
        /// <summary>Multiplies the current Color4 values by scale and stores the result in "result"</summary>
        /// <param name="scale">defines the scaling factor to apply</param>
        /// <param name="result">defines the Color4 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Color4 -> Color4
        /// <summary>Scale the current Color4 values by a factor and add the result to a given Color4</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Color4 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Color4 -> Color4
        /// <summary>Clamps the rgb values by the min and max values and stores the result into "result"</summary>
        /// <param name="min">defines minimum clamping value (default is 0)</param>
        /// <param name="max">defines maximum clamping value (default is 1)</param>
        /// <param name="result">defines color to store the result into.</param>
        abstract clampToRef: min: float option * max: float option * result: Color4 -> Color4
        /// <summary>Multipy an Color4 value by another and return a new Color4 object</summary>
        /// <param name="color">defines the Color4 value to multiply by</param>
        abstract multiply: color: Color4 -> Color4
        /// <summary>Multipy a Color4 value by another and push the result in a reference value</summary>
        /// <param name="color">defines the Color4 value to multiply by</param>
        /// <param name="result">defines the Color4 to fill the result in</param>
        abstract multiplyToRef: color: Color4 * result: Color4 -> Color4
        /// Creates a string with the Color4 current values
        abstract toString: unit -> string
        /// Returns the string "Color4"
        abstract getClassName: unit -> string
        /// Compute the Color4 hash code
        abstract getHashCode: unit -> float
        /// Creates a new Color4 copied from the current one
        abstract clone: unit -> Color4
        /// <summary>Copies the given Color4 values into the current one</summary>
        /// <param name="source">defines the source Color4 object</param>
        abstract copyFrom: source: Color4 -> Color4
        /// <summary>Copies the given float values into the current one</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        /// <param name="a">defines the alpha component to read from</param>
        abstract copyFromFloats: r: float * g: float * b: float * a: float -> Color4
        /// <summary>Copies the given float values into the current one</summary>
        /// <param name="r">defines the red component to read from</param>
        /// <param name="g">defines the green component to read from</param>
        /// <param name="b">defines the blue component to read from</param>
        /// <param name="a">defines the alpha component to read from</param>
        abstract set: r: float * g: float * b: float * a: float -> Color4
        /// Compute the Color4 hexadecimal code as a string
        abstract toHexString: unit -> string
        /// Computes a new Color4 converted from the current one to linear space
        abstract toLinearSpace: unit -> Color4
        /// <summary>Converts the Color4 values to linear space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color4 object where to store the linear space version</param>
        abstract toLinearSpaceToRef: convertedColor: Color4 -> Color4
        /// Computes a new Color4 converted from the current one to gamma space
        abstract toGammaSpace: unit -> Color4
        /// <summary>Converts the Color4 values to gamma space and stores the result in "convertedColor"</summary>
        /// <param name="convertedColor">defines the Color4 object where to store the gamma space version</param>
        abstract toGammaSpaceToRef: convertedColor: Color4 -> Color4

    /// Class used to hold a RBGA color
    type [<AllowNullLiteral>] Color4Static =
        /// <summary>Creates a new Color4 object from red, green, blue values, all between 0 and 1</summary>
        /// <param name="r">defines the red component (between 0 and 1, default is 0)</param>
        /// <param name="g">defines the green component (between 0 and 1, default is 0)</param>
        /// <param name="b">defines the blue component (between 0 and 1, default is 0)</param>
        /// <param name="a">defines the alpha component (between 0 and 1, default is 1)</param>
        [<Emit "new $0($1...)">] abstract Create: ?r: float * ?g: float * ?b: float * ?a: float -> Color4
        /// <summary>Creates a new Color4 from the string containing valid hexadecimal values</summary>
        /// <param name="hex">defines a string containing valid hexadecimal values</param>
        abstract FromHexString: hex: string -> Color4
        /// <summary>Creates a new Color4 object set with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object</summary>
        /// <param name="left">defines the start value</param>
        /// <param name="right">defines the end value</param>
        /// <param name="amount">defines the gradient factor</param>
        abstract Lerp: left: Color4 * right: Color4 * amount: float -> Color4
        /// <summary>Set the given "result" with the linearly interpolated values of "amount" between the left Color4 object and the right Color4 object</summary>
        /// <param name="left">defines the start value</param>
        /// <param name="right">defines the end value</param>
        /// <param name="amount">defines the gradient factor</param>
        /// <param name="result">defines the Color4 object where to store data</param>
        abstract LerpToRef: left: Color4 * right: Color4 * amount: float * result: Color4 -> unit
        /// <summary>Creates a new Color4 from the starting index element of the given array</summary>
        /// <param name="array">defines the source array to read from</param>
        /// <param name="offset">defines the offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Color4
        /// <summary>Creates a new Color3 from integer values (< 256)</summary>
        /// <param name="r">defines the red component to read from (value between 0 and 255)</param>
        /// <param name="g">defines the green component to read from (value between 0 and 255)</param>
        /// <param name="b">defines the blue component to read from (value between 0 and 255)</param>
        /// <param name="a">defines the alpha component to read from (value between 0 and 255)</param>
        abstract FromInts: r: float * g: float * b: float * a: float -> Color4
        /// <summary>Check the content of a given array and convert it to an array containing RGBA data
        /// If the original array was already containing count * 4 values then it is returned directly</summary>
        /// <param name="colors">defines the array to check</param>
        /// <param name="count">defines the number of RGBA data to expect</param>
        abstract CheckColors4: colors: ResizeArray<float> * count: float -> ResizeArray<float>

    type [<AllowNullLiteral>] Vector2 =
        abstract x: float with get, set
        abstract y: float with get, set
        /// Returns a string with the Vector2 coordinates.
        abstract toString: unit -> string
        /// Returns the string "Vector2"
        abstract getClassName: unit -> string
        /// Returns the Vector2 hash code as a number.
        abstract getHashCode: unit -> float
        /// Sets the Vector2 coordinates in the given array or Float32Array from the given index.
        /// Returns the Vector2.
        abstract toArray: array: FloatArray * ?index: float -> Vector2
        /// Returns a new array with 2 elements : the Vector2 coordinates.
        abstract asArray: unit -> ResizeArray<float>
        /// Sets the Vector2 coordinates with the given Vector2 coordinates.
        /// Returns the updated Vector2.
        abstract copyFrom: source: Vector2 -> Vector2
        /// Sets the Vector2 coordinates with the given floats.
        /// Returns the updated Vector2.
        abstract copyFromFloats: x: float * y: float -> Vector2
        /// Sets the Vector2 coordinates with the given floats.
        /// Returns the updated Vector2.
        abstract set: x: float * y: float -> Vector2
        /// Returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates.
        abstract add: otherVector: Vector2 -> Vector2
        /// Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates.
        /// Returns the Vector2.
        abstract addToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// Set the Vector2 coordinates by adding the given Vector2 coordinates.
        /// Returns the updated Vector2.
        abstract addInPlace: otherVector: Vector2 -> Vector2
        /// Returns a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates.
        abstract addVector3: otherVector: Vector3 -> Vector2
        /// Returns a new Vector2 set with the subtracted coordinates of the given one from the current Vector2.
        abstract subtract: otherVector: Vector2 -> Vector2
        /// Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
        /// Returns the Vector2.
        abstract subtractToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// Sets the current Vector2 coordinates by subtracting from it the given one coordinates.
        /// Returns the updated Vector2.
        abstract subtractInPlace: otherVector: Vector2 -> Vector2
        /// Multiplies in place the current Vector2 coordinates by the given ones.
        /// Returns the updated Vector2.
        abstract multiplyInPlace: otherVector: Vector2 -> Vector2
        /// Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates.
        abstract multiply: otherVector: Vector2 -> Vector2
        /// Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates.
        /// Returns the Vector2.
        abstract multiplyToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// Returns a new Vector2 set with the Vector2 coordinates multiplied by the given floats.
        abstract multiplyByFloats: x: float * y: float -> Vector2
        /// Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates.
        abstract divide: otherVector: Vector2 -> Vector2
        /// Sets the "result" coordinates with the Vector2 divided by the given one coordinates.
        /// Returns the Vector2.
        abstract divideToRef: otherVector: Vector2 * result: Vector2 -> Vector2
        /// Divides the current Vector3 coordinates by the given ones.
        /// Returns the updated Vector3.
        abstract divideInPlace: otherVector: Vector2 -> Vector2
        /// Returns a new Vector2 with current Vector2 negated coordinates.
        abstract negate: unit -> Vector2
        /// Multiply the Vector2 coordinates by scale.
        /// Returns the updated Vector2.
        abstract scaleInPlace: scale: float -> Vector2
        /// Returns a new Vector2 scaled by "scale" from the current Vector2.
        abstract scale: scale: float -> Vector2
        /// <summary>Scale the current Vector2 values by a factor to a given Vector2</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector2 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Vector2 -> Vector2
        /// <summary>Scale the current Vector2 values by a factor and add the result to a given Vector2</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector2 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Vector2 -> Vector2
        /// Boolean : True if the given vector coordinates strictly equal the current Vector2 ones.
        abstract equals: otherVector: Vector2 -> bool
        /// Boolean : True if the given vector coordinates are close to the current ones by a distance of epsilon.
        abstract equalsWithEpsilon: otherVector: Vector2 * ?epsilon: float -> bool
        /// Returns the vector length (float).
        abstract length: unit -> float
        /// Returns the vector squared length (float);
        abstract lengthSquared: unit -> float
        /// Normalize the vector.
        /// Returns the updated Vector2.
        abstract normalize: unit -> Vector2
        /// Returns a new Vector2 copied from the Vector2.
        abstract clone: unit -> Vector2

    type [<AllowNullLiteral>] Vector2Static =
        /// Creates a new Vector2 from the given x and y coordinates.
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float -> Vector2
        /// Returns a new Vector2(0, 0)
        abstract Zero: unit -> Vector2
        /// Returns a new Vector2(1, 1)
        abstract One: unit -> Vector2
        /// Returns a new Vector2 set from the given index element of the given array.
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Vector2
        /// Sets "result" from the given index element of the given array.
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Vector2 -> unit
        /// Retuns a new Vector2 located for "amount" (float) on the CatmullRom  spline defined by the given four Vector2.
        abstract CatmullRom: value1: Vector2 * value2: Vector2 * value3: Vector2 * value4: Vector2 * amount: float -> Vector2
        /// Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
        /// If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
        /// If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate.
        abstract Clamp: value: Vector2 * min: Vector2 * max: Vector2 -> Vector2
        /// Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value3", "tangent1", "tangent2".
        abstract Hermite: value1: Vector2 * tangent1: Vector2 * value2: Vector2 * tangent2: Vector2 * amount: float -> Vector2
        /// Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
        abstract Lerp: start: Vector2 * ``end``: Vector2 * amount: float -> Vector2
        /// Returns the dot product (float) of the vector "left" and the vector "right".
        abstract Dot: left: Vector2 * right: Vector2 -> float
        /// Returns a new Vector2 equal to the normalized given vector.
        abstract Normalize: vector: Vector2 -> Vector2
        /// Returns a new Vecto2 set with the minimal coordinate values from the "left" and "right" vectors.
        abstract Minimize: left: Vector2 * right: Vector2 -> Vector2
        /// Returns a new Vecto2 set with the maximal coordinate values from the "left" and "right" vectors.
        abstract Maximize: left: Vector2 * right: Vector2 -> Vector2
        /// Returns a new Vecto2 set with the transformed coordinates of the given vector by the given transformation matrix.
        abstract Transform: vector: Vector2 * transformation: Matrix -> Vector2
        /// Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector "result" coordinates.
        abstract TransformToRef: vector: Vector2 * transformation: Matrix * result: Vector2 -> unit
        /// Boolean : True if the point "p" is in the triangle defined by the vertors "p0", "p1", "p2"
        abstract PointInTriangle: p: Vector2 * p0: Vector2 * p1: Vector2 * p2: Vector2 -> bool
        /// Returns the distance (float) between the vectors "value1" and "value2".
        abstract Distance: value1: Vector2 * value2: Vector2 -> float
        /// Returns the squared distance (float) between the vectors "value1" and "value2".
        abstract DistanceSquared: value1: Vector2 * value2: Vector2 -> float
        /// Returns a new Vecto2 located at the center of the vectors "value1" and "value2".
        abstract Center: value1: Vector2 * value2: Vector2 -> Vector2
        /// Returns the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
        abstract DistanceOfPointFromSegment: p: Vector2 * segA: Vector2 * segB: Vector2 -> float

    /// Classed used to store (x,y,z) vector representation
    /// A Vector3 is the main object used in 3D geometry
    /// It can represent etiher the coordinates of a point the space, either a direction
    /// Reminder: Babylon.js uses a left handed forward facing system
    type [<AllowNullLiteral>] Vector3 =
        /// Defines the first coordinates (on X axis)
        abstract x: float with get, set
        /// Defines the second coordinates (on Y axis)
        abstract y: float with get, set
        /// Defines the third coordinates (on Z axis)
        abstract z: float with get, set
        /// Creates a string representation of the Vector3
        abstract toString: unit -> string
        /// Gets the class name
        abstract getClassName: unit -> string
        /// Creates the Vector3 hash code
        abstract getHashCode: unit -> float
        /// Creates an array containing three elements : the coordinates of the Vector3
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Populates the given array or Float32Array from the given index with the successive coordinates of the Vector3</summary>
        /// <param name="array">defines the destination array</param>
        /// <param name="index">defines the offset in the destination array</param>
        abstract toArray: array: FloatArray * ?index: float -> Vector3
        /// Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)
        abstract toQuaternion: unit -> Quaternion
        /// <summary>Adds the given vector to the current Vector3</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract addInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Gets a new Vector3, result of the addition the current Vector3 and the given vector</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract add: otherVector: Vector3 -> Vector3
        /// <summary>Adds the current Vector3 to the given one and stores the result in the vector "result"</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract addToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Subtract the given vector from the current Vector3</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract subtractInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Returns a new Vector3, result of the subtraction of the given vector from the current Vector3</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract subtract: otherVector: Vector3 -> Vector3
        /// <summary>Subtracts the given vector from the current Vector3 and stores the result in the vector "result".</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract subtractToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract subtractFromFloats: x: float * y: float * z: float -> Vector3
        /// <summary>Subtracts the given floats from the current Vector3 coordinates and set the given vector "result" with this result</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract subtractFromFloatsToRef: x: float * y: float * z: float * result: Vector3 -> Vector3
        /// Gets a new Vector3 set with the current Vector3 negated coordinates
        abstract negate: unit -> Vector3
        /// <summary>Multiplies the Vector3 coordinates by the float "scale"</summary>
        /// <param name="scale">defines the multiplier factor</param>
        abstract scaleInPlace: scale: float -> Vector3
        /// <summary>Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float "scale"</summary>
        /// <param name="scale">defines the multiplier factor</param>
        abstract scale: scale: float -> Vector3
        /// <summary>Multiplies the current Vector3 coordinates by the float "scale" and stores the result in the given vector "result" coordinates</summary>
        /// <param name="scale">defines the multiplier factor</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract scaleToRef: scale: float * result: Vector3 -> Vector3
        /// <summary>Scale the current Vector3 values by a factor and add the result to a given Vector3</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Vector3 -> Vector3
        /// <summary>Returns true if the current Vector3 and the given vector coordinates are strictly equal</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract equals: otherVector: Vector3 -> bool
        /// <summary>Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="epsilon">defines the minimal distance to define values as equals</param>
        abstract equalsWithEpsilon: otherVector: Vector3 * ?epsilon: float -> bool
        /// <summary>Returns true if the current Vector3 coordinates equals the given floats</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract equalsToFloats: x: float * y: float * z: float -> bool
        /// <summary>Multiplies the current Vector3 coordinates by the given ones</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract multiplyInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract multiply: otherVector: Vector3 -> Vector3
        /// <summary>Multiplies the current Vector3 by the given one and stores the result in the given vector "result"</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract multiplyToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract multiplyByFloats: x: float * y: float * z: float -> Vector3
        /// <summary>Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract divide: otherVector: Vector3 -> Vector3
        /// <summary>Divides the current Vector3 coordinates by the given ones and stores the result in the given vector "result"</summary>
        /// <param name="otherVector">defines the second operand</param>
        /// <param name="result">defines the Vector3 object where to store the result</param>
        abstract divideToRef: otherVector: Vector3 * result: Vector3 -> Vector3
        /// <summary>Divides the current Vector3 coordinates by the given ones.</summary>
        /// <param name="otherVector">defines the second operand</param>
        abstract divideInPlace: otherVector: Vector3 -> Vector3
        /// <summary>Updates the current Vector3 with the minimal coordinate values between its and the given vector ones</summary>
        /// <param name="other">defines the second operand</param>
        abstract minimizeInPlace: other: Vector3 -> Vector3
        /// <summary>Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.</summary>
        /// <param name="other">defines the second operand</param>
        abstract maximizeInPlace: other: Vector3 -> Vector3
        /// Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same
        abstract isNonUniform: bool
        /// Gets the length of the Vector3
        abstract length: unit -> float
        /// Gets the squared length of the Vector3
        abstract lengthSquared: unit -> float
        /// Normalize the current Vector3.
        /// Please note that this is an in place operation.
        abstract normalize: unit -> Vector3
        /// Normalize the current Vector3 to a new vector
        abstract normalizeToNew: unit -> Vector3
        /// <summary>Normalize the current Vector3 to the reference</summary>
        /// <param name="reference">define the Vector3 to update</param>
        abstract normalizeToRef: reference: Vector3 -> Vector3
        /// Creates a new Vector3 copied from the current Vector3
        abstract clone: unit -> Vector3
        /// <summary>Copies the given vector coordinates to the current Vector3 ones</summary>
        /// <param name="source">defines the source Vector3</param>
        abstract copyFrom: source: Vector3 -> Vector3
        /// <summary>Copies the given floats to the current Vector3 coordinates</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract copyFromFloats: x: float * y: float * z: float -> Vector3
        /// <summary>Copies the given floats to the current Vector3 coordinates</summary>
        /// <param name="x">defines the x coordinate of the operand</param>
        /// <param name="y">defines the y coordinate of the operand</param>
        /// <param name="z">defines the z coordinate of the operand</param>
        abstract set: x: float * y: float * z: float -> Vector3
        abstract _viewportMatrixCache: obj with get, set

    /// Classed used to store (x,y,z) vector representation
    /// A Vector3 is the main object used in 3D geometry
    /// It can represent etiher the coordinates of a point the space, either a direction
    /// Reminder: Babylon.js uses a left handed forward facing system
    type [<AllowNullLiteral>] Vector3Static =
        /// <summary>Creates a new Vector3 object from the given x, y, z (floats) coordinates.</summary>
        /// <param name="x">defines the first coordinates (on X axis)</param>
        /// <param name="y">defines the second coordinates (on Y axis)</param>
        /// <param name="z">defines the third coordinates (on Z axis)</param>
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float * z: float -> Vector3
        /// <summary>Get the clip factor between two vectors</summary>
        /// <param name="vector0">defines the first operand</param>
        /// <param name="vector1">defines the second operand</param>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="size">defines the size along the axis</param>
        abstract GetClipFactor: vector0: Vector3 * vector1: Vector3 * axis: Vector3 * size: float -> float
        /// <summary>Get angle between two vectors</summary>
        /// <param name="vector0">angle between vector0 and vector1</param>
        /// <param name="vector1">angle between vector0 and vector1</param>
        /// <param name="normal">direction of the normal</param>
        abstract GetAngleBetweenVectors: vector0: Vector3 * vector1: Vector3 * normal: Vector3 -> float
        /// <summary>Returns a new Vector3 set from the index "offset" of the given array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Vector3
        /// <summary>Returns a new Vector3 set from the index "offset" of the given Float32Array
        /// This function is deprecated.  Use FromArray instead</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        abstract FromFloatArray: array: Float32Array * ?offset: float -> Vector3
        /// <summary>Sets the given vector "result" with the element values from the index "offset" of the given array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" with the element values from the index "offset" of the given Float32Array
        /// This function is deprecated.  Use FromArrayToRef instead.</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract FromFloatArrayToRef: array: Float32Array * offset: float * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" with the given floats.</summary>
        /// <param name="x">defines the x coordinate of the source</param>
        /// <param name="y">defines the y coordinate of the source</param>
        /// <param name="z">defines the z coordinate of the source</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract FromFloatsToRef: x: float * y: float * z: float * result: Vector3 -> unit
        /// Returns a new Vector3 set to (0.0, 0.0, 0.0)
        abstract Zero: unit -> Vector3
        /// Returns a new Vector3 set to (1.0, 1.0, 1.0)
        abstract One: unit -> Vector3
        /// Returns a new Vector3 set to (0.0, 1.0, 0.0)
        abstract Up: unit -> Vector3
        /// Returns a new Vector3 set to (0.0, 0.0, 1.0)
        abstract Forward: unit -> Vector3
        /// Returns a new Vector3 set to (1.0, 0.0, 0.0)
        abstract Right: unit -> Vector3
        /// Returns a new Vector3 set to (-1.0, 0.0, 0.0)
        abstract Left: unit -> Vector3
        /// <summary>Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.
        /// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        abstract TransformCoordinates: vector: Vector3 * transformation: Matrix -> Vector3
        /// <summary>Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given vector
        /// This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformCoordinatesToRef: vector: Vector3 * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)
        /// This method computes tranformed coordinates only, not transformed direction vectors</summary>
        /// <param name="x">define the x coordinate of the source vector</param>
        /// <param name="y">define the y coordinate of the source vector</param>
        /// <param name="z">define the z coordinate of the source vector</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformCoordinatesFromFloatsToRef: x: float * y: float * z: float * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector
        /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        abstract TransformNormal: vector: Vector3 * transformation: Matrix -> Vector3
        /// <summary>Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector
        /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)</summary>
        /// <param name="vector">defines the Vector3 to transform</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformNormalToRef: vector: Vector3 * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z)
        /// This methods computes transformed normalized direction vectors only (ie. it does not apply translation)</summary>
        /// <param name="x">define the x coordinate of the source vector</param>
        /// <param name="y">define the y coordinate of the source vector</param>
        /// <param name="z">define the z coordinate of the source vector</param>
        /// <param name="transformation">defines the transformation matrix</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract TransformNormalFromFloatsToRef: x: float * y: float * z: float * transformation: Matrix * result: Vector3 -> unit
        /// <summary>Returns a new Vector3 located for "amount" on the CatmullRom interpolation spline defined by the vectors "value1", "value2", "value3", "value4"</summary>
        /// <param name="value1">defines the first control point</param>
        /// <param name="value2">defines the second control point</param>
        /// <param name="value3">defines the third control point</param>
        /// <param name="value4">defines the fourth control point</param>
        /// <param name="amount">defines the amount on the spline to use</param>
        abstract CatmullRom: value1: Vector3 * value2: Vector3 * value3: Vector3 * value4: Vector3 * amount: float -> Vector3
        /// <summary>Returns a new Vector3 set with the coordinates of "value", if the vector "value" is in the cube defined by the vectors "min" and "max"
        /// If a coordinate value of "value" is lower than one of the "min" coordinate, then this "value" coordinate is set with the "min" one
        /// If a coordinate value of "value" is greater than one of the "max" coordinate, then this "value" coordinate is set with the "max" one</summary>
        /// <param name="value">defines the current value</param>
        /// <param name="min">defines the lower range value</param>
        /// <param name="max">defines the upper range value</param>
        abstract Clamp: value: Vector3 * min: Vector3 * max: Vector3 -> Vector3
        /// <summary>Returns a new Vector3 located for "amount" (float) on the Hermite interpolation spline defined by the vectors "value1", "tangent1", "value2", "tangent2"</summary>
        /// <param name="value1">defines the first control point</param>
        /// <param name="tangent1">defines the first tangent vector</param>
        /// <param name="value2">defines the second control point</param>
        /// <param name="tangent2">defines the second tangent vector</param>
        /// <param name="amount">defines the amount on the interpolation spline (between 0 and 1)</param>
        abstract Hermite: value1: Vector3 * tangent1: Vector3 * value2: Vector3 * tangent2: Vector3 * amount: float -> Vector3
        /// <summary>Returns a new Vector3 located for "amount" (float) on the linear interpolation between the vectors "start" and "end"</summary>
        /// <param name="start">defines the start value</param>
        /// <param name="end">defines the end value</param>
        /// <param name="amount">max defines amount between both (between 0 and 1)</param>
        abstract Lerp: start: Vector3 * ``end``: Vector3 * amount: float -> Vector3
        /// <summary>Sets the given vector "result" with the result of the linear interpolation from the vector "start" for "amount" to the vector "end"</summary>
        /// <param name="start">defines the start value</param>
        /// <param name="end">defines the end value</param>
        /// <param name="amount">max defines amount between both (between 0 and 1)</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract LerpToRef: start: Vector3 * ``end``: Vector3 * amount: float * result: Vector3 -> unit
        /// <summary>Returns the dot product (float) between the vectors "left" and "right"</summary>
        /// <param name="left">defines the left operand</param>
        /// <param name="right">defines the right operand</param>
        abstract Dot: left: Vector3 * right: Vector3 -> float
        /// <summary>Returns a new Vector3 as the cross product of the vectors "left" and "right"
        /// The cross product is then orthogonal to both "left" and "right"</summary>
        /// <param name="left">defines the left operand</param>
        /// <param name="right">defines the right operand</param>
        abstract Cross: left: Vector3 * right: Vector3 -> Vector3
        /// <summary>Sets the given vector "result" with the cross product of "left" and "right"
        /// The cross product is then orthogonal to both "left" and "right"</summary>
        /// <param name="left">defines the left operand</param>
        /// <param name="right">defines the right operand</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract CrossToRef: left: Vector3 * right: Vector3 * result: Vector3 -> unit
        /// <summary>Returns a new Vector3 as the normalization of the given vector</summary>
        /// <param name="vector">defines the Vector3 to normalize</param>
        abstract Normalize: vector: Vector3 -> Vector3
        /// <summary>Sets the given vector "result" with the normalization of the given first vector</summary>
        /// <param name="vector">defines the Vector3 to normalize</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract NormalizeToRef: vector: Vector3 * result: Vector3 -> unit
        /// <summary>Project a Vector3 onto screen space</summary>
        /// <param name="vector">defines the Vector3 to project</param>
        /// <param name="world">defines the world matrix to use</param>
        /// <param name="transform">defines the transform (view x projection) matrix to use</param>
        /// <param name="viewport">defines the screen viewport to use</param>
        abstract Project: vector: Vector3 * world: Matrix * transform: Matrix * viewport: Viewport -> Vector3
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="source">defines the screen space Vector3 to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="transform">defines the transform (view x projection) matrix to use</param>
        abstract UnprojectFromTransform: source: Vector3 * viewportWidth: float * viewportHeight: float * world: Matrix * transform: Matrix -> Vector3
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="source">defines the screen space Vector3 to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="view">defines the view matrix to use</param>
        /// <param name="projection">defines the projection matrix to use</param>
        abstract Unproject: source: Vector3 * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix -> Vector3
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="source">defines the screen space Vector3 to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="view">defines the view matrix to use</param>
        /// <param name="projection">defines the projection matrix to use</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract UnprojectToRef: source: Vector3 * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix * result: Vector3 -> unit
        /// <summary>Unproject from screen space to object space</summary>
        /// <param name="sourceX">defines the screen space x coordinate to use</param>
        /// <param name="sourceY">defines the screen space y coordinate to use</param>
        /// <param name="sourceZ">defines the screen space z coordinate to use</param>
        /// <param name="viewportWidth">defines the current width of the viewport</param>
        /// <param name="viewportHeight">defines the current height of the viewport</param>
        /// <param name="world">defines the world matrix to use (can be set to Identity to go to world space)</param>
        /// <param name="view">defines the view matrix to use</param>
        /// <param name="projection">defines the projection matrix to use</param>
        /// <param name="result">defines the Vector3 where to store the result</param>
        abstract UnprojectFloatsToRef: sourceX: float * sourceY: float * sourceZ: float * viewportWidth: float * viewportHeight: float * world: Matrix * view: Matrix * projection: Matrix * result: Vector3 -> unit
        /// <summary>Gets the minimal coordinate values between two Vector3</summary>
        /// <param name="left">defines the first operand</param>
        /// <param name="right">defines the second operand</param>
        abstract Minimize: left: Vector3 * right: Vector3 -> Vector3
        /// <summary>Gets the maximal coordinate values between two Vector3</summary>
        /// <param name="left">defines the first operand</param>
        /// <param name="right">defines the second operand</param>
        abstract Maximize: left: Vector3 * right: Vector3 -> Vector3
        /// <summary>Returns the distance between the vectors "value1" and "value2"</summary>
        /// <param name="value1">defines the first operand</param>
        /// <param name="value2">defines the second operand</param>
        abstract Distance: value1: Vector3 * value2: Vector3 -> float
        /// <summary>Returns the squared distance between the vectors "value1" and "value2"</summary>
        /// <param name="value1">defines the first operand</param>
        /// <param name="value2">defines the second operand</param>
        abstract DistanceSquared: value1: Vector3 * value2: Vector3 -> float
        /// <summary>Returns a new Vector3 located at the center between "value1" and "value2"</summary>
        /// <param name="value1">defines the first operand</param>
        /// <param name="value2">defines the second operand</param>
        abstract Center: value1: Vector3 * value2: Vector3 -> Vector3
        /// <summary>Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),
        /// RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply
        /// to something in order to rotate it from its local system to the given target system
        /// Note: axis1, axis2 and axis3 are normalized during this operation</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        abstract RotationFromAxis: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 -> Vector3
        /// <summary>The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        /// <param name="ref">defines the Vector3 where to store the result</param>
        abstract RotationFromAxisToRef: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 * ref: Vector3 -> unit

    type [<AllowNullLiteral>] Vector4 =
        abstract x: float with get, set
        abstract y: float with get, set
        abstract z: float with get, set
        abstract w: float with get, set
        /// Returns the string with the Vector4 coordinates.
        abstract toString: unit -> string
        /// Returns the string "Vector4".
        abstract getClassName: unit -> string
        /// Returns the Vector4 hash code.
        abstract getHashCode: unit -> float
        /// Returns a new array populated with 4 elements : the Vector4 coordinates.
        abstract asArray: unit -> ResizeArray<float>
        /// Populates the given array from the given index with the Vector4 coordinates.
        /// Returns the Vector4.
        abstract toArray: array: FloatArray * ?index: float -> Vector4
        /// Adds the given vector to the current Vector4.
        /// Returns the updated Vector4.
        abstract addInPlace: otherVector: Vector4 -> Vector4
        /// Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.
        abstract add: otherVector: Vector4 -> Vector4
        /// Updates the given vector "result" with the result of the addition of the current Vector4 and the given one.
        /// Returns the current Vector4.
        abstract addToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// Subtract in place the given vector from the current Vector4.
        /// Returns the updated Vector4.
        abstract subtractInPlace: otherVector: Vector4 -> Vector4
        /// Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.
        abstract subtract: otherVector: Vector4 -> Vector4
        /// Sets the given vector "result" with the result of the subtraction of the given vector from the current Vector4.
        /// Returns the current Vector4.
        abstract subtractToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.
        abstract subtractFromFloats: x: float * y: float * z: float * w: float -> Vector4
        /// Sets the given vector "result" set with the result of the subtraction of the given floats from the current Vector4 coordinates.
        /// Returns the current Vector4.
        abstract subtractFromFloatsToRef: x: float * y: float * z: float * w: float * result: Vector4 -> Vector4
        /// Returns a new Vector4 set with the current Vector4 negated coordinates.
        abstract negate: unit -> Vector4
        /// Multiplies the current Vector4 coordinates by scale (float).
        /// Returns the updated Vector4.
        abstract scaleInPlace: scale: float -> Vector4
        /// Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).
        abstract scale: scale: float -> Vector4
        /// Sets the given vector "result" with the current Vector4 coordinates multiplied by scale (float).
        /// Returns the current Vector4.
        abstract scaleToRef: scale: float * result: Vector4 -> Vector4
        /// <summary>Scale the current Vector4 values by a factor and add the result to a given Vector4</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Vector4 object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Vector4 -> Vector4
        /// Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.
        abstract equals: otherVector: Vector4 -> bool
        /// Boolean : True if the current Vector4 coordinates are each beneath the distance "epsilon" from the given vector ones.
        abstract equalsWithEpsilon: otherVector: Vector4 * ?epsilon: float -> bool
        /// Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.
        abstract equalsToFloats: x: float * y: float * z: float * w: float -> bool
        /// Multiplies in place the current Vector4 by the given one.
        /// Returns the updated Vector4.
        abstract multiplyInPlace: otherVector: Vector4 -> Vector4
        /// Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.
        abstract multiply: otherVector: Vector4 -> Vector4
        /// Updates the given vector "result" with the multiplication result of the current Vector4 and the given one.
        /// Returns the current Vector4.
        abstract multiplyToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.
        abstract multiplyByFloats: x: float * y: float * z: float * w: float -> Vector4
        /// Returns a new Vector4 set with the division result of the current Vector4 by the given one.
        abstract divide: otherVector: Vector4 -> Vector4
        /// Updates the given vector "result" with the division result of the current Vector4 by the given one.
        /// Returns the current Vector4.
        abstract divideToRef: otherVector: Vector4 * result: Vector4 -> Vector4
        /// Divides the current Vector3 coordinates by the given ones.
        abstract divideInPlace: otherVector: Vector4 -> Vector4
        /// <summary>Updates the Vector4 coordinates with the minimum values between its own and the given vector ones</summary>
        /// <param name="other">defines the second operand</param>
        abstract minimizeInPlace: other: Vector4 -> Vector4
        /// <summary>Updates the Vector4 coordinates with the maximum values between its own and the given vector ones</summary>
        /// <param name="other">defines the second operand</param>
        abstract maximizeInPlace: other: Vector4 -> Vector4
        /// Returns the Vector4 length (float).
        abstract length: unit -> float
        /// Returns the Vector4 squared length (float).
        abstract lengthSquared: unit -> float
        /// Normalizes in place the Vector4.
        /// Returns the updated Vector4.
        abstract normalize: unit -> Vector4
        /// Returns a new Vector3 from the Vector4 (x, y, z) coordinates.
        abstract toVector3: unit -> Vector3
        /// Returns a new Vector4 copied from the current one.
        abstract clone: unit -> Vector4
        /// Updates the current Vector4 with the given one coordinates.
        /// Returns the updated Vector4.
        abstract copyFrom: source: Vector4 -> Vector4
        /// Updates the current Vector4 coordinates with the given floats.
        /// Returns the updated Vector4.
        abstract copyFromFloats: x: float * y: float * z: float * w: float -> Vector4
        /// Updates the current Vector4 coordinates with the given floats.
        /// Returns the updated Vector4.
        abstract set: x: float * y: float * z: float * w: float -> Vector4

    type [<AllowNullLiteral>] Vector4Static =
        /// Creates a Vector4 object from the given floats.
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float * z: float * w: float -> Vector4
        /// Returns a new Vector4 set from the starting index of the given array.
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Vector4
        /// Updates the given vector "result" from the starting index of the given array.
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Vector4 -> unit
        /// Updates the given vector "result" from the starting index of the given Float32Array.
        abstract FromFloatArrayToRef: array: Float32Array * offset: float * result: Vector4 -> unit
        /// Updates the given vector "result" coordinates from the given floats.
        abstract FromFloatsToRef: x: float * y: float * z: float * w: float * result: Vector4 -> unit
        /// Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)
        abstract Zero: unit -> Vector4
        /// Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)
        abstract One: unit -> Vector4
        /// Returns a new normalized Vector4 from the given one.
        abstract Normalize: vector: Vector4 -> Vector4
        /// Updates the given vector "result" from the normalization of the given one.
        abstract NormalizeToRef: vector: Vector4 * result: Vector4 -> unit
        abstract Minimize: left: Vector4 * right: Vector4 -> Vector4
        abstract Maximize: left: Vector4 * right: Vector4 -> Vector4
        /// Returns the distance (float) between the vectors "value1" and "value2".
        abstract Distance: value1: Vector4 * value2: Vector4 -> float
        /// Returns the squared distance (float) between the vectors "value1" and "value2".
        abstract DistanceSquared: value1: Vector4 * value2: Vector4 -> float
        /// Returns a new Vector4 located at the center between the vectors "value1" and "value2".
        abstract Center: value1: Vector4 * value2: Vector4 -> Vector4
        /// Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.
        /// This methods computes transformed normalized direction vectors only.
        abstract TransformNormal: vector: Vector4 * transformation: Matrix -> Vector4
        /// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given vector.
        /// This methods computes transformed normalized direction vectors only.
        abstract TransformNormalToRef: vector: Vector4 * transformation: Matrix * result: Vector4 -> unit
        /// Sets the given vector "result" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).
        /// This methods computes transformed normalized direction vectors only.
        abstract TransformNormalFromFloatsToRef: x: float * y: float * z: float * w: float * transformation: Matrix * result: Vector4 -> unit

    type [<AllowNullLiteral>] ISize =
        abstract width: float with get, set
        abstract height: float with get, set

    type [<AllowNullLiteral>] Size =
        inherit ISize
        abstract width: float with get, set
        abstract height: float with get, set
        abstract toString: unit -> string
        /// Returns the string "Size"
        abstract getClassName: unit -> string
        /// Returns the Size hash code.
        abstract getHashCode: unit -> float
        /// Updates the current size from the given one.
        /// Returns the updated Size.
        abstract copyFrom: src: Size -> unit
        /// Updates in place the current Size from the given floats.
        /// Returns the updated Size.
        abstract copyFromFloats: width: float * height: float -> Size
        /// Updates in place the current Size from the given floats.
        /// Returns the updated Size.
        abstract set: width: float * height: float -> Size
        /// Returns a new Size set with the multiplication result of the current Size and the given floats.
        abstract multiplyByFloats: w: float * h: float -> Size
        /// Returns a new Size copied from the given one.
        abstract clone: unit -> Size
        /// Boolean : True if the current Size and the given one width and height are strictly equal.
        abstract equals: other: Size -> bool
        /// Returns the surface of the Size : width * height (float).
        abstract surface: float
        /// Returns a new Size set as the addition result of the current Size and the given one.
        abstract add: otherSize: Size -> Size
        /// Returns a new Size set as the subtraction result of  the given one from the current Size.
        abstract subtract: otherSize: Size -> Size

    type [<AllowNullLiteral>] SizeStatic =
        /// Creates a Size object from the given width and height (floats).
        [<Emit "new $0($1...)">] abstract Create: width: float * height: float -> Size
        /// Returns a new Size set to (0.0, 0.0)
        abstract Zero: unit -> Size
        /// Returns a new Size set at the linear interpolation "amount" between "start" and "end".
        abstract Lerp: start: Size * ``end``: Size * amount: float -> Size

    /// Class used to store quaternion data
    type [<AllowNullLiteral>] Quaternion =
        /// defines the first component (0 by default) 
        abstract x: float with get, set
        /// defines the second component (0 by default) 
        abstract y: float with get, set
        /// defines the third component (0 by default) 
        abstract z: float with get, set
        /// defines the fourth component (1.0 by default) 
        abstract w: float with get, set
        /// Gets a string representation for the current quaternion
        abstract toString: unit -> string
        /// Gets the class name of the quaternion
        abstract getClassName: unit -> string
        /// Gets a hash code for this quaternion
        abstract getHashCode: unit -> float
        /// Copy the quaternion to an array
        abstract asArray: unit -> ResizeArray<float>
        /// <summary>Check if two quaternions are equals</summary>
        /// <param name="otherQuaternion">defines the second operand</param>
        abstract equals: otherQuaternion: Quaternion -> bool
        /// Clone the current quaternion
        abstract clone: unit -> Quaternion
        /// <summary>Copy a quaternion to the current one</summary>
        /// <param name="other">defines the other quaternion</param>
        abstract copyFrom: other: Quaternion -> Quaternion
        /// <summary>Updates the current quaternion with the given float coordinates</summary>
        /// <param name="x">defines the x coordinate</param>
        /// <param name="y">defines the y coordinate</param>
        /// <param name="z">defines the z coordinate</param>
        /// <param name="w">defines the w coordinate</param>
        abstract copyFromFloats: x: float * y: float * z: float * w: float -> Quaternion
        /// <summary>Updates the current quaternion from the given float coordinates</summary>
        /// <param name="x">defines the x coordinate</param>
        /// <param name="y">defines the y coordinate</param>
        /// <param name="z">defines the z coordinate</param>
        /// <param name="w">defines the w coordinate</param>
        abstract set: x: float * y: float * z: float * w: float -> Quaternion
        /// <summary>Adds two quaternions</summary>
        /// <param name="other">defines the second operand</param>
        abstract add: other: Quaternion -> Quaternion
        /// <summary>Add a quaternion to the current one</summary>
        /// <param name="other">defines the quaternion to add</param>
        abstract addInPlace: other: Quaternion -> Quaternion
        /// <summary>Subtract two quaternions</summary>
        /// <param name="other">defines the second operand</param>
        abstract subtract: other: Quaternion -> Quaternion
        /// <summary>Multiplies the current quaternion by a scale factor</summary>
        /// <param name="value">defines the scale factor</param>
        abstract scale: value: float -> Quaternion
        /// <summary>Scale the current quaternion values by a factor and stores the result to a given quaternion</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Quaternion object where to store the result</param>
        abstract scaleToRef: scale: float * result: Quaternion -> Quaternion
        /// <summary>Multiplies in place the current quaternion by a scale factor</summary>
        /// <param name="value">defines the scale factor</param>
        abstract scaleInPlace: value: float -> Quaternion
        /// <summary>Scale the current quaternion values by a factor and add the result to a given quaternion</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Quaternion object where to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Quaternion -> Quaternion
        /// <summary>Multiplies two quaternions</summary>
        /// <param name="q1">defines the second operand</param>
        abstract multiply: q1: Quaternion -> Quaternion
        /// <summary>Sets the given "result" as the the multiplication result of the current one with the given one "q1"</summary>
        /// <param name="q1">defines the second operand</param>
        /// <param name="result">defines the target quaternion</param>
        abstract multiplyToRef: q1: Quaternion * result: Quaternion -> Quaternion
        /// <summary>Updates the current quaternion with the multiplication of itself with the given one "q1"</summary>
        /// <param name="q1">defines the second operand</param>
        abstract multiplyInPlace: q1: Quaternion -> Quaternion
        /// <summary>Conjugates (1-q) the current quaternion and stores the result in the given quaternion</summary>
        /// <param name="ref">defines the target quaternion</param>
        abstract conjugateToRef: ref: Quaternion -> Quaternion
        /// Conjugates in place (1-q) the current quaternion
        abstract conjugateInPlace: unit -> Quaternion
        /// Conjugates in place (1-q) the current quaternion
        abstract conjugate: unit -> Quaternion
        /// Gets length of current quaternion
        abstract length: unit -> float
        /// Normalize in place the current quaternion
        abstract normalize: unit -> Quaternion
        /// <summary>Returns a new Vector3 set with the Euler angles translated from the current quaternion</summary>
        /// <param name="order">is a reserved parameter and is ignore for now</param>
        abstract toEulerAngles: ?order: string -> Vector3
        /// <summary>Sets the given vector3 "result" with the Euler angles translated from the current quaternion</summary>
        /// <param name="result">defines the vector which will be filled with the Euler angles</param>
        /// <param name="order">is a reserved parameter and is ignore for now</param>
        abstract toEulerAnglesToRef: result: Vector3 * ?order: string -> Quaternion
        /// <summary>Updates the given rotation matrix with the current quaternion values</summary>
        /// <param name="result">defines the target matrix</param>
        abstract toRotationMatrix: result: Matrix -> Quaternion
        /// <summary>Updates the current quaternion from the given rotation matrix values</summary>
        /// <param name="matrix">defines the source matrix</param>
        abstract fromRotationMatrix: matrix: Matrix -> Quaternion

    /// Class used to store quaternion data
    type [<AllowNullLiteral>] QuaternionStatic =
        /// <summary>Creates a new Quaternion from the given floats</summary>
        /// <param name="x">defines the first component (0 by default)</param>
        /// <param name="y">defines the second component (0 by default)</param>
        /// <param name="z">defines the third component (0 by default)</param>
        /// <param name="w">defines the fourth component (1.0 by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?x: float * ?y: float * ?z: float * ?w: float -> Quaternion
        /// <summary>Creates a new quaternion from a rotation matrix</summary>
        /// <param name="matrix">defines the source matrix</param>
        abstract FromRotationMatrix: matrix: Matrix -> Quaternion
        /// <summary>Updates the given quaternion with the given rotation matrix values</summary>
        /// <param name="matrix">defines the source matrix</param>
        /// <param name="result">defines the target quaternion</param>
        abstract FromRotationMatrixToRef: matrix: Matrix * result: Quaternion -> unit
        /// Creates an empty quaternion
        abstract Zero: unit -> Quaternion
        /// <summary>Inverse a given quaternion</summary>
        /// <param name="q">defines the source quaternion</param>
        abstract Inverse: q: Quaternion -> Quaternion
        /// Creates an identity quaternion
        abstract Identity: unit -> Quaternion
        /// <summary>Gets a boolean indicating if the given quaternion is identity</summary>
        /// <param name="quaternion">defines the quaternion to check</param>
        abstract IsIdentity: quaternion: Quaternion -> bool
        /// <summary>Creates a quaternion from a rotation around an axis</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle to use</param>
        abstract RotationAxis: axis: Vector3 * angle: float -> Quaternion
        /// <summary>Creates a rotation around an axis and stores it into the given quaternion</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle to use</param>
        /// <param name="result">defines the target quaternion</param>
        abstract RotationAxisToRef: axis: Vector3 * angle: float * result: Quaternion -> Quaternion
        /// <summary>Creates a new quaternion from data stored into an array</summary>
        /// <param name="array">defines the data source</param>
        /// <param name="offset">defines the offset in the source array where the data starts</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Quaternion
        /// <summary>Creates a new quaternion from the given Euler float angles (y, x, z)</summary>
        /// <param name="yaw">defines the rotation around Y axis</param>
        /// <param name="pitch">defines the rotation around X axis</param>
        /// <param name="roll">defines the rotation around Z axis</param>
        abstract RotationYawPitchRoll: yaw: float * pitch: float * roll: float -> Quaternion
        /// <summary>Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion</summary>
        /// <param name="yaw">defines the rotation around Y axis</param>
        /// <param name="pitch">defines the rotation around X axis</param>
        /// <param name="roll">defines the rotation around Z axis</param>
        /// <param name="result">defines the target quaternion</param>
        abstract RotationYawPitchRollToRef: yaw: float * pitch: float * roll: float * result: Quaternion -> unit
        /// <summary>Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation</summary>
        /// <param name="alpha">defines the rotation around first axis</param>
        /// <param name="beta">defines the rotation around second axis</param>
        /// <param name="gamma">defines the rotation around third axis</param>
        abstract RotationAlphaBetaGamma: alpha: float * beta: float * gamma: float -> Quaternion
        /// <summary>Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion</summary>
        /// <param name="alpha">defines the rotation around first axis</param>
        /// <param name="beta">defines the rotation around second axis</param>
        /// <param name="gamma">defines the rotation around third axis</param>
        /// <param name="result">defines the target quaternion</param>
        abstract RotationAlphaBetaGammaToRef: alpha: float * beta: float * gamma: float * result: Quaternion -> unit
        /// <summary>Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        abstract RotationQuaternionFromAxis: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 -> Quaternion
        /// <summary>Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion</summary>
        /// <param name="axis1">defines the first axis</param>
        /// <param name="axis2">defines the second axis</param>
        /// <param name="axis3">defines the third axis</param>
        /// <param name="ref">defines the target quaternion</param>
        abstract RotationQuaternionFromAxisToRef: axis1: Vector3 * axis2: Vector3 * axis3: Vector3 * ref: Quaternion -> unit
        /// <summary>Interpolates between two quaternions</summary>
        /// <param name="left">defines first quaternion</param>
        /// <param name="right">defines second quaternion</param>
        /// <param name="amount">defines the gradient to use</param>
        abstract Slerp: left: Quaternion * right: Quaternion * amount: float -> Quaternion
        /// <summary>Interpolates between two quaternions and stores it into a target quaternion</summary>
        /// <param name="left">defines first quaternion</param>
        /// <param name="right">defines second quaternion</param>
        /// <param name="amount">defines the gradient to use</param>
        /// <param name="result">defines the target quaternion</param>
        abstract SlerpToRef: left: Quaternion * right: Quaternion * amount: float * result: Quaternion -> unit
        /// <summary>Interpolate between two quaternions using Hermite interpolation</summary>
        /// <param name="value1">defines first quaternion</param>
        /// <param name="tangent1">defines the incoming tangent</param>
        /// <param name="value2">defines second quaternion</param>
        /// <param name="tangent2">defines the outgoing tangent</param>
        /// <param name="amount">defines the target quaternion</param>
        abstract Hermite: value1: Quaternion * tangent1: Quaternion * value2: Quaternion * tangent2: Quaternion * amount: float -> Quaternion

    /// Class used to store matrix data (4x4)
    type [<AllowNullLiteral>] Matrix =
        abstract _tempQuaternion: obj with get, set
        abstract _xAxis: obj with get, set
        abstract _yAxis: obj with get, set
        abstract _zAxis: obj with get, set
        abstract _updateFlagSeed: obj with get, set
        abstract _identityReadOnly: obj with get, set
        abstract _isIdentity: obj with get, set
        abstract _isIdentityDirty: obj with get, set
        /// Gets the update flag of the matrix which is an unique number for the matrix.
        /// It will be incremented every time the matrix data change.
        /// You can use it to speed the comparison between two versions of the same matrix.
        abstract updateFlag: float with get, set
        /// Gets or sets the internal data of the matrix
        abstract m: Float32Array with get, set
        abstract _markAsUpdated: unit -> unit
        /// <summary>Check if the current matrix is indentity</summary>
        /// <param name="considerAsTextureMatrix">defines if the current matrix must be considered as a texture matrix (3x2)</param>
        abstract isIdentity: ?considerAsTextureMatrix: bool -> bool
        /// Gets the determinant of the matrix
        abstract determinant: unit -> float
        /// Returns the matrix as a Float32Array
        abstract toArray: unit -> Float32Array
        /// Returns the matrix as a Float32Array
        abstract asArray: unit -> Float32Array
        /// Inverts the current matrix in place
        abstract invert: unit -> Matrix
        /// Sets all the matrix elements to zero
        abstract reset: unit -> Matrix
        /// <summary>Adds the current matrix with a second one</summary>
        /// <param name="other">defines the matrix to add</param>
        abstract add: other: Matrix -> Matrix
        /// <summary>Sets the given matrix "result" to the addition of the current matrix and the given one</summary>
        /// <param name="other">defines the matrix to add</param>
        /// <param name="result">defines the target matrix</param>
        abstract addToRef: other: Matrix * result: Matrix -> Matrix
        /// <summary>Adds in place the given matrix to the current matrix</summary>
        /// <param name="other">defines the second operand</param>
        abstract addToSelf: other: Matrix -> Matrix
        /// <summary>Sets the given matrix to the current inverted Matrix</summary>
        /// <param name="other">defines the target matrix</param>
        abstract invertToRef: other: Matrix -> Matrix
        /// <summary>Inserts the translation vector (using 3 floats) in the current matrix</summary>
        /// <param name="x">defines the 1st component of the translation</param>
        /// <param name="y">defines the 2nd component of the translation</param>
        /// <param name="z">defines the 3rd component of the translation</param>
        abstract setTranslationFromFloats: x: float * y: float * z: float -> Matrix
        /// <summary>Inserts the translation vector in the current matrix</summary>
        /// <param name="vector3">defines the translation to insert</param>
        abstract setTranslation: vector3: Vector3 -> Matrix
        /// Gets the translation value of the current matrix
        abstract getTranslation: unit -> Vector3
        /// <summary>Fill a Vector3 with the extracted translation from the matrix</summary>
        /// <param name="result">defines the Vector3 where to store the translation</param>
        abstract getTranslationToRef: result: Vector3 -> Matrix
        /// Remove rotation and scaling part from the matrix
        abstract removeRotationAndScaling: unit -> Matrix
        /// <summary>Multiply two matrices</summary>
        /// <param name="other">defines the second operand</param>
        abstract multiply: other: Matrix -> Matrix
        /// <summary>Copy the current matrix from the given one</summary>
        /// <param name="other">defines the source matrix</param>
        abstract copyFrom: other: Matrix -> Matrix
        /// <summary>Populates the given array from the starting index with the current matrix values</summary>
        /// <param name="array">defines the target array</param>
        /// <param name="offset">defines the offset in the target array where to start storing values</param>
        abstract copyToArray: array: Float32Array * ?offset: float -> Matrix
        /// <summary>Sets the given matrix "result" with the multiplication result of the current Matrix and the given one</summary>
        /// <param name="other">defines the second operand</param>
        /// <param name="result">defines the matrix where to store the multiplication</param>
        abstract multiplyToRef: other: Matrix * result: Matrix -> Matrix
        /// <summary>Sets the Float32Array "result" from the given index "offset" with the multiplication of the current matrix and the given one</summary>
        /// <param name="other">defines the second operand</param>
        /// <param name="result">defines the array where to store the multiplication</param>
        /// <param name="offset">defines the offset in the target array where to start storing values</param>
        abstract multiplyToArray: other: Matrix * result: Float32Array * offset: float -> Matrix
        /// <summary>Check equality between this matrix and a second one</summary>
        /// <param name="value">defines the second matrix to compare</param>
        abstract equals: value: Matrix -> bool
        /// Clone the current matrix
        abstract clone: unit -> Matrix
        /// Returns the name of the current matrix class
        abstract getClassName: unit -> string
        /// Gets the hash code of the current matrix
        abstract getHashCode: unit -> float
        /// <summary>Decomposes the current Matrix into a translation, rotation and scaling components</summary>
        /// <param name="scale">defines the scale vector3 given as a reference to update</param>
        /// <param name="rotation">defines the rotation quaternion given as a reference to update</param>
        /// <param name="translation">defines the translation vector3 given as a reference to update</param>
        abstract decompose: ?scale: Vector3 * ?rotation: Quaternion * ?translation: Vector3 -> bool
        /// <summary>Gets specific row of the matrix</summary>
        /// <param name="index">defines the number of the row to get</param>
        abstract getRow: index: float -> Nullable<Vector4>
        /// <summary>Sets the index-th row of the current matrix to the vector4 values</summary>
        /// <param name="index">defines the number of the row to set</param>
        /// <param name="row">defines the target vector4</param>
        abstract setRow: index: float * row: Vector4 -> Matrix
        /// Compute the transpose of the matrix
        abstract transpose: unit -> Matrix
        /// <summary>Compute the transpose of the matrix and store it in a given matrix</summary>
        /// <param name="result">defines the target matrix</param>
        abstract transposeToRef: result: Matrix -> Matrix
        /// <summary>Sets the index-th row of the current matrix with the given 4 x float values</summary>
        /// <param name="index">defines the row index</param>
        /// <param name="x">defines the x component to set</param>
        /// <param name="y">defines the y component to set</param>
        /// <param name="z">defines the z component to set</param>
        /// <param name="w">defines the w component to set</param>
        abstract setRowFromFloats: index: float * x: float * y: float * z: float * w: float -> Matrix
        /// <summary>Compute a new matrix set with the current matrix values multiplied by scale (float)</summary>
        /// <param name="scale">defines the scale factor</param>
        abstract scale: scale: float -> Matrix
        /// <summary>Scale the current matrix values by a factor to a given result matrix</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the matrix to store the result</param>
        abstract scaleToRef: scale: float * result: Matrix -> Matrix
        /// <summary>Scale the current matrix values by a factor and add the result to a given matrix</summary>
        /// <param name="scale">defines the scale factor</param>
        /// <param name="result">defines the Matrix to store the result</param>
        abstract scaleAndAddToRef: scale: float * result: Matrix -> Matrix
        /// <summary>Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).</summary>
        /// <param name="ref">matrix to store the result</param>
        abstract toNormalMatrix: ref: Matrix -> unit
        /// Gets only rotation part of the current matrix
        abstract getRotationMatrix: unit -> Matrix
        /// <summary>Extracts the rotation matrix from the current one and sets it as the given "result"</summary>
        /// <param name="result">defines the target matrix to store data to</param>
        abstract getRotationMatrixToRef: result: Matrix -> Matrix
        /// Gets an identity matrix that must not be updated
        abstract IdentityReadOnly: Matrix

    /// Class used to store matrix data (4x4)
    type [<AllowNullLiteral>] MatrixStatic =
        /// Creates an empty matrix (filled with zeros)
        [<Emit "new $0($1...)">] abstract Create: unit -> Matrix
        /// <summary>Creates a matrix from an array</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines an offset in the source array</param>
        abstract FromArray: array: ArrayLike<float> * ?offset: float -> Matrix
        /// <summary>Copy the content of an array into a given matrix</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines an offset in the source array</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromArrayToRef: array: ArrayLike<float> * offset: float * result: Matrix -> unit
        /// <summary>Stores an array into a matrix after having multiplied each component by a given factor</summary>
        /// <param name="array">defines the source array</param>
        /// <param name="offset">defines the offset in the source array</param>
        /// <param name="scale">defines the scaling factor</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromFloat32ArrayToRefScaled: array: Float32Array * offset: float * scale: float * result: Matrix -> unit
        /// <summary>Stores a list of values (16) inside a given matrix</summary>
        /// <param name="initialM11">defines 1st value of 1st row</param>
        /// <param name="initialM12">defines 2nd value of 1st row</param>
        /// <param name="initialM13">defines 3rd value of 1st row</param>
        /// <param name="initialM14">defines 4th value of 1st row</param>
        /// <param name="initialM21">defines 1st value of 2nd row</param>
        /// <param name="initialM22">defines 2nd value of 2nd row</param>
        /// <param name="initialM23">defines 3rd value of 2nd row</param>
        /// <param name="initialM24">defines 4th value of 2nd row</param>
        /// <param name="initialM31">defines 1st value of 3rd row</param>
        /// <param name="initialM32">defines 2nd value of 3rd row</param>
        /// <param name="initialM33">defines 3rd value of 3rd row</param>
        /// <param name="initialM34">defines 4th value of 3rd row</param>
        /// <param name="initialM41">defines 1st value of 4th row</param>
        /// <param name="initialM42">defines 2nd value of 4th row</param>
        /// <param name="initialM43">defines 3rd value of 4th row</param>
        /// <param name="initialM44">defines 4th value of 4th row</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromValuesToRef: initialM11: float * initialM12: float * initialM13: float * initialM14: float * initialM21: float * initialM22: float * initialM23: float * initialM24: float * initialM31: float * initialM32: float * initialM33: float * initialM34: float * initialM41: float * initialM42: float * initialM43: float * initialM44: float * result: Matrix -> unit
        /// <summary>Creates new matrix from a list of values (16)</summary>
        /// <param name="initialM11">defines 1st value of 1st row</param>
        /// <param name="initialM12">defines 2nd value of 1st row</param>
        /// <param name="initialM13">defines 3rd value of 1st row</param>
        /// <param name="initialM14">defines 4th value of 1st row</param>
        /// <param name="initialM21">defines 1st value of 2nd row</param>
        /// <param name="initialM22">defines 2nd value of 2nd row</param>
        /// <param name="initialM23">defines 3rd value of 2nd row</param>
        /// <param name="initialM24">defines 4th value of 2nd row</param>
        /// <param name="initialM31">defines 1st value of 3rd row</param>
        /// <param name="initialM32">defines 2nd value of 3rd row</param>
        /// <param name="initialM33">defines 3rd value of 3rd row</param>
        /// <param name="initialM34">defines 4th value of 3rd row</param>
        /// <param name="initialM41">defines 1st value of 4th row</param>
        /// <param name="initialM42">defines 2nd value of 4th row</param>
        /// <param name="initialM43">defines 3rd value of 4th row</param>
        /// <param name="initialM44">defines 4th value of 4th row</param>
        abstract FromValues: initialM11: float * initialM12: float * initialM13: float * initialM14: float * initialM21: float * initialM22: float * initialM23: float * initialM24: float * initialM31: float * initialM32: float * initialM33: float * initialM34: float * initialM41: float * initialM42: float * initialM43: float * initialM44: float -> Matrix
        /// <summary>Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)</summary>
        /// <param name="scale">defines the scale vector3</param>
        /// <param name="rotation">defines the rotation quaternion</param>
        /// <param name="translation">defines the translation vector3</param>
        abstract Compose: scale: Vector3 * rotation: Quaternion * translation: Vector3 -> Matrix
        /// <summary>Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)</summary>
        /// <param name="scale">defines the scale vector3</param>
        /// <param name="rotation">defines the rotation quaternion</param>
        /// <param name="translation">defines the translation vector3</param>
        /// <param name="result">defines the target matrix</param>
        abstract ComposeToRef: scale: Vector3 * rotation: Quaternion * translation: Vector3 * result: Matrix -> unit
        /// Creates a new identity matrix
        abstract Identity: unit -> Matrix
        /// <summary>Creates a new identity matrix and stores the result in a given matrix</summary>
        /// <param name="result">defines the target matrix</param>
        abstract IdentityToRef: result: Matrix -> unit
        /// Creates a new zero matrix
        abstract Zero: unit -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the X axis</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationX: angle: float -> Matrix
        /// <summary>Creates a new matrix as the invert of a given matrix</summary>
        /// <param name="source">defines the source matrix</param>
        abstract Invert: source: Matrix -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the X axis and stores it in a given matrix</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationXToRef: angle: float * result: Matrix -> unit
        /// <summary>Creates a new rotation matrix for "angle" radians around the Y axis</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationY: angle: float -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the Y axis and stores it in a given matrix</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationYToRef: angle: float * result: Matrix -> unit
        /// <summary>Creates a new rotation matrix for "angle" radians around the Z axis</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationZ: angle: float -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the Z axis and stores it in a given matrix</summary>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationZToRef: angle: float * result: Matrix -> unit
        /// <summary>Creates a new rotation matrix for "angle" radians around the given axis</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle (in radians) to use</param>
        abstract RotationAxis: axis: Vector3 * angle: float -> Matrix
        /// <summary>Creates a new rotation matrix for "angle" radians around the given axis and stores it in a given matrix</summary>
        /// <param name="axis">defines the axis to use</param>
        /// <param name="angle">defines the angle (in radians) to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationAxisToRef: axis: Vector3 * angle: float * result: Matrix -> unit
        /// <summary>Creates a rotation matrix</summary>
        /// <param name="yaw">defines the yaw angle in radians (Y axis)</param>
        /// <param name="pitch">defines the pitch angle in radians (X axis)</param>
        /// <param name="roll">defines the roll angle in radians (X axis)</param>
        abstract RotationYawPitchRoll: yaw: float * pitch: float * roll: float -> Matrix
        /// <summary>Creates a rotation matrix and stores it in a given matrix</summary>
        /// <param name="yaw">defines the yaw angle in radians (Y axis)</param>
        /// <param name="pitch">defines the pitch angle in radians (X axis)</param>
        /// <param name="roll">defines the roll angle in radians (X axis)</param>
        /// <param name="result">defines the target matrix</param>
        abstract RotationYawPitchRollToRef: yaw: float * pitch: float * roll: float * result: Matrix -> unit
        /// <summary>Creates a scaling matrix</summary>
        /// <param name="x">defines the scale factor on X axis</param>
        /// <param name="y">defines the scale factor on Y axis</param>
        /// <param name="z">defines the scale factor on Z axis</param>
        abstract Scaling: x: float * y: float * z: float -> Matrix
        /// <summary>Creates a scaling matrix and stores it in a given matrix</summary>
        /// <param name="x">defines the scale factor on X axis</param>
        /// <param name="y">defines the scale factor on Y axis</param>
        /// <param name="z">defines the scale factor on Z axis</param>
        /// <param name="result">defines the target matrix</param>
        abstract ScalingToRef: x: float * y: float * z: float * result: Matrix -> unit
        /// <summary>Creates a translation matrix</summary>
        /// <param name="x">defines the translation on X axis</param>
        /// <param name="y">defines the translation on Y axis</param>
        /// <param name="z">defines the translationon Z axis</param>
        abstract Translation: x: float * y: float * z: float -> Matrix
        /// <summary>Creates a translation matrix and stores it in a given matrix</summary>
        /// <param name="x">defines the translation on X axis</param>
        /// <param name="y">defines the translation on Y axis</param>
        /// <param name="z">defines the translationon Z axis</param>
        /// <param name="result">defines the target matrix</param>
        abstract TranslationToRef: x: float * y: float * z: float * result: Matrix -> unit
        /// <summary>Returns a new Matrix whose values are the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".</summary>
        /// <param name="startValue">defines the start value</param>
        /// <param name="endValue">defines the end value</param>
        /// <param name="gradient">defines the gradient factor</param>
        abstract Lerp: startValue: Matrix * endValue: Matrix * gradient: float -> Matrix
        /// <summary>Set the given matrix "result" as the interpolated values for "gradient" (float) between the ones of the matrices "startValue" and "endValue".</summary>
        /// <param name="startValue">defines the start value</param>
        /// <param name="endValue">defines the end value</param>
        /// <param name="gradient">defines the gradient factor</param>
        /// <param name="result">defines the Matrix object where to store data</param>
        abstract LerpToRef: startValue: Matrix * endValue: Matrix * gradient: float * result: Matrix -> unit
        /// <summary>Builds a new matrix whose values are computed by:
        /// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
        /// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
        /// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices</summary>
        /// <param name="startValue">defines the first matrix</param>
        /// <param name="endValue">defines the second matrix</param>
        /// <param name="gradient">defines the gradient between the two matrices</param>
        abstract DecomposeLerp: startValue: Matrix * endValue: Matrix * gradient: float -> Matrix
        /// <summary>Update a matrix to values which are computed by:
        /// * decomposing the the "startValue" and "endValue" matrices into their respective scale, rotation and translation matrices
        /// * interpolating for "gradient" (float) the values between each of these decomposed matrices between the start and the end
        /// * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices</summary>
        /// <param name="startValue">defines the first matrix</param>
        /// <param name="endValue">defines the second matrix</param>
        /// <param name="gradient">defines the gradient between the two matrices</param>
        /// <param name="result">defines the target matrix</param>
        abstract DecomposeLerpToRef: startValue: Matrix * endValue: Matrix * gradient: float * result: Matrix -> unit
        /// <summary>Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
        /// This function works in left handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        abstract LookAtLH: eye: Vector3 * target: Vector3 * up: Vector3 -> Matrix
        /// <summary>Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
        /// This function works in left handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        /// <param name="result">defines the target matrix</param>
        abstract LookAtLHToRef: eye: Vector3 * target: Vector3 * up: Vector3 * result: Matrix -> unit
        /// <summary>Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up"
        /// This function works in right handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        abstract LookAtRH: eye: Vector3 * target: Vector3 * up: Vector3 -> Matrix
        /// <summary>Sets the given "result" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like "up".
        /// This function works in right handed mode</summary>
        /// <param name="eye">defines the final position of the entity</param>
        /// <param name="target">defines where the entity should look at</param>
        /// <param name="up">defines the up vector for the entity</param>
        /// <param name="result">defines the target matrix</param>
        abstract LookAtRHToRef: eye: Vector3 * target: Vector3 * up: Vector3 * result: Matrix -> unit
        /// <summary>Create a left-handed orthographic projection matrix</summary>
        /// <param name="width">defines the viewport width</param>
        /// <param name="height">defines the viewport height</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract OrthoLH: width: float * height: float * znear: float * zfar: float -> Matrix
        /// <summary>Store a left-handed orthographic projection to a given matrix</summary>
        /// <param name="width">defines the viewport width</param>
        /// <param name="height">defines the viewport height</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract OrthoLHToRef: width: float * height: float * znear: float * zfar: float * result: Matrix -> unit
        /// <summary>Create a left-handed orthographic projection matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract OrthoOffCenterLH: left: float * right: float * bottom: float * top: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a left-handed orthographic projection into a given matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract OrthoOffCenterLHToRef: left: float * right: float * bottom: float * top: float * znear: float * zfar: float * result: Matrix -> unit
        /// <summary>Creates a right-handed orthographic projection matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract OrthoOffCenterRH: left: float * right: float * bottom: float * top: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a right-handed orthographic projection into a given matrix</summary>
        /// <param name="left">defines the viewport left coordinate</param>
        /// <param name="right">defines the viewport right coordinate</param>
        /// <param name="bottom">defines the viewport bottom coordinate</param>
        /// <param name="top">defines the viewport top coordinate</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract OrthoOffCenterRHToRef: left: float * right: float * bottom: float * top: float * znear: float * zfar: float * result: Matrix -> unit
        /// <summary>Creates a left-handed perspective projection matrix</summary>
        /// <param name="width">defines the viewport width</param>
        /// <param name="height">defines the viewport height</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract PerspectiveLH: width: float * height: float * znear: float * zfar: float -> Matrix
        /// <summary>Creates a left-handed perspective projection matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract PerspectiveFovLH: fov: float * aspect: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a left-handed perspective projection into a given matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        /// <param name="isVerticalFovFixed">defines it the fov is vertically fixed (default) or horizontally</param>
        abstract PerspectiveFovLHToRef: fov: float * aspect: float * znear: float * zfar: float * result: Matrix * ?isVerticalFovFixed: bool -> unit
        /// <summary>Creates a right-handed perspective projection matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        abstract PerspectiveFovRH: fov: float * aspect: float * znear: float * zfar: float -> Matrix
        /// <summary>Stores a right-handed perspective projection into a given matrix</summary>
        /// <param name="fov">defines the horizontal field of view</param>
        /// <param name="aspect">defines the aspect ratio</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        /// <param name="isVerticalFovFixed">defines it the fov is vertically fixed (default) or horizontally</param>
        abstract PerspectiveFovRHToRef: fov: float * aspect: float * znear: float * zfar: float * result: Matrix * ?isVerticalFovFixed: bool -> unit
        /// <summary>Stores a perspective projection for WebVR info a given matrix</summary>
        /// <param name="fov">defines the field of view</param>
        /// <param name="znear">defines the near clip plane</param>
        /// <param name="zfar">defines the far clip plane</param>
        /// <param name="result">defines the target matrix</param>
        /// <param name="rightHanded">defines if the matrix must be in right-handed mode (false by default)</param>
        abstract PerspectiveFovWebVRToRef: fov: MatrixStaticPerspectiveFovWebVRToRefFov * znear: float * zfar: float * result: Matrix * ?rightHanded: bool -> unit
        /// <summary>Computes a complete transformation matrix</summary>
        /// <param name="viewport">defines the viewport to use</param>
        /// <param name="world">defines the world matrix</param>
        /// <param name="view">defines the view matrix</param>
        /// <param name="projection">defines the projection matrix</param>
        /// <param name="zmin">defines the near clip plane</param>
        /// <param name="zmax">defines the far clip plane</param>
        abstract GetFinalMatrix: viewport: Viewport * world: Matrix * view: Matrix * projection: Matrix * zmin: float * zmax: float -> Matrix
        /// <summary>Extracts a 2x2 matrix from a given matrix and store the result in a Float32Array</summary>
        /// <param name="matrix">defines the matrix to use</param>
        abstract GetAsMatrix2x2: matrix: Matrix -> Float32Array
        /// <summary>Extracts a 3x3 matrix from a given matrix and store the result in a Float32Array</summary>
        /// <param name="matrix">defines the matrix to use</param>
        abstract GetAsMatrix3x3: matrix: Matrix -> Float32Array
        /// <summary>Compute the transpose of a given matrix</summary>
        /// <param name="matrix">defines the matrix to transpose</param>
        abstract Transpose: matrix: Matrix -> Matrix
        /// <summary>Compute the transpose of a matrix and store it in a target matrix</summary>
        /// <param name="matrix">defines the matrix to transpose</param>
        /// <param name="result">defines the target matrix</param>
        abstract TransposeToRef: matrix: Matrix * result: Matrix -> unit
        /// <summary>Computes a reflection matrix from a plane</summary>
        /// <param name="plane">defines the reflection plane</param>
        abstract Reflection: plane: Plane -> Matrix
        /// <summary>Computes a reflection matrix from a plane</summary>
        /// <param name="plane">defines the reflection plane</param>
        /// <param name="result">defines the target matrix</param>
        abstract ReflectionToRef: plane: Plane * result: Matrix -> unit
        /// <summary>Sets the given matrix as a rotation matrix composed from the 3 left handed axes</summary>
        /// <param name="xaxis">defines the value of the 1st axis</param>
        /// <param name="yaxis">defines the value of the 2nd axis</param>
        /// <param name="zaxis">defines the value of the 3rd axis</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromXYZAxesToRef: xaxis: Vector3 * yaxis: Vector3 * zaxis: Vector3 * result: Matrix -> unit
        /// <summary>Creates a rotation matrix from a quaternion and stores it in a target matrix</summary>
        /// <param name="quat">defines the quaternion to use</param>
        /// <param name="result">defines the target matrix</param>
        abstract FromQuaternionToRef: quat: Quaternion * result: Matrix -> unit

    type [<AllowNullLiteral>] MatrixStaticPerspectiveFovWebVRToRefFov =
        abstract upDegrees: float with get, set
        abstract downDegrees: float with get, set
        abstract leftDegrees: float with get, set
        abstract rightDegrees: float with get, set

    type [<AllowNullLiteral>] Plane =
        abstract normal: Vector3 with get, set
        abstract d: float with get, set
        /// Returns the plane coordinates as a new array of 4 elements [a, b, c, d].
        abstract asArray: unit -> ResizeArray<float>
        /// Returns a new plane copied from the current Plane.
        abstract clone: unit -> Plane
        /// Returns the string "Plane".
        abstract getClassName: unit -> string
        /// Returns the Plane hash code.
        abstract getHashCode: unit -> float
        /// Normalize the current Plane in place.
        /// Returns the updated Plane.
        abstract normalize: unit -> Plane
        /// Returns a new Plane as the result of the transformation of the current Plane by the given matrix.
        abstract transform: transformation: Matrix -> Plane
        /// Returns the dot product (float) of the point coordinates and the plane normal.
        abstract dotCoordinate: point: Vector3 -> float
        /// Updates the current Plane from the plane defined by the three given points.
        /// Returns the updated Plane.
        abstract copyFromPoints: point1: Vector3 * point2: Vector3 * point3: Vector3 -> Plane
        /// Boolean : True is the vector "direction"  is the same side than the plane normal.
        abstract isFrontFacingTo: direction: Vector3 * epsilon: float -> bool
        /// Returns the signed distance (float) from the given point to the Plane.
        abstract signedDistanceTo: point: Vector3 -> float

    type [<AllowNullLiteral>] PlaneStatic =
        /// Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0
        [<Emit "new $0($1...)">] abstract Create: a: float * b: float * c: float * d: float -> Plane
        /// Returns a new Plane from the given array.
        abstract FromArray: array: ArrayLike<float> -> Plane
        /// Returns a new Plane defined by the three given points.
        abstract FromPoints: point1: Vector3 * point2: Vector3 * point3: Vector3 -> Plane
        /// Returns a new Plane the normal vector to this plane at the given origin point.
        /// Note : the vector "normal" is updated because normalized.
        abstract FromPositionAndNormal: origin: Vector3 * normal: Vector3 -> Plane
        /// Returns the signed distance between the plane defined by the normal vector at the "origin"" point and the given other point.
        abstract SignedDistanceToPlaneFromPositionAndNormal: origin: Vector3 * normal: Vector3 * point: Vector3 -> float

    type [<AllowNullLiteral>] Viewport =
        abstract x: float with get, set
        abstract y: float with get, set
        abstract width: float with get, set
        abstract height: float with get, set
        abstract toGlobal: renderWidthOrEngine: U2<float, Engine> * renderHeight: float -> Viewport
        /// Returns a new Viewport copied from the current one.
        abstract clone: unit -> Viewport

    type [<AllowNullLiteral>] ViewportStatic =
        /// Creates a Viewport object located at (x, y) and sized (width, height).
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float * width: float * height: float -> Viewport

    type [<AllowNullLiteral>] Frustum =
        interface end

    type [<AllowNullLiteral>] FrustumStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Frustum
        /// Returns a new array of 6 Frustum planes computed by the given transformation matrix.
        abstract GetPlanes: transform: Matrix -> ResizeArray<Plane>
        abstract GetNearPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        abstract GetFarPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        abstract GetLeftPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        abstract GetRightPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        abstract GetTopPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        abstract GetBottomPlaneToRef: transform: Matrix * frustumPlane: Plane -> unit
        /// Sets the given array "frustumPlanes" with the 6 Frustum planes computed by the given transformation matrix.
        abstract GetPlanesToRef: transform: Matrix * frustumPlanes: ResizeArray<Plane> -> unit

    type [<RequireQualifiedAccess>] Space =
        | LOCAL = 0
        | WORLD = 1
        | BONE = 2

    type [<AllowNullLiteral>] Axis =
        abstract X: Vector3 with get, set
        abstract Y: Vector3 with get, set
        abstract Z: Vector3 with get, set

    type [<AllowNullLiteral>] AxisStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Axis

    type [<AllowNullLiteral>] BezierCurve =
        interface end

    type [<AllowNullLiteral>] BezierCurveStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> BezierCurve
        /// Returns the cubic Bezier interpolated value (float) at "t" (float) from the given x1, y1, x2, y2 floats.
        abstract interpolate: t: float * x1: float * y1: float * x2: float * y2: float -> float

    type [<RequireQualifiedAccess>] Orientation =
        | CW = 0
        | CCW = 1

    type [<AllowNullLiteral>] Angle =
        abstract _radians: obj with get, set
        /// Returns the Angle value in degrees (float).
        abstract degrees: (unit -> float) with get, set
        /// Returns the Angle value in radians (float).
        abstract radians: (unit -> float) with get, set

    type [<AllowNullLiteral>] AngleStatic =
        /// Creates an Angle object of "radians" radians (float).
        [<Emit "new $0($1...)">] abstract Create: radians: float -> Angle
        /// Returns a new Angle object valued with the angle value in radians between the two given vectors.
        abstract BetweenTwoPoints: a: Vector2 * b: Vector2 -> Angle
        /// Returns a new Angle object from the given float in radians.
        abstract FromRadians: radians: float -> Angle
        /// Returns a new Angle object from the given float in degrees.
        abstract FromDegrees: degrees: float -> Angle

    type [<AllowNullLiteral>] Arc2 =
        abstract startPoint: Vector2 with get, set
        abstract midPoint: Vector2 with get, set
        abstract endPoint: Vector2 with get, set
        abstract centerPoint: Vector2 with get, set
        abstract radius: float with get, set
        abstract angle: Angle with get, set
        abstract startAngle: Angle with get, set
        abstract orientation: Orientation with get, set

    type [<AllowNullLiteral>] Arc2Static =
        /// Creates an Arc object from the three given points : start, middle and end.
        [<Emit "new $0($1...)">] abstract Create: startPoint: Vector2 * midPoint: Vector2 * endPoint: Vector2 -> Arc2

    type [<AllowNullLiteral>] Path2 =
        abstract _points: obj with get, set
        abstract _length: obj with get, set
        abstract closed: bool with get, set
        /// Adds a new segment until the given coordinates (x, y) to the current Path2.
        /// Returns the updated Path2.
        abstract addLineTo: x: float * y: float -> Path2
        /// Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.
        /// Returns the updated Path2.
        abstract addArcTo: midX: float * midY: float * endX: float * endY: float * ?numberOfSegments: float -> Path2
        /// Closes the Path2.
        /// Returns the Path2.
        abstract close: unit -> Path2
        /// Returns the Path2 total length (float).
        abstract length: unit -> float
        /// Returns the Path2 internal array of points.
        abstract getPoints: unit -> ResizeArray<Vector2>
        /// Returns a new Vector2 located at a percentage of the Path2 total length on this path.
        abstract getPointAtLengthPosition: normalizedLengthPosition: float -> Vector2

    type [<AllowNullLiteral>] Path2Static =
        /// Creates a Path2 object from the starting 2D coordinates x and y.
        [<Emit "new $0($1...)">] abstract Create: x: float * y: float -> Path2
        /// Returns a new Path2 starting at the coordinates (x, y).
        abstract StartingAt: x: float * y: float -> Path2

    type [<AllowNullLiteral>] Path3D =
        abstract path: ResizeArray<Vector3> with get, set
        abstract _curve: obj with get, set
        abstract _distances: obj with get, set
        abstract _tangents: obj with get, set
        abstract _normals: obj with get, set
        abstract _binormals: obj with get, set
        abstract _raw: obj with get, set
        /// Returns the Path3D array of successive Vector3 designing its curve.
        abstract getCurve: unit -> ResizeArray<Vector3>
        /// Returns an array populated with tangent vectors on each Path3D curve point.
        abstract getTangents: unit -> ResizeArray<Vector3>
        /// Returns an array populated with normal vectors on each Path3D curve point.
        abstract getNormals: unit -> ResizeArray<Vector3>
        /// Returns an array populated with binormal vectors on each Path3D curve point.
        abstract getBinormals: unit -> ResizeArray<Vector3>
        /// Returns an array populated with distances (float) of the i-th point from the first curve point.
        abstract getDistances: unit -> ResizeArray<float>
        /// Forces the Path3D tangent, normal, binormal and distance recomputation.
        /// Returns the same object updated.
        abstract update: path: ResizeArray<Vector3> * ?firstNormal: Nullable<Vector3> -> Path3D
        abstract _compute: firstNormal: obj -> unit
        abstract _getFirstNonNullVector: index: obj -> unit
        abstract _getLastNonNullVector: index: obj -> unit
        abstract _normalVector: v0: obj * vt: obj * va: obj -> unit

    type [<AllowNullLiteral>] Path3DStatic =
        /// new Path3D(path, normal, raw)
        /// Creates a Path3D. A Path3D is a logical math object, so not a mesh.
        /// please read the description in the tutorial :  http://doc.babylonjs.com/tutorials/How_to_use_Path3D
        /// path : an array of Vector3, the curve axis of the Path3D
        /// normal (optional) : Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.
        /// raw (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.
        [<Emit "new $0($1...)">] abstract Create: path: ResizeArray<Vector3> * ?firstNormal: Nullable<Vector3> * ?raw: bool -> Path3D

    type [<AllowNullLiteral>] Curve3 =
        abstract _points: obj with get, set
        abstract _length: obj with get, set
        /// Returns the Curve3 stored array of successive Vector3
        abstract getPoints: unit -> ResizeArray<Vector3>
        /// Returns the computed length (float) of the curve.
        abstract length: unit -> float
        /// Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);
        /// This new Curve3 is built by translating and sticking the curveB at the end of the curveA.
        /// curveA and curveB keep unchanged.
        abstract ``continue``: curve: Curve3 -> Curve3
        abstract _computeLength: path: obj -> unit

    type [<AllowNullLiteral>] Curve3Static =
        /// <summary>Returns a Curve3 object along a Quadratic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#quadratic-bezier-curve</summary>
        /// <param name="v0">(Vector3) the origin point of the Quadratic Bezier</param>
        /// <param name="v1">(Vector3) the control point</param>
        /// <param name="v2">(Vector3) the end point of the Quadratic Bezier</param>
        /// <param name="nbPoints">(integer) the wanted number of points in the curve</param>
        abstract CreateQuadraticBezier: v0: Vector3 * v1: Vector3 * v2: Vector3 * nbPoints: float -> Curve3
        /// <summary>Returns a Curve3 object along a Cubic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#cubic-bezier-curve</summary>
        /// <param name="v0">(Vector3) the origin point of the Cubic Bezier</param>
        /// <param name="v1">(Vector3) the first control point</param>
        /// <param name="v2">(Vector3) the second control point</param>
        /// <param name="v3">(Vector3) the end point of the Cubic Bezier</param>
        /// <param name="nbPoints">(integer) the wanted number of points in the curve</param>
        abstract CreateCubicBezier: v0: Vector3 * v1: Vector3 * v2: Vector3 * v3: Vector3 * nbPoints: float -> Curve3
        /// <summary>Returns a Curve3 object along a Hermite Spline curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#hermite-spline</summary>
        /// <param name="p1">(Vector3) the origin point of the Hermite Spline</param>
        /// <param name="t1">(Vector3) the tangent vector at the origin point</param>
        /// <param name="p2">(Vector3) the end point of the Hermite Spline</param>
        /// <param name="t2">(Vector3) the tangent vector at the end point</param>
        /// <param name="nbPoints">(integer) the wanted number of points in the curve</param>
        abstract CreateHermiteSpline: p1: Vector3 * t1: Vector3 * p2: Vector3 * t2: Vector3 * nbPoints: float -> Curve3
        /// <summary>Returns a Curve3 object along a CatmullRom Spline curve :</summary>
        /// <param name="points">(array of Vector3) the points the spline must pass through. At least, four points required.</param>
        /// <param name="nbPoints">(integer) the wanted number of points between each curve control points.</param>
        abstract CreateCatmullRomSpline: points: ResizeArray<Vector3> * nbPoints: float -> Curve3
        /// A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.
        /// A Curve3 is designed from a series of successive Vector3.
        /// Tuto : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#curve3-object
        [<Emit "new $0($1...)">] abstract Create: points: ResizeArray<Vector3> -> Curve3

    type [<AllowNullLiteral>] PositionNormalVertex =
        abstract position: Vector3 with get, set
        abstract normal: Vector3 with get, set
        abstract clone: unit -> PositionNormalVertex

    type [<AllowNullLiteral>] PositionNormalVertexStatic =
        [<Emit "new $0($1...)">] abstract Create: ?position: Vector3 * ?normal: Vector3 -> PositionNormalVertex

    type [<AllowNullLiteral>] PositionNormalTextureVertex =
        abstract position: Vector3 with get, set
        abstract normal: Vector3 with get, set
        abstract uv: Vector2 with get, set
        abstract clone: unit -> PositionNormalTextureVertex

    type [<AllowNullLiteral>] PositionNormalTextureVertexStatic =
        [<Emit "new $0($1...)">] abstract Create: ?position: Vector3 * ?normal: Vector3 * ?uv: Vector2 -> PositionNormalTextureVertex

    type [<AllowNullLiteral>] Tmp =
        abstract Color3: ResizeArray<Color3> with get, set
        abstract Vector2: ResizeArray<Vector2> with get, set
        abstract Vector3: ResizeArray<Vector3> with get, set
        abstract Vector4: ResizeArray<Vector4> with get, set
        abstract Quaternion: ResizeArray<Quaternion> with get, set
        abstract Matrix: ResizeArray<Matrix> with get, set

    type [<AllowNullLiteral>] TmpStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Tmp

    type [<AllowNullLiteral>] SphericalPolynomial =
        abstract x: Vector3 with get, set
        abstract y: Vector3 with get, set
        abstract z: Vector3 with get, set
        abstract xx: Vector3 with get, set
        abstract yy: Vector3 with get, set
        abstract zz: Vector3 with get, set
        abstract xy: Vector3 with get, set
        abstract yz: Vector3 with get, set
        abstract zx: Vector3 with get, set
        abstract addAmbient: color: Color3 -> unit
        abstract scale: scale: float -> unit

    type [<AllowNullLiteral>] SphericalPolynomialStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SphericalPolynomial
        abstract getSphericalPolynomialFromHarmonics: harmonics: SphericalHarmonics -> SphericalPolynomial

    type [<AllowNullLiteral>] SphericalHarmonics =
        abstract L00: Vector3 with get, set
        abstract L1_1: Vector3 with get, set
        abstract L10: Vector3 with get, set
        abstract L11: Vector3 with get, set
        abstract L2_2: Vector3 with get, set
        abstract L2_1: Vector3 with get, set
        abstract L20: Vector3 with get, set
        abstract L21: Vector3 with get, set
        abstract L22: Vector3 with get, set
        abstract addLight: direction: Vector3 * color: Color3 * deltaSolidAngle: float -> unit
        abstract scale: scale: float -> unit
        abstract convertIncidentRadianceToIrradiance: unit -> unit
        abstract convertIrradianceToLambertianRadiance: unit -> unit

    type [<AllowNullLiteral>] SphericalHarmonicsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SphericalHarmonics
        abstract getsphericalHarmonicsFromPolynomial: polynomial: SphericalPolynomial -> SphericalHarmonics

    /// Defines a target to use with MorphTargetManager
    type [<AllowNullLiteral>] MorphTarget =
        inherit IAnimatable
        /// defines the name of the target 
        abstract name: string with get, set
        /// Gets or sets the list of animations
        abstract animations: ResizeArray<Animation> with get, set
        abstract _positions: obj with get, set
        abstract _normals: obj with get, set
        abstract _tangents: obj with get, set
        abstract _influence: obj with get, set
        /// Observable raised when the influence changes
        abstract onInfluenceChanged: Observable<bool> with get, set
        /// Gets or sets the influence of this target (ie. its weight in the overall morphing)
        abstract influence: float with get, set
        /// Gets a boolean defining if the target contains position data
        abstract hasPositions: bool
        /// Gets a boolean defining if the target contains normal data
        abstract hasNormals: bool
        /// Gets a boolean defining if the target contains tangent data
        abstract hasTangents: bool
        /// <summary>Affects position data to this target</summary>
        /// <param name="data">defines the position data to use</param>
        abstract setPositions: data: Nullable<FloatArray> -> unit
        /// Gets the position data stored in this target
        abstract getPositions: unit -> Nullable<FloatArray>
        /// <summary>Affects normal data to this target</summary>
        /// <param name="data">defines the normal data to use</param>
        abstract setNormals: data: Nullable<FloatArray> -> unit
        /// Gets the normal data stored in this target
        abstract getNormals: unit -> Nullable<FloatArray>
        /// <summary>Affects tangent data to this target</summary>
        /// <param name="data">defines the tangent data to use</param>
        abstract setTangents: data: Nullable<FloatArray> -> unit
        /// Gets the tangent data stored in this target
        abstract getTangents: unit -> Nullable<FloatArray>
        /// Serializes the current target into a Serialization object
        abstract serialize: unit -> obj option

    /// Defines a target to use with MorphTargetManager
    type [<AllowNullLiteral>] MorphTargetStatic =
        /// <summary>Creates a new MorphTarget</summary>
        /// <param name="name">defines the name of the target</param>
        /// <param name="influence">defines the influence to use</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?influence: float -> MorphTarget
        /// <summary>Creates a new target from serialized data</summary>
        /// <param name="serializationObject">defines the serialized data to use</param>
        abstract Parse: serializationObject: obj option -> MorphTarget
        /// <summary>Creates a MorphTarget from mesh data</summary>
        /// <param name="mesh">defines the source mesh</param>
        /// <param name="name">defines the name to use for the new target</param>
        /// <param name="influence">defines the influence to attach to the target</param>
        abstract FromMesh: mesh: AbstractMesh * ?name: string * ?influence: float -> MorphTarget

    /// This class is used to deform meshes using morphing between different targets
    type [<AllowNullLiteral>] MorphTargetManager =
        abstract _targets: obj with get, set
        abstract _targetObservable: obj with get, set
        abstract _activeTargets: obj with get, set
        abstract _scene: obj with get, set
        abstract _influences: obj with get, set
        abstract _supportsNormals: obj with get, set
        abstract _supportsTangents: obj with get, set
        abstract _vertexCount: obj with get, set
        abstract _uniqueId: obj with get, set
        abstract _tempInfluences: obj with get, set
        /// Gets the unique ID of this manager
        abstract uniqueId: float
        /// Gets the number of vertices handled by this manager
        abstract vertexCount: float
        /// Gets a boolean indicating if this manager supports morphing of normals
        abstract supportsNormals: bool
        /// Gets a boolean indicating if this manager supports morphing of tangents
        abstract supportsTangents: bool
        /// Gets the number of targets stored in this manager
        abstract numTargets: float
        /// Gets the number of influencers (ie. the number of targets with influences > 0)
        abstract numInfluencers: float
        /// Gets the list of influences (one per target)
        abstract influences: Float32Array
        /// <summary>Gets the active target at specified index. An active target is a target with an influence > 0</summary>
        /// <param name="index">defines the index to check</param>
        abstract getActiveTarget: index: float -> MorphTarget
        /// <summary>Gets the target at specified index</summary>
        /// <param name="index">defines the index to check</param>
        abstract getTarget: index: float -> MorphTarget
        /// <summary>Add a new target to this manager</summary>
        /// <param name="target">defines the target to add</param>
        abstract addTarget: target: MorphTarget -> unit
        /// <summary>Removes a target from the manager</summary>
        /// <param name="target">defines the target to remove</param>
        abstract removeTarget: target: MorphTarget -> unit
        /// Serializes the current manager into a Serialization object
        abstract serialize: unit -> obj option
        abstract _syncActiveTargets: needUpdate: obj -> unit
        /// Syncrhonize the targets with all the meshes using this morph target manager
        abstract synchronize: unit -> unit

    /// This class is used to deform meshes using morphing between different targets
    type [<AllowNullLiteral>] MorphTargetManagerStatic =
        /// <summary>Creates a new MorphTargetManager</summary>
        /// <param name="scene">defines the current scene</param>
        [<Emit "new $0($1...)">] abstract Create: ?scene: Nullable<Scene> -> MorphTargetManager
        /// <summary>Creates a new MorphTargetManager from serialized data</summary>
        /// <param name="serializationObject">defines the serialized data</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract Parse: serializationObject: obj option * scene: Scene -> MorphTargetManager

    /// This represents a GPU particle system in Babylon
    /// This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
    type [<AllowNullLiteral>] GPUParticleSystem =
        inherit IDisposable
        inherit IParticleSystem
        inherit IAnimatable
        /// The id of the Particle system.
        abstract id: string with get, set
        /// The friendly name of the Particle system.
        abstract name: string with get, set
        /// The emitter represents the Mesh or position we are attaching the particle system to.
        abstract emitter: Nullable<U2<AbstractMesh, Vector3>> with get, set
        /// The rendering group used by the Particle system to chose when to render.
        abstract renderingGroupId: float with get, set
        /// The layer mask we are rendering the particles through.
        abstract layerMask: float with get, set
        abstract _capacity: obj with get, set
        abstract _activeCount: obj with get, set
        abstract _currentActiveCount: obj with get, set
        abstract _renderEffect: obj with get, set
        abstract _updateEffect: obj with get, set
        abstract _buffer0: obj with get, set
        abstract _buffer1: obj with get, set
        abstract _spriteBuffer: obj with get, set
        abstract _updateVAO: obj with get, set
        abstract _renderVAO: obj with get, set
        abstract _targetIndex: obj with get, set
        abstract _sourceBuffer: obj with get, set
        abstract _targetBuffer: obj with get, set
        abstract _scene: obj with get, set
        abstract _engine: obj with get, set
        abstract _currentRenderId: obj with get, set
        abstract _started: obj with get, set
        abstract _stopped: obj with get, set
        abstract _timeDelta: obj with get, set
        abstract _randomTexture: obj with get, set
        abstract _attributesStrideSize: obj
        abstract _updateEffectOptions: obj with get, set
        abstract _randomTextureSize: obj with get, set
        abstract _actualFrame: obj with get, set
        /// List of animations used by the particle system.
        abstract animations: ResizeArray<Animation> with get, set
        /// Gets a boolean indicating if the GPU particles can be rendered on current browser
        abstract IsSupported: bool
        /// An event triggered when the system is disposed.
        abstract onDisposeObservable: Observable<GPUParticleSystem> with get, set
        /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
        abstract updateSpeed: float with get, set
        /// The amount of time the particle system is running (depends of the overall update speed).
        abstract targetStopDuration: float with get, set
        /// The texture used to render each particle. (this can be a spritesheet)
        abstract particleTexture: Nullable<Texture> with get, set
        /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
        abstract blendMode: float with get, set
        /// Minimum life time of emitting particles.
        abstract minLifeTime: float with get, set
        /// Maximum life time of emitting particles.
        abstract maxLifeTime: float with get, set
        /// Minimum Size of emitting particles.
        abstract minSize: float with get, set
        /// Maximum Size of emitting particles.
        abstract maxSize: float with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color1: Color4 with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color2: Color4 with get, set
        /// Color the particle will have at the end of its lifetime.
        abstract colorDead: Color4 with get, set
        /// The maximum number of particles to emit per frame until we reach the activeParticleCount value
        abstract emitRate: float with get, set
        /// You can use gravity if you want to give an orientation to your particles.
        abstract gravity: Vector3 with get, set
        /// Minimum power of emitting particles.
        abstract minEmitPower: float with get, set
        /// Maximum power of emitting particles.
        abstract maxEmitPower: float with get, set
        /// The particle emitter type defines the emitter used by the particle system.
        /// It can be for example box, sphere, or cone...
        abstract particleEmitterType: Nullable<IParticleEmitterType> with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract direction1: Vector3 with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract direction2: Vector3 with get, set
        /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract minEmitBox: Vector3 with get, set
        /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract maxEmitBox: Vector3 with get, set
        /// Gets the maximum number of particles active at the same time.
        abstract getCapacity: unit -> float
        /// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
        /// to override the particles.
        abstract forceDepthWrite: bool with get, set
        /// Gets or set the number of active particles
        abstract activeParticleCount: float with get, set
        /// Is this system ready to be used/rendered
        abstract isReady: unit -> bool
        /// Gets Wether the system has been started.
        abstract isStarted: unit -> bool
        /// Starts the particle system and begins to emit.
        abstract start: unit -> unit
        /// Stops the particle system.
        abstract stop: unit -> unit
        /// Remove all active particles
        abstract reset: unit -> unit
        /// Returns the string "GPUParticleSystem"
        abstract getClassName: unit -> string
        abstract _createUpdateVAO: source: obj -> unit
        abstract _createRenderVAO: source: obj * spriteSource: obj -> unit
        abstract _initialize: ?force: obj -> unit
        abstract _recreateUpdateEffect: unit -> unit
        abstract _recreateRenderEffect: unit -> unit
        /// Animates the particle system for the current frame by emitting new particles and or animating the living ones.
        abstract animate: unit -> unit
        /// Renders the particle system in its current state.
        abstract render: unit -> float
        /// Rebuilds the particle system
        abstract rebuild: unit -> unit
        abstract _releaseBuffers: unit -> unit
        abstract _releaseVAOs: unit -> unit
        /// <summary>Disposes the particle system and free the associated resources</summary>
        /// <param name="disposeTexture">defines if the particule texture must be disposed as well (true by default)</param>
        abstract dispose: ?disposeTexture: bool -> unit
        /// <summary>Clones the particle system.</summary>
        /// <param name="name">The name of the cloned object</param>
        /// <param name="newEmitter">The new emitter to use</param>
        abstract clone: name: string * newEmitter: obj option -> Nullable<GPUParticleSystem>
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option

    /// This represents a GPU particle system in Babylon
    /// This is the fastest particle system in Babylon as it uses the GPU to update the individual particle data
    type [<AllowNullLiteral>] GPUParticleSystemStatic =
        /// <summary>Instantiates a GPU particle system.
        /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.</summary>
        /// <param name="name">The name of the particle system</param>
        /// <param name="scene">The scene the particle system belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: obj * scene: Scene -> GPUParticleSystem
        /// <summary>Parses a JSON object to create a GPU particle system.</summary>
        /// <param name="parsedParticleSystem">The JSON object to parse</param>
        /// <param name="scene">The scene to create the particle system in</param>
        /// <param name="rootUrl">The root url to use to load external dependencies like texture</param>
        abstract Parse: parsedParticleSystem: obj option * scene: Scene * rootUrl: string -> GPUParticleSystem

    /// Interface representing a particle system in Babylon.
    /// This groups the common functionalities that needs to be implemented in order to create a particle system.
    /// A particle system represents a way to manage particles from their emission to their animation and rendering.
    type [<AllowNullLiteral>] IParticleSystem =
        /// The id of the Particle system.
        abstract id: string with get, set
        /// The name of the Particle system.
        abstract name: string with get, set
        /// The emitter represents the Mesh or position we are attaching the particle system to.
        abstract emitter: Nullable<U2<AbstractMesh, Vector3>> with get, set
        /// The rendering group used by the Particle system to chose when to render.
        abstract renderingGroupId: float with get, set
        /// The layer mask we are rendering the particles through.
        abstract layerMask: float with get, set
        /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
        abstract updateSpeed: float with get, set
        /// The amount of time the particle system is running (depends of the overall update speed).
        abstract targetStopDuration: float with get, set
        /// The texture used to render each particle. (this can be a spritesheet)
        abstract particleTexture: Nullable<Texture> with get, set
        /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
        abstract blendMode: float with get, set
        /// Minimum life time of emitting particles.
        abstract minLifeTime: float with get, set
        /// Maximum life time of emitting particles.
        abstract maxLifeTime: float with get, set
        /// Minimum Size of emitting particles.
        abstract minSize: float with get, set
        /// Maximum Size of emitting particles.
        abstract maxSize: float with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color1: Color4 with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color2: Color4 with get, set
        /// Color the particle will have at the end of its lifetime.
        abstract colorDead: Color4 with get, set
        /// The maximum number of particles to emit per frame until we reach the activeParticleCount value
        abstract emitRate: float with get, set
        /// You can use gravity if you want to give an orientation to your particles.
        abstract gravity: Vector3 with get, set
        /// Minimum power of emitting particles.
        abstract minEmitPower: float with get, set
        /// Maximum power of emitting particles.
        abstract maxEmitPower: float with get, set
        /// The particle emitter type defines the emitter used by the particle system.
        /// It can be for example box, sphere, or cone...
        abstract particleEmitterType: Nullable<IParticleEmitterType> with get, set
        /// Gets the maximum number of particles active at the same time.
        abstract getCapacity: unit -> float
        /// Gets Wether the system has been started.
        abstract isStarted: unit -> bool
        /// Animates the particle system for this frame.
        abstract animate: unit -> unit
        /// Renders the particle system in its current state.
        abstract render: unit -> float
        /// <summary>Dispose the particle system and frees its associated resources.</summary>
        /// <param name="disposeTexture">defines if the particule texture must be disposed as well (true by default)</param>
        abstract dispose: ?disposeTexture: bool -> unit
        /// <summary>Clones the particle system.</summary>
        /// <param name="name">The name of the cloned object</param>
        /// <param name="newEmitter">The new emitter to use</param>
        abstract clone: name: string * newEmitter: obj option -> Nullable<IParticleSystem>
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// Rebuild the particle system
        abstract rebuild: unit -> unit
        /// Starts the particle system and begins to emit.
        abstract start: unit -> unit
        /// Stops the particle system.
        abstract stop: unit -> unit
        /// Remove all active particles
        abstract reset: unit -> unit
        /// Is this system ready to be used/rendered
        abstract isReady: unit -> bool

    /// A particle represents one of the element emitted by a particle system.
    /// This is mainly define by its coordinates, direction, velocity and age.
    type [<AllowNullLiteral>] Particle =
        /// particleSystem the particle system the particle belongs to.
        abstract particleSystem: ParticleSystem with get, set
        /// The world position of the particle in the scene.
        abstract position: Vector3 with get, set
        /// The world direction of the particle in the scene.
        abstract direction: Vector3 with get, set
        /// The color of the particle.
        abstract color: Color4 with get, set
        /// The color change of the particle per step.
        abstract colorStep: Color4 with get, set
        /// Defines how long will the life of the particle be.
        abstract lifeTime: float with get, set
        /// The current age of the particle.
        abstract age: float with get, set
        /// The current size of the particle.
        abstract size: float with get, set
        /// The current angle of the particle.
        abstract angle: float with get, set
        /// Defines how fast is the angle changing.
        abstract angularSpeed: float with get, set
        /// Defines the cell index used by the particle to be rendered from a sprite.
        abstract cellIndex: float with get, set
        abstract _currentFrameCounter: obj with get, set
        abstract updateCellInfoFromSystem: unit -> unit
        /// Defines how the sprite cell index is updated for the particle. This is
        /// defined as a callback.
        abstract updateCellIndex: (float -> unit) with get, set
        abstract _updateCellIndexWithSpeedCalculated: scaledUpdateSpeed: obj -> unit
        abstract _updateCellIndexWithCustomSpeed: unit -> unit
        /// <summary>Copy the properties of particle to another one.</summary>
        /// <param name="other">the particle to copy the information to.</param>
        abstract copyTo: other: Particle -> unit

    /// A particle represents one of the element emitted by a particle system.
    /// This is mainly define by its coordinates, direction, velocity and age.
    type [<AllowNullLiteral>] ParticleStatic =
        /// <summary>Creates a new instance Particle</summary>
        /// <param name="particleSystem">the particle system the particle belongs to</param>
        [<Emit "new $0($1...)">] abstract Create: particleSystem: ParticleSystem -> Particle

    /// This represents a particle system in Babylon.
    /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
    /// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
    type [<AllowNullLiteral>] ParticleSystem =
        inherit IDisposable
        inherit IAnimatable
        inherit IParticleSystem
        /// Source color is added to the destination color without alpha affecting the result.
        abstract BLENDMODE_ONEONE: float with get, set
        /// Blend current color and particle color using particles alpha.
        abstract BLENDMODE_STANDARD: float with get, set
        /// List of animations used by the particle system.
        abstract animations: ResizeArray<Animation> with get, set
        /// The id of the Particle system.
        abstract id: string with get, set
        /// The friendly name of the Particle system.
        abstract name: string with get, set
        /// The rendering group used by the Particle system to chose when to render.
        abstract renderingGroupId: float with get, set
        /// The emitter represents the Mesh or position we are attaching the particle system to.
        abstract emitter: Nullable<U2<AbstractMesh, Vector3>> with get, set
        /// The maximum number of particles to emit per frame
        abstract emitRate: float with get, set
        /// If you want to launch only a few particles at once, that can be done, as well.
        abstract manualEmitCount: float with get, set
        /// The overall motion speed (0.01 is default update speed, faster updates = faster animation)
        abstract updateSpeed: float with get, set
        /// The amount of time the particle system is running (depends of the overall update speed).
        abstract targetStopDuration: float with get, set
        /// Specifies whether the particle system will be disposed once it reaches the end of the animation.
        abstract disposeOnStop: bool with get, set
        /// Minimum power of emitting particles.
        abstract minEmitPower: float with get, set
        /// Maximum power of emitting particles.
        abstract maxEmitPower: float with get, set
        /// Minimum life time of emitting particles.
        abstract minLifeTime: float with get, set
        /// Maximum life time of emitting particles.
        abstract maxLifeTime: float with get, set
        /// Minimum Size of emitting particles.
        abstract minSize: float with get, set
        /// Maximum Size of emitting particles.
        abstract maxSize: float with get, set
        /// Minimum angular speed of emitting particles (Z-axis rotation for each particle).
        abstract minAngularSpeed: float with get, set
        /// Maximum angular speed of emitting particles (Z-axis rotation for each particle).
        abstract maxAngularSpeed: float with get, set
        /// The texture used to render each particle. (this can be a spritesheet)
        abstract particleTexture: Nullable<Texture> with get, set
        /// The layer mask we are rendering the particles through.
        abstract layerMask: float with get, set
        /// This can help using your own shader to render the particle system.
        /// The according effect will be created
        abstract customShader: obj option with get, set
        /// By default particle system starts as soon as they are created. This prevents the
        /// automatic start to happen and let you decide when to start emitting particles.
        abstract preventAutoStart: bool with get, set
        /// This function can be defined to provide custom update for active particles.
        /// This function will be called instead of regular update (age, position, color, etc.).
        /// Do not forget that this function will be called on every frame so try to keep it simple and fast :)
        abstract updateFunction: (ResizeArray<Particle> -> unit) with get, set
        /// Callback triggered when the particle animation is ending.
        abstract onAnimationEnd: Nullable<(unit -> unit)> with get, set
        /// Blend mode use to render the particle, it can be either ParticleSystem.BLENDMODE_ONEONE or ParticleSystem.BLENDMODE_STANDARD.
        abstract blendMode: float with get, set
        /// Forces the particle to write their depth information to the depth buffer. This can help preventing other draw calls
        /// to override the particles.
        abstract forceDepthWrite: bool with get, set
        /// You can use gravity if you want to give an orientation to your particles.
        abstract gravity: Vector3 with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract direction1: Vector3 with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract direction2: Vector3 with get, set
        /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract minEmitBox: Vector3 with get, set
        /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        /// This only works when particleEmitterTyps is a BoxParticleEmitter
        abstract maxEmitBox: Vector3 with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color1: Color4 with get, set
        /// Random color of each particle after it has been emitted, between color1 and color2 vectors.
        abstract color2: Color4 with get, set
        /// Color the particle will have at the end of its lifetime.
        abstract colorDead: Color4 with get, set
        /// An optional mask to filter some colors out of the texture, or filter a part of the alpha channel.
        abstract textureMask: Color4 with get, set
        /// The particle emitter type defines the emitter used by the particle system.
        /// It can be for example box, sphere, or cone...
        abstract particleEmitterType: IParticleEmitterType with get, set
        /// This function can be defined to specify initial direction for every new particle.
        /// It by default use the emitterType defined function.
        abstract startDirectionFunction: (float -> Matrix -> Vector3 -> Particle -> unit) with get, set
        /// This function can be defined to specify initial position for every new particle.
        /// It by default use the emitterType defined function.
        abstract startPositionFunction: (Matrix -> Vector3 -> Particle -> unit) with get, set
        /// If using a spritesheet (isAnimationSheetEnabled), defines if the sprite animation should loop between startSpriteCellID and endSpriteCellID or not.
        abstract spriteCellLoop: bool with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the speed of the sprite loop.
        abstract spriteCellChangeSpeed: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the first sprite cell to display.
        abstract startSpriteCellID: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled) and spriteCellLoop defines the last sprite cell to display.
        abstract endSpriteCellID: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell width to use.
        abstract spriteCellWidth: float with get, set
        /// If using a spritesheet (isAnimationSheetEnabled), defines the sprite cell height to use.
        abstract spriteCellHeight: float with get, set
        /// An event triggered when the system is disposed.
        abstract onDisposeObservable: Observable<ParticleSystem> with get, set
        abstract _onDisposeObserver: obj with get, set
        /// Sets a callback that will be triggered when the system is disposed.
        abstract onDispose: (unit -> unit) with get, set
        /// Gets wether an animation sprite sheet is enabled or not on the particle system.
        abstract isAnimationSheetEnabled: Boolean
        abstract _particles: obj with get, set
        abstract _epsilon: obj with get, set
        abstract _capacity: obj with get, set
        abstract _scene: obj with get, set
        abstract _stockParticles: obj with get, set
        abstract _newPartsExcess: obj with get, set
        abstract _vertexData: obj with get, set
        abstract _vertexBuffer: obj with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _effect: obj with get, set
        abstract _customEffect: obj with get, set
        abstract _cachedDefines: obj with get, set
        abstract _scaledColorStep: obj with get, set
        abstract _colorDiff: obj with get, set
        abstract _scaledDirection: obj with get, set
        abstract _scaledGravity: obj with get, set
        abstract _currentRenderId: obj with get, set
        abstract _alive: obj with get, set
        abstract _started: obj with get, set
        abstract _stopped: obj with get, set
        abstract _actualFrame: obj with get, set
        abstract _scaledUpdateSpeed: obj with get, set
        abstract _vertexBufferSize: obj with get, set
        abstract _isAnimationSheetEnabled: obj with get, set
        /// this is the Sub-emitters templates that will be used to generate particle system when the particle dies, this property is used by the root particle system only.
        abstract subEmitters: ResizeArray<ParticleSystem> with get, set
        /// The current active Sub-systems, this property is used by the root particle system only.
        abstract activeSubSystems: Array<ParticleSystem> with get, set
        abstract _rootParticleSystem: obj with get, set
        /// Gets the current list of active particles
        abstract particles: ResizeArray<Particle>
        /// Returns the string "ParticleSystem"
        abstract getClassName: unit -> string
        abstract _createIndexBuffer: unit -> unit
        /// Gets the maximum number of particles active at the same time.
        abstract getCapacity: unit -> float
        /// Gets Wether there are still active particles in the system.
        abstract isAlive: unit -> bool
        /// Gets Wether the system has been started.
        abstract isStarted: unit -> bool
        /// Starts the particle system and begins to emit.
        abstract start: unit -> unit
        /// <summary>Stops the particle system.</summary>
        /// <param name="stopSubEmitters">if true it will stop the current system and all created sub-Systems if false it will stop the current root system only, this param is used by the root particle system only. the default value is true.</param>
        abstract stop: ?stopSubEmitters: bool -> unit
        /// Remove all active particles
        abstract reset: unit -> unit
        abstract _appendParticleVertex: index: float * particle: Particle * offsetX: float * offsetY: float -> unit
        abstract _appendParticleVertexWithAnimation: index: float * particle: Particle * offsetX: float * offsetY: float -> unit
        /// "Recycles" one of the particle by copying it back to the "stock" of particles and removing it from the active list.
        /// Its lifetime will start back at 0.
        abstract recycleParticle: (Particle -> unit) with get, set
        abstract _stopSubEmitters: unit -> unit
        abstract _createParticle: obj with get, set
        abstract _removeFromRoot: unit -> unit
        abstract _emitFromParticle: obj with get, set
        abstract _update: newParticles: obj -> unit
        abstract _getEffect: unit -> unit
        /// Animates the particle system for the current frame by emitting new particles and or animating the living ones.
        abstract animate: unit -> unit
        abstract _appendParticleVertexes: obj with get, set
        abstract _appenedParticleVertexesWithSheet: offset: obj * particle: obj -> unit
        abstract _appenedParticleVertexesNoSheet: offset: obj * particle: obj -> unit
        /// Rebuilds the particle system.
        abstract rebuild: unit -> unit
        /// Is this system ready to be used/rendered
        abstract isReady: unit -> bool
        /// Renders the particle system in its current state.
        abstract render: unit -> float
        /// <summary>Disposes the particle system and free the associated resources</summary>
        /// <param name="disposeTexture">defines if the particule texture must be disposed as well (true by default)</param>
        abstract dispose: ?disposeTexture: bool -> unit
        /// <summary>Creates a Sphere Emitter for the particle system. (emits along the sphere radius)</summary>
        /// <param name="radius">The radius of the sphere to emit from</param>
        abstract createSphereEmitter: ?radius: float -> SphereParticleEmitter
        /// <summary>Creates a Directed Sphere Emitter for the particle system. (emits between direction1 and direction2)</summary>
        /// <param name="radius">The radius of the sphere to emit from</param>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the sphere</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the sphere</param>
        abstract createDirectedSphereEmitter: ?radius: float * ?direction1: Vector3 * ?direction2: Vector3 -> SphereDirectedParticleEmitter
        /// <summary>Creates a Cone Emitter for the particle system. (emits from the cone to the particle position)</summary>
        /// <param name="radius">The radius of the cone to emit from</param>
        /// <param name="angle">The base angle of the cone</param>
        abstract createConeEmitter: ?radius: float * ?angle: float -> ConeParticleEmitter
        /// <summary>Creates a Box Emitter for the particle system. (emits between direction1 and direction2 from withing the box defined by minEmitBox and maxEmitBox)</summary>
        /// <param name="direction1">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="direction2">Particles are emitted between the direction1 and direction2 from within the box</param>
        /// <param name="minEmitBox">Particles are emitted from the box between minEmitBox and maxEmitBox</param>
        /// <param name="maxEmitBox">Particles are emitted from the box between minEmitBox and maxEmitBox</param>
        abstract createBoxEmitter: direction1: Vector3 * direction2: Vector3 * minEmitBox: Vector3 * maxEmitBox: Vector3 -> BoxParticleEmitter
        /// <summary>Clones the particle system.</summary>
        /// <param name="name">The name of the cloned object</param>
        /// <param name="newEmitter">The new emitter to use</param>
        abstract clone: name: string * newEmitter: obj option -> ParticleSystem
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option

    /// This represents a particle system in Babylon.
    /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.
    /// Particles can take different shapes while emitted like box, sphere, cone or you can write your custom function.
    type [<AllowNullLiteral>] ParticleSystemStatic =
        /// <summary>Instantiates a particle system.
        /// Particles are often small sprites used to simulate hard-to-reproduce phenomena like fire, smoke, water, or abstract visual effects like magic glitter and faery dust.</summary>
        /// <param name="name">The name of the particle system</param>
        /// <param name="capacity">The max number of particles alive at the same time</param>
        /// <param name="scene">The scene the particle system belongs to</param>
        /// <param name="customEffect">a custom effect used to change the way particles are rendered by default</param>
        /// <param name="isAnimationSheetEnabled">Must be true if using a spritesheet to animate the particles texture</param>
        /// <param name="epsilon">Offset used to render the particles</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * capacity: float * scene: Scene * ?customEffect: Nullable<Effect> * ?isAnimationSheetEnabled: bool * ?epsilon: float -> ParticleSystem
        /// <summary>Parses a JSON object to create a particle system.</summary>
        /// <param name="parsedParticleSystem">The JSON object to parse</param>
        /// <param name="scene">The scene to create the particle system in</param>
        /// <param name="rootUrl">The root url to use to load external dependencies like texture</param>
        abstract Parse: parsedParticleSystem: obj option * scene: Scene * rootUrl: string -> ParticleSystem

    /// Represents one particle of a solid particle system.
    type [<AllowNullLiteral>] SolidParticle =
        /// particle global index
        abstract idx: float with get, set
        /// The color of the particle
        abstract color: Nullable<Color4> with get, set
        /// The world space position of the particle.
        abstract position: Vector3 with get, set
        /// The world space rotation of the particle. (Not use if rotationQuaternion is set)
        abstract rotation: Vector3 with get, set
        /// The world space rotation quaternion of the particle.
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        /// The scaling of the particle.
        abstract scaling: Vector3 with get, set
        /// The uvs of the particle.
        abstract uvs: Vector4 with get, set
        /// The current speed of the particle.
        abstract velocity: Vector3 with get, set
        /// The pivot point in the particle local space.
        abstract pivot: Vector3 with get, set
        /// Must the particle be translated from its pivot point in its local space ?
        /// In this case, the pivot point is set at the origin of the particle local space and the particle is translated.
        /// Default : false
        abstract translateFromPivot: bool with get, set
        /// Is the particle active or not ?
        abstract alive: bool with get, set
        /// Is the particle visible or not ?
        abstract isVisible: bool with get, set
        /// Index of this particle in the global "positions" array (Internal use)
        abstract _pos: float with get, set
        /// Index of this particle in the global "indices" array (Internal use)
        abstract _ind: float with get, set
        /// ModelShape of this particle (Internal use)
        abstract _model: ModelShape with get, set
        /// ModelShape id of this particle
        abstract shapeId: float with get, set
        /// Index of the particle in its shape id (Internal use)
        abstract idxInShape: float with get, set
        /// Reference to the shape model BoundingInfo object (Internal use)
        abstract _modelBoundingInfo: BoundingInfo with get, set
        /// Particle BoundingInfo object (Internal use)
        abstract _boundingInfo: BoundingInfo with get, set
        /// Reference to the SPS what the particle belongs to (Internal use)
        abstract _sps: SolidParticleSystem with get, set
        /// Still set as invisible in order to skip useless computations (Internal use)
        abstract _stillInvisible: bool with get, set
        /// Last computed particle rotation matrix
        abstract _rotationMatrix: ResizeArray<float> with get, set
        /// Parent particle Id, if any.
        /// Default null.
        abstract parentId: Nullable<float> with get, set
        /// Internal global position in the SPS.
        abstract _globalPosition: Vector3 with get, set
        /// Legacy support, changed scale to scaling
        /// Legacy support, changed scale to scaling
        abstract scale: Vector3 with get, set
        /// Legacy support, changed quaternion to rotationQuaternion
        /// Legacy support, changed quaternion to rotationQuaternion
        abstract quaternion: Nullable<Quaternion> with get, set
        /// <summary>Returns a boolean. True if the particle intersects another particle or another mesh, else false.
        /// The intersection is computed on the particle bounding sphere and Axis Aligned Bounding Box (AABB)</summary>
        /// <param name="target">is the object (solid particle or mesh) what the intersection is computed against.</param>
        abstract intersectsMesh: target: U2<Mesh, SolidParticle> -> bool

    /// Represents one particle of a solid particle system.
    type [<AllowNullLiteral>] SolidParticleStatic =
        /// <summary>Creates a Solid Particle object.
        /// Don't create particles manually, use instead the Solid Particle System internal tools like _addParticle()</summary>
        /// <param name="particleIndex">(integer) is the particle index in the Solid Particle System pool. It's also the particle identifier.</param>
        /// <param name="positionIndex">(integer) is the starting index of the particle vertices in the SPS "positions" array.</param>
        /// <param name="indiceIndex">(integer) is the starting index of the particle indices in the SPS "indices" array.</param>
        /// <param name="model">(ModelShape) is a reference to the model shape on what the particle is designed.</param>
        /// <param name="shapeId">(integer) is the model shape identifier in the SPS.</param>
        /// <param name="idxInShape">(integer) is the index of the particle in the current model (ex: the 10th box of addShape(box, 30))</param>
        /// <param name="modelBoundingInfo">is the reference to the model BoundingInfo used for intersection computations.</param>
        [<Emit "new $0($1...)">] abstract Create: particleIndex: float * positionIndex: float * indiceIndex: float * model: Nullable<ModelShape> * shapeId: float * idxInShape: float * sps: SolidParticleSystem * ?modelBoundingInfo: Nullable<BoundingInfo> -> SolidParticle

    /// Represents the shape of the model used by one particle of a solid particle system.
    /// SPS internal tool, don't use it manually.
    type [<AllowNullLiteral>] ModelShape =
        /// The shape id.
        abstract shapeID: float with get, set
        /// flat array of model positions (internal use)
        abstract _shape: ResizeArray<Vector3> with get, set
        /// flat array of model UVs (internal use)
        abstract _shapeUV: ResizeArray<float> with get, set
        /// length of the shape in the model indices array (internal use)
        abstract _indicesLength: float with get, set
        /// Custom position function (internal use)
        abstract _positionFunction: Nullable<(SolidParticle -> float -> float -> unit)> with get, set
        /// Custom vertex function (internal use)
        abstract _vertexFunction: Nullable<(SolidParticle -> Vector3 -> float -> unit)> with get, set

    /// Represents the shape of the model used by one particle of a solid particle system.
    /// SPS internal tool, don't use it manually.
    type [<AllowNullLiteral>] ModelShapeStatic =
        /// Creates a ModelShape object. This is an internal simplified reference to a mesh used as for a model to replicate particles from by the SPS.
        /// SPS internal tool, don't use it manually.
        [<Emit "new $0($1...)">] abstract Create: id: float * shape: ResizeArray<Vector3> * indicesLength: float * shapeUV: ResizeArray<float> * posFunction: Nullable<(SolidParticle -> float -> float -> unit)> * vtxFunction: Nullable<(SolidParticle -> Vector3 -> float -> unit)> -> ModelShape

    /// Represents a Depth Sorted Particle in the solid particle system.
    type [<AllowNullLiteral>] DepthSortedParticle =
        /// Index of the particle in the "indices" array
        abstract ind: float with get, set
        /// Length of the particle shape in the "indices" array
        abstract indicesLength: float with get, set
        /// Squared distance from the particle to the camera
        abstract sqDistance: float with get, set

    /// Represents a Depth Sorted Particle in the solid particle system.
    type [<AllowNullLiteral>] DepthSortedParticleStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DepthSortedParticle

    /// The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
    /// As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
    /// 
    /// The SPS is also a particle system. It provides some methods to manage the particles.
    /// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
    /// 
    /// Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
    type [<AllowNullLiteral>] SolidParticleSystem =
        inherit IDisposable
        /// The SPS array of Solid Particle objects. Just access each particle as with any classic array.
        /// Example : var p = SPS.particles[i];
        abstract particles: ResizeArray<SolidParticle> with get, set
        /// The SPS total number of particles. Read only. Use SPS.counter instead if you need to set your own value.
        abstract nbParticles: float with get, set
        /// If the particles must ever face the camera (default false). Useful for planar particles.
        abstract billboard: bool with get, set
        /// Recompute normals when adding a shape
        abstract recomputeNormals: bool with get, set
        /// This a counter ofr your own usage. It's not set by any SPS functions.
        abstract counter: float with get, set
        /// The SPS name. This name is also given to the underlying mesh.
        abstract name: string with get, set
        /// The SPS mesh. It's a standard BJS Mesh, so all the methods from the Mesh class are avalaible.
        abstract mesh: Mesh with get, set
        /// This empty object is intended to store some SPS specific or temporary values in order to lower the Garbage Collector activity.
        /// Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#garbage-collector-concerns
        abstract vars: obj option with get, set
        /// This array is populated when the SPS is set as 'pickable'.
        /// Each key of this array is a `faceId` value that you can get from a pickResult object.
        /// Each element of this array is an object `{idx: int, faceId: int}`.
        /// `idx` is the picked particle index in the `SPS.particles` array
        /// `faceId` is the picked face index counted within this particle.
        /// Please read : http://doc.babylonjs.com/overviews/Solid_Particle_System#pickable-particles
        abstract pickedParticles: ResizeArray<obj> with get, set
        /// This array is populated when `enableDepthSort` is set to true.
        /// Each element of this array is an instance of the class DepthSortedParticle.
        abstract depthSortedParticles: ResizeArray<DepthSortedParticle> with get, set
        /// If the particle intersection must be computed only with the bounding sphere (no bounding box computation, so faster). (Internal use only)
        abstract _bSphereOnly: bool with get, set
        /// A number to multiply the boundind sphere radius by in order to reduce it for instance. (Internal use only)
        abstract _bSphereRadiusFactor: float with get, set
        abstract _scene: obj with get, set
        abstract _positions: obj with get, set
        abstract _indices: obj with get, set
        abstract _normals: obj with get, set
        abstract _colors: obj with get, set
        abstract _uvs: obj with get, set
        abstract _indices32: obj with get, set
        abstract _positions32: obj with get, set
        abstract _normals32: obj with get, set
        abstract _fixedNormal32: obj with get, set
        abstract _colors32: obj with get, set
        abstract _uvs32: obj with get, set
        abstract _index: obj with get, set
        abstract _updatable: obj with get, set
        abstract _pickable: obj with get, set
        abstract _isVisibilityBoxLocked: obj with get, set
        abstract _alwaysVisible: obj with get, set
        abstract _depthSort: obj with get, set
        abstract _shapeCounter: obj with get, set
        abstract _copy: obj with get, set
        abstract _shape: obj with get, set
        abstract _shapeUV: obj with get, set
        abstract _color: obj with get, set
        abstract _computeParticleColor: obj with get, set
        abstract _computeParticleTexture: obj with get, set
        abstract _computeParticleRotation: obj with get, set
        abstract _computeParticleVertex: obj with get, set
        abstract _computeBoundingBox: obj with get, set
        abstract _depthSortParticles: obj with get, set
        abstract _cam_axisZ: obj with get, set
        abstract _cam_axisY: obj with get, set
        abstract _cam_axisX: obj with get, set
        abstract _axisZ: obj with get, set
        abstract _camera: obj with get, set
        abstract _particle: obj with get, set
        abstract _camDir: obj with get, set
        abstract _camInvertedPosition: obj with get, set
        abstract _rotMatrix: obj with get, set
        abstract _invertMatrix: obj with get, set
        abstract _rotated: obj with get, set
        abstract _quaternion: obj with get, set
        abstract _vertex: obj with get, set
        abstract _normal: obj with get, set
        abstract _yaw: obj with get, set
        abstract _pitch: obj with get, set
        abstract _roll: obj with get, set
        abstract _halfroll: obj with get, set
        abstract _halfpitch: obj with get, set
        abstract _halfyaw: obj with get, set
        abstract _sinRoll: obj with get, set
        abstract _cosRoll: obj with get, set
        abstract _sinPitch: obj with get, set
        abstract _cosPitch: obj with get, set
        abstract _sinYaw: obj with get, set
        abstract _cosYaw: obj with get, set
        abstract _mustUnrotateFixedNormals: obj with get, set
        abstract _minimum: obj with get, set
        abstract _maximum: obj with get, set
        abstract _minBbox: obj with get, set
        abstract _maxBbox: obj with get, set
        abstract _particlesIntersect: obj with get, set
        abstract _depthSortFunction: obj with get, set
        abstract _needs32Bits: obj with get, set
        abstract _pivotBackTranslation: obj with get, set
        abstract _scaledPivot: obj with get, set
        abstract _particleHasParent: obj with get, set
        abstract _parent: obj with get, set
        /// Builds the SPS underlying mesh. Returns a standard Mesh.
        /// If no model shape was added to the SPS, the returned mesh is just a single triangular plane.
        abstract buildMesh: unit -> Mesh
        /// <summary>Digests the mesh and generates as many solid particles in the system as wanted. Returns the SPS.
        /// These particles will have the same geometry than the mesh parts and will be positioned at the same localisation than the mesh original places.
        /// Thus the particles generated from `digest()` have their property `position` set yet.</summary>
        /// <param name="mesh">( Mesh ) is the mesh to be digested</param>
        /// <param name="options">(optional integer, default 1) is the number of mesh facets per particle, this parameter is overriden by the parameter `number` if any
        /// {delta} (optional integer, default 0) is the random extra number of facets per particle , each particle will have between `facetNb` and `facetNb + delta` facets
        /// {number} (optional positive integer) is the wanted number of particles : each particle is built with `mesh_total_facets / number` facets</param>
        abstract digest: mesh: Mesh * ?options: SolidParticleSystemDigestOptions -> SolidParticleSystem
        abstract _unrotateFixedNormals: unit -> unit
        abstract _resetCopy: unit -> unit
        abstract _meshBuilder: p: obj * shape: obj * positions: obj * meshInd: obj * indices: obj * meshUV: obj * uvs: obj * meshCol: obj * colors: obj * meshNor: obj * normals: obj * idx: obj * idxInShape: obj * options: obj -> unit
        abstract _posToShape: positions: obj -> unit
        abstract _uvsToShapeUV: uvs: obj -> unit
        abstract _addParticle: idx: obj * idxpos: obj * idxind: obj * model: obj * shapeId: obj * idxInShape: obj * ?bInfo: obj -> unit
        /// <summary>Adds some particles to the SPS from the model shape. Returns the shape id.
        /// Please read the doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#create-an-immutable-sps</summary>
        /// <param name="mesh">is any Mesh object that will be used as a model for the solid particles.</param>
        /// <param name="nb">(positive integer) the number of particles to be created from this model</param>
        /// <param name="options">is an optional javascript function to called for each particle on SPS creation.
        /// {vertexFunction} is an optional javascript function to called for each vertex of each particle on SPS creation</param>
        abstract addShape: mesh: Mesh * nb: float * ?options: SolidParticleSystemAddShapeOptions -> float
        abstract _rebuildParticle: particle: obj -> unit
        /// Rebuilds the whole mesh and updates the VBO : custom positions and vertices are recomputed if needed.
        abstract rebuildMesh: unit -> SolidParticleSystem
        /// <summary>Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.
        /// This method calls `updateParticle()` for each particle of the SPS.
        /// For an animated SPS, it is usually called within the render loop.</summary>
        /// <param name="start">The particle index in the particle array where to start to compute the particle property values _(default 0)_</param>
        /// <param name="end">The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_</param>
        /// <param name="update">If the mesh must be finally updated on this call after all the particle computations _(default true)_</param>
        abstract setParticles: ?start: float * ?``end``: float * ?update: bool -> SolidParticleSystem
        abstract _quaternionRotationYPR: unit -> unit
        abstract _quaternionToRotationMatrix: unit -> unit
        /// Disposes the SPS.
        abstract dispose: unit -> unit
        /// Visibilty helper : Recomputes the visible size according to the mesh bounding box
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        abstract refreshVisibleSize: unit -> SolidParticleSystem
        /// <summary>Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.</summary>
        /// <param name="size">the size (float) of the visibility box
        /// note : this doesn't lock the SPS mesh bounding box.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility</param>
        abstract setVisibilityBox: size: float -> unit
        /// Gets whether the SPS as always visible or not
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        /// Sets the SPS as always visible or not
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        abstract isAlwaysVisible: bool with get, set
        /// Gets if the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        /// Sets the SPS visibility box as locked or not. This enables/disables the underlying mesh bounding box updates.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#sps-visibility
        abstract isVisibilityBoxLocked: bool with get, set
        /// Gets if `setParticles()` computes the particle rotations or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
        /// Tells to `setParticles()` to compute the particle rotations or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate.
        abstract computeParticleRotation: bool with get, set
        /// Gets if `setParticles()` computes the particle colors or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
        /// Tells to `setParticles()` to compute the particle colors or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.
        abstract computeParticleColor: bool with get, set
        /// Gets if `setParticles()` computes the particle textures or not.
        /// Default value : true. The SPS is faster when it's set to false.
        /// Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.
        abstract computeParticleTexture: bool with get, set
        /// Gets if `setParticles()` calls the vertex function for each vertex of each particle, or not.
        /// Default value : false. The SPS is faster when it's set to false.
        /// Note : the particle custom vertex positions aren't stored values.
        /// Tells to `setParticles()` to call the vertex function for each vertex of each particle, or not.
        /// Default value : false. The SPS is faster when it's set to false.
        /// Note : the particle custom vertex positions aren't stored values.
        abstract computeParticleVertex: bool with get, set
        /// Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.
        /// Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.
        abstract computeBoundingBox: bool with get, set
        /// Gets if `setParticles()` sorts or not the distance between each particle and the camera.
        /// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
        /// Default : `true`
        /// Tells to `setParticles()` to sort or not the distance between each particle and the camera.
        /// Skipped when `enableDepthSort` is set to `false` (default) at construction time.
        /// Default : `true`
        abstract depthSortParticles: bool with get, set
        /// This function does nothing. It may be overwritten to set all the particle first values.
        /// The SPS doesn't call this function, you may have to call it by your own.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management
        abstract initParticles: unit -> unit
        /// <summary>This function does nothing. It may be overwritten to recycle a particle.
        /// The SPS doesn't call this function, you may have to call it by your own.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management</summary>
        /// <param name="particle">The particle to recycle</param>
        abstract recycleParticle: particle: SolidParticle -> SolidParticle
        /// <summary>Updates a particle : this function should  be overwritten by the user.
        /// It is called on each particle by `setParticles()`. This is the place to code each particle behavior.
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#particle-management</summary>
        /// <param name="particle">The particle to update</param>
        abstract updateParticle: particle: SolidParticle -> SolidParticle
        /// <summary>Updates a vertex of a particle : it can be overwritten by the user.
        /// This will be called on each vertex particle by `setParticles()` if `computeParticleVertex` is set to true only.</summary>
        /// <param name="particle">the current particle</param>
        /// <param name="vertex">the current index of the current particle</param>
        /// <param name="pt">the index of the current vertex in the particle shape
        /// doc : http://doc.babylonjs.com/overviews/Solid_Particle_System#update-each-particle-shape</param>
        abstract updateParticleVertex: particle: SolidParticle * vertex: Vector3 * pt: float -> Vector3
        /// <summary>This will be called before any other treatment by `setParticles()` and will be passed three parameters.
        /// This does nothing and may be overwritten by the user.</summary>
        /// <param name="start">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="stop">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="update">the boolean update value actually passed to setParticles()</param>
        abstract beforeUpdateParticles: ?start: float * ?stop: float * ?update: bool -> unit
        /// <summary>This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.
        /// This will be passed three parameters.
        /// This does nothing and may be overwritten by the user.</summary>
        /// <param name="start">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="stop">the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()</param>
        /// <param name="update">the boolean update value actually passed to setParticles()</param>
        abstract afterUpdateParticles: ?start: float * ?stop: float * ?update: bool -> unit

    type [<AllowNullLiteral>] SolidParticleSystemDigestOptions =
        abstract facetNb: float option with get, set
        abstract number: float option with get, set
        abstract delta: float option with get, set

    type [<AllowNullLiteral>] SolidParticleSystemAddShapeOptions =
        abstract positionFunction: obj option with get, set
        abstract vertexFunction: obj option with get, set

    /// The SPS is a single updatable mesh. The solid particles are simply separate parts or faces fo this big mesh.
    /// As it is just a mesh, the SPS has all the same properties than any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.
    /// 
    /// The SPS is also a particle system. It provides some methods to manage the particles.
    /// However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.
    /// 
    /// Full documentation here : http://doc.babylonjs.com/overviews/Solid_Particle_System
    type [<AllowNullLiteral>] SolidParticleSystemStatic =
        /// <summary>Creates a SPS (Solid Particle System) object.</summary>
        /// <param name="name">(String) is the SPS name, this will be the underlying mesh name.</param>
        /// <param name="scene">(Scene) is the scene in which the SPS is added.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ?options: SolidParticleSystemStaticOptions -> SolidParticleSystem

    type [<AllowNullLiteral>] SolidParticleSystemStaticOptions =
        abstract updatable: bool option with get, set
        abstract isPickable: bool option with get, set
        abstract enableDepthSort: bool option with get, set
        abstract particleIntersection: bool option with get, set
        abstract boundingSphereOnly: bool option with get, set
        abstract bSphereRadiusFactor: float option with get, set

    type [<AllowNullLiteral>] PhysicsImpostorJoint =
        abstract mainImpostor: PhysicsImpostor with get, set
        abstract connectedImpostor: PhysicsImpostor with get, set
        abstract joint: PhysicsJoint with get, set

    type [<AllowNullLiteral>] PhysicsEngine =
        abstract _physicsPlugin: obj with get, set
        abstract gravity: Vector3 with get, set
        abstract setGravity: gravity: Vector3 -> unit
        /// <summary>Set the time step of the physics engine.
        /// default is 1/60.
        /// To slow it down, enter 1/600 for example.
        /// To speed it up, 1/30</summary>
        /// <param name="newTimeStep">the new timestep to apply to this world.</param>
        abstract setTimeStep: ?newTimeStep: float -> unit
        /// Get the time step of the physics engine.
        abstract getTimeStep: unit -> float
        abstract dispose: unit -> unit
        abstract getPhysicsPluginName: unit -> string
        abstract Epsilon: float with get, set
        abstract _impostors: obj with get, set
        abstract _joints: obj with get, set
        /// <summary>Adding a new impostor for the impostor tracking.
        /// This will be done by the impostor itself.</summary>
        /// <param name="impostor">the impostor to add</param>
        abstract addImpostor: impostor: PhysicsImpostor -> unit
        /// <summary>Remove an impostor from the engine.
        /// This impostor and its mesh will not longer be updated by the physics engine.</summary>
        /// <param name="impostor">the impostor to remove</param>
        abstract removeImpostor: impostor: PhysicsImpostor -> unit
        /// <summary>Add a joint to the physics engine</summary>
        /// <param name="mainImpostor">the main impostor to which the joint is added.</param>
        /// <param name="connectedImpostor">the impostor that is connected to the main impostor using this joint</param>
        abstract addJoint: mainImpostor: PhysicsImpostor * connectedImpostor: PhysicsImpostor * joint: PhysicsJoint -> unit
        abstract removeJoint: mainImpostor: PhysicsImpostor * connectedImpostor: PhysicsImpostor * joint: PhysicsJoint -> unit
        /// Called by the scene. no need to call it.
        abstract _step: delta: float -> unit
        abstract getPhysicsPlugin: unit -> IPhysicsEnginePlugin
        abstract getImpostors: unit -> Array<PhysicsImpostor>
        abstract getImpostorForPhysicsObject: ``object``: IPhysicsEnabledObject -> Nullable<PhysicsImpostor>
        abstract getImpostorWithPhysicsBody: body: obj option -> Nullable<PhysicsImpostor>

    type [<AllowNullLiteral>] PhysicsEngineStatic =
        [<Emit "new $0($1...)">] abstract Create: gravity: Nullable<Vector3> * ?_physicsPlugin: IPhysicsEnginePlugin -> PhysicsEngine

    type [<AllowNullLiteral>] IPhysicsEnginePlugin =
        abstract world: obj option with get, set
        abstract name: string with get, set
        abstract setGravity: gravity: Vector3 -> unit
        abstract setTimeStep: timeStep: float -> unit
        abstract getTimeStep: unit -> float
        abstract executeStep: delta: float * impostors: Array<PhysicsImpostor> -> unit
        abstract applyImpulse: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract applyForce: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract generatePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract removePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract generateJoint: joint: PhysicsImpostorJoint -> unit
        abstract removeJoint: joint: PhysicsImpostorJoint -> unit
        abstract isSupported: unit -> bool
        abstract setTransformationFromPhysicsBody: impostor: PhysicsImpostor -> unit
        abstract setPhysicsBodyTransformation: impostor: PhysicsImpostor * newPosition: Vector3 * newRotation: Quaternion -> unit
        abstract setLinearVelocity: impostor: PhysicsImpostor * velocity: Nullable<Vector3> -> unit
        abstract setAngularVelocity: impostor: PhysicsImpostor * velocity: Nullable<Vector3> -> unit
        abstract getLinearVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract getAngularVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract setBodyMass: impostor: PhysicsImpostor * mass: float -> unit
        abstract getBodyMass: impostor: PhysicsImpostor -> float
        abstract getBodyFriction: impostor: PhysicsImpostor -> float
        abstract setBodyFriction: impostor: PhysicsImpostor * friction: float -> unit
        abstract getBodyRestitution: impostor: PhysicsImpostor -> float
        abstract setBodyRestitution: impostor: PhysicsImpostor * restitution: float -> unit
        abstract sleepBody: impostor: PhysicsImpostor -> unit
        abstract wakeUpBody: impostor: PhysicsImpostor -> unit
        abstract updateDistanceJoint: joint: PhysicsJoint * maxDistance: float * ?minDistance: float -> unit
        abstract setMotor: joint: IMotorEnabledJoint * speed: float * ?maxForce: float * ?motorIndex: float -> unit
        abstract setLimit: joint: IMotorEnabledJoint * upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit
        abstract getRadius: impostor: PhysicsImpostor -> float
        abstract getBoxSizeToRef: impostor: PhysicsImpostor * result: Vector3 -> unit
        abstract syncMeshWithImpostor: mesh: AbstractMesh * impostor: PhysicsImpostor -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] PhysicsHelper =
        abstract _scene: obj with get, set
        abstract _physicsEngine: obj with get, set
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear. Defaults to Constant</param>
        abstract applyRadialExplosionImpulse: origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsRadialExplosionEvent>
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear. Defaults to Constant</param>
        abstract applyRadialExplosionForce: origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsRadialExplosionEvent>
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear. Defaults to Constant</param>
        abstract gravitationalField: origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsGravitationalFieldEvent>
        /// <param name="origin">the origin of the updraft</param>
        /// <param name="radius">the radius of the updraft</param>
        /// <param name="strength">the strength of the updraft</param>
        /// <param name="height">the height of the updraft</param>
        /// <param name="updraftMode">possible options: Center & Perpendicular. Defaults to Center</param>
        abstract updraft: origin: Vector3 * radius: float * strength: float * height: float * ?updraftMode: PhysicsUpdraftMode -> Nullable<PhysicsUpdraftEvent>
        /// <param name="origin">the of the vortex</param>
        /// <param name="radius">the radius of the vortex</param>
        /// <param name="strength">the strength of the vortex</param>
        /// <param name="height">the height of the vortex</param>
        abstract vortex: origin: Vector3 * radius: float * strength: float * height: float -> Nullable<PhysicsVortexEvent>

    type [<AllowNullLiteral>] PhysicsHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PhysicsHelper

    type [<AllowNullLiteral>] PhysicsRadialExplosionEvent =
        abstract _scene: obj with get, set
        abstract _sphere: obj with get, set
        abstract _sphereOptions: obj with get, set
        abstract _rays: obj with get, set
        abstract _dataFetched: obj with get, set
        /// Returns the data related to the radial explosion event (sphere & rays).
        abstract getData: unit -> PhysicsRadialExplosionEventData
        /// <summary>Returns the force and contact point of the impostor or false, if the impostor is not affected by the force/impulse.</summary>
        /// <param name="impostor"></param>
        /// <param name="origin">the origin of the explosion</param>
        /// <param name="radius">the explosion radius</param>
        /// <param name="strength">the explosion strength</param>
        /// <param name="falloff">possible options: Constant & Linear</param>
        abstract getImpostorForceAndContactPoint: impostor: PhysicsImpostor * origin: Vector3 * radius: float * strength: float * falloff: PhysicsRadialImpulseFalloff -> Nullable<PhysicsForceAndContactPoint>
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force"></param>
        abstract dispose: ?force: bool -> unit
        abstract _prepareSphere: unit -> unit
        abstract _intersectsWithSphere: impostor: obj * origin: obj * radius: obj -> unit

    type [<AllowNullLiteral>] PhysicsRadialExplosionEventStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PhysicsRadialExplosionEvent

    type [<AllowNullLiteral>] PhysicsGravitationalFieldEvent =
        abstract _physicsHelper: obj with get, set
        abstract _scene: obj with get, set
        abstract _origin: obj with get, set
        abstract _radius: obj with get, set
        abstract _strength: obj with get, set
        abstract _falloff: obj with get, set
        abstract _tickCallback: obj with get, set
        abstract _sphere: obj with get, set
        abstract _dataFetched: obj with get, set
        /// Returns the data related to the gravitational field event (sphere).
        abstract getData: unit -> PhysicsGravitationalFieldEventData
        /// Enables the gravitational field.
        abstract enable: unit -> unit
        /// Disables the gravitational field.
        abstract disable: unit -> unit
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force"></param>
        abstract dispose: ?force: bool -> unit
        abstract _tick: unit -> unit

    type [<AllowNullLiteral>] PhysicsGravitationalFieldEventStatic =
        [<Emit "new $0($1...)">] abstract Create: physicsHelper: PhysicsHelper * scene: Scene * origin: Vector3 * radius: float * strength: float * ?falloff: PhysicsRadialImpulseFalloff -> PhysicsGravitationalFieldEvent

    type [<AllowNullLiteral>] PhysicsUpdraftEvent =
        abstract _scene: obj with get, set
        abstract _origin: obj with get, set
        abstract _radius: obj with get, set
        abstract _strength: obj with get, set
        abstract _height: obj with get, set
        abstract _updraftMode: obj with get, set
        abstract _physicsEngine: obj with get, set
        abstract _originTop: obj with get, set
        abstract _originDirection: obj with get, set
        abstract _tickCallback: obj with get, set
        abstract _cylinder: obj with get, set
        abstract _cylinderPosition: obj with get, set
        abstract _dataFetched: obj with get, set
        /// Returns the data related to the updraft event (cylinder).
        abstract getData: unit -> PhysicsUpdraftEventData
        /// Enables the updraft.
        abstract enable: unit -> unit
        /// Disables the cortex.
        abstract disable: unit -> unit
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force"></param>
        abstract dispose: ?force: bool -> unit
        abstract getImpostorForceAndContactPoint: impostor: obj -> unit
        abstract _tick: unit -> unit
        abstract _prepareCylinder: unit -> unit
        abstract _intersectsWithCylinder: impostor: obj -> unit

    type [<AllowNullLiteral>] PhysicsUpdraftEventStatic =
        [<Emit "new $0($1...)">] abstract Create: _scene: Scene * _origin: Vector3 * _radius: float * _strength: float * _height: float * _updraftMode: PhysicsUpdraftMode -> PhysicsUpdraftEvent

    type [<AllowNullLiteral>] PhysicsVortexEvent =
        abstract _scene: obj with get, set
        abstract _origin: obj with get, set
        abstract _radius: obj with get, set
        abstract _strength: obj with get, set
        abstract _height: obj with get, set
        abstract _physicsEngine: obj with get, set
        abstract _originTop: obj with get, set
        abstract _centripetalForceThreshold: obj with get, set
        abstract _updraftMultiplier: obj with get, set
        abstract _tickCallback: obj with get, set
        abstract _cylinder: obj with get, set
        abstract _cylinderPosition: obj with get, set
        abstract _dataFetched: obj with get, set
        /// Returns the data related to the vortex event (cylinder).
        abstract getData: unit -> PhysicsVortexEventData
        /// Enables the vortex.
        abstract enable: unit -> unit
        /// Disables the cortex.
        abstract disable: unit -> unit
        /// <summary>Disposes the sphere.</summary>
        /// <param name="force"></param>
        abstract dispose: ?force: bool -> unit
        abstract getImpostorForceAndContactPoint: impostor: obj -> unit
        abstract _tick: unit -> unit
        abstract _prepareCylinder: unit -> unit
        abstract _intersectsWithCylinder: impostor: obj -> unit

    type [<AllowNullLiteral>] PhysicsVortexEventStatic =
        [<Emit "new $0($1...)">] abstract Create: _scene: Scene * _origin: Vector3 * _radius: float * _strength: float * _height: float -> PhysicsVortexEvent

    type [<RequireQualifiedAccess>] PhysicsRadialImpulseFalloff =
        | Constant = 0
        | Linear = 1

    type [<RequireQualifiedAccess>] PhysicsUpdraftMode =
        | Center = 0
        | Perpendicular = 1

    type [<AllowNullLiteral>] PhysicsForceAndContactPoint =
        abstract force: Vector3 with get, set
        abstract contactPoint: Vector3 with get, set

    type [<AllowNullLiteral>] PhysicsRadialExplosionEventData =
        abstract sphere: Mesh with get, set
        abstract rays: Array<Ray> with get, set

    type [<AllowNullLiteral>] PhysicsGravitationalFieldEventData =
        abstract sphere: Mesh with get, set

    type [<AllowNullLiteral>] PhysicsUpdraftEventData =
        abstract cylinder: Mesh with get, set

    type [<AllowNullLiteral>] PhysicsVortexEventData =
        abstract cylinder: Mesh with get, set

    type [<AllowNullLiteral>] PhysicsImpostorParameters =
        abstract mass: float with get, set
        abstract friction: float option with get, set
        abstract restitution: float option with get, set
        abstract nativeOptions: obj option with get, set
        abstract ignoreParent: bool option with get, set
        abstract disableBidirectionalTransformation: bool option with get, set

    type [<AllowNullLiteral>] IPhysicsEnabledObject =
        abstract position: Vector3 with get, set
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        abstract scaling: Vector3 with get, set
        abstract rotation: Vector3 option with get, set
        abstract parent: obj option with get, set
        abstract getBoundingInfo: unit -> BoundingInfo
        abstract computeWorldMatrix: force: bool -> Matrix
        abstract getWorldMatrix: unit -> Matrix
        abstract getChildMeshes: ?directDescendantsOnly: bool -> Array<AbstractMesh>
        abstract getVerticesData: kind: string -> Nullable<U2<Array<float>, Float32Array>>
        abstract getIndices: unit -> Nullable<IndicesArray>
        abstract getScene: unit -> Scene
        abstract getAbsolutePosition: unit -> Vector3
        abstract getAbsolutePivotPoint: unit -> Vector3
        abstract rotate: axis: Vector3 * amount: float * ?space: Space -> TransformNode
        abstract translate: axis: Vector3 * distance: float * ?space: Space -> TransformNode
        abstract setAbsolutePosition: absolutePosition: Vector3 -> TransformNode
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] PhysicsImpostor =
        abstract ``object``: IPhysicsEnabledObject with get, set
        abstract ``type``: float with get, set
        abstract _options: obj with get, set
        abstract _scene: obj with get, set
        abstract DEFAULT_OBJECT_SIZE: Vector3 with get, set
        abstract IDENTITY_QUATERNION: Quaternion with get, set
        abstract _physicsEngine: obj with get, set
        abstract _physicsBody: obj with get, set
        abstract _bodyUpdateRequired: obj with get, set
        abstract _onBeforePhysicsStepCallbacks: obj with get, set
        abstract _onAfterPhysicsStepCallbacks: obj with get, set
        abstract _onPhysicsCollideCallbacks: obj with get, set
        abstract _deltaPosition: obj with get, set
        abstract _deltaRotation: obj with get, set
        abstract _deltaRotationConjugated: obj with get, set
        abstract _parent: obj with get, set
        abstract _isDisposed: obj with get, set
        abstract _tmpVecs: obj with get, set
        abstract _tmpQuat: obj with get, set
        abstract isDisposed: bool
        abstract mass: float with get, set
        abstract friction: float with get, set
        abstract restitution: float with get, set
        abstract uniqueId: float with get, set
        abstract _joints: obj with get, set
        /// This function will completly initialize this impostor.
        /// It will create a new body - but only if this mesh has no parent.
        /// If it has, this impostor will not be used other than to define the impostor
        /// of the child mesh.
        abstract _init: unit -> unit
        abstract _getPhysicsParent: unit -> unit
        /// Should a new body be generated.
        abstract isBodyInitRequired: unit -> bool
        abstract setScalingUpdated: updated: bool -> unit
        /// Force a regeneration of this or the parent's impostor's body.
        /// Use under cautious - This will remove all joints already implemented.
        abstract forceUpdate: unit -> unit
        /// Gets the body that holds this impostor. Either its own, or its parent.
        /// Set the physics body. Used mainly by the physics engine/plugin
        abstract physicsBody: obj option with get, set
        abstract parent: Nullable<PhysicsImpostor> with get, set
        abstract resetUpdateFlags: unit -> unit
        abstract getObjectExtendSize: unit -> Vector3
        abstract getObjectCenter: unit -> Vector3
        /// Get a specific parametes from the options parameter.
        abstract getParam: paramName: string -> obj option
        /// Sets a specific parameter in the options given to the physics plugin
        abstract setParam: paramName: string * value: float -> unit
        /// Specifically change the body's mass option. Won't recreate the physics body object
        abstract setMass: mass: float -> unit
        abstract getLinearVelocity: unit -> Nullable<Vector3>
        abstract setLinearVelocity: velocity: Nullable<Vector3> -> unit
        abstract getAngularVelocity: unit -> Nullable<Vector3>
        abstract setAngularVelocity: velocity: Nullable<Vector3> -> unit
        /// Execute a function with the physics plugin native code.
        /// Provide a function the will have two variables - the world object and the physics body object.
        abstract executeNativeFunction: func: (obj option -> obj option -> unit) -> unit
        /// Register a function that will be executed before the physics world is stepping forward.
        abstract registerBeforePhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        abstract unregisterBeforePhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        /// Register a function that will be executed after the physics step
        abstract registerAfterPhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        abstract unregisterAfterPhysicsStep: func: (PhysicsImpostor -> unit) -> unit
        /// register a function that will be executed when this impostor collides against a different body.
        abstract registerOnPhysicsCollide: collideAgainst: U2<PhysicsImpostor, Array<PhysicsImpostor>> * func: (PhysicsImpostor -> PhysicsImpostor -> unit) -> unit
        abstract unregisterOnPhysicsCollide: collideAgainst: U2<PhysicsImpostor, Array<PhysicsImpostor>> * func: (PhysicsImpostor -> U2<PhysicsImpostor, Array<PhysicsImpostor>> -> unit) -> unit
        abstract _tmpQuat: obj with get, set
        abstract _tmpQuat2: obj with get, set
        abstract getParentsRotation: unit -> Quaternion
        /// this function is executed by the physics engine.
        abstract beforeStep: (unit -> unit) with get, set
        /// this function is executed by the physics engine.
        abstract afterStep: (unit -> unit) with get, set
        /// Legacy collision detection event support
        abstract onCollideEvent: Nullable<(PhysicsImpostor -> PhysicsImpostor -> unit)> with get, set
        abstract onCollide: (obj -> unit) with get, set
        /// Apply a force
        abstract applyForce: force: Vector3 * contactPoint: Vector3 -> PhysicsImpostor
        /// Apply an impulse
        abstract applyImpulse: force: Vector3 * contactPoint: Vector3 -> PhysicsImpostor
        /// A help function to create a joint.
        abstract createJoint: otherImpostor: PhysicsImpostor * jointType: float * jointData: PhysicsJointData -> PhysicsImpostor
        /// Add a joint to this impostor with a different impostor.
        abstract addJoint: otherImpostor: PhysicsImpostor * joint: PhysicsJoint -> PhysicsImpostor
        /// Will keep this body still, in a sleep mode.
        abstract sleep: unit -> PhysicsImpostor
        /// Wake the body up.
        abstract wakeUp: unit -> PhysicsImpostor
        abstract clone: newObject: IPhysicsEnabledObject -> Nullable<PhysicsImpostor>
        abstract dispose: unit -> unit
        abstract setDeltaPosition: position: Vector3 -> unit
        abstract setDeltaRotation: rotation: Quaternion -> unit
        abstract getBoxSizeToRef: result: Vector3 -> PhysicsImpostor
        abstract getRadius: unit -> float
        /// <summary>Sync a bone with this impostor</summary>
        /// <param name="bone">The bone to sync to the impostor.</param>
        /// <param name="boneMesh">The mesh that the bone is influencing.</param>
        /// <param name="jointPivot">The pivot of the joint / bone in local space.</param>
        /// <param name="distToJoint">Optional distance from the impostor to the joint.</param>
        /// <param name="adjustRotation">Optional quaternion for adjusting the local rotation of the bone.</param>
        abstract syncBoneWithImpostor: bone: Bone * boneMesh: AbstractMesh * jointPivot: Vector3 * ?distToJoint: float * ?adjustRotation: Quaternion -> unit
        /// <summary>Sync impostor to a bone</summary>
        /// <param name="bone">The bone that the impostor will be synced to.</param>
        /// <param name="boneMesh">The mesh that the bone is influencing.</param>
        /// <param name="jointPivot">The pivot of the joint / bone in local space.</param>
        /// <param name="distToJoint">Optional distance from the impostor to the joint.</param>
        /// <param name="adjustRotation">Optional quaternion for adjusting the local rotation of the bone.</param>
        /// <param name="boneAxis">Optional vector3 axis the bone is aligned with</param>
        abstract syncImpostorWithBone: bone: Bone * boneMesh: AbstractMesh * jointPivot: Vector3 * ?distToJoint: float * ?adjustRotation: Quaternion * ?boneAxis: Vector3 -> unit
        abstract NoImpostor: float with get, set
        abstract SphereImpostor: float with get, set
        abstract BoxImpostor: float with get, set
        abstract PlaneImpostor: float with get, set
        abstract MeshImpostor: float with get, set
        abstract CylinderImpostor: float with get, set
        abstract ParticleImpostor: float with get, set
        abstract HeightmapImpostor: float with get, set

    type [<AllowNullLiteral>] PhysicsImpostorStatic =
        [<Emit "new $0($1...)">] abstract Create: ``object``: IPhysicsEnabledObject * ``type``: float * ?_options: PhysicsImpostorParameters * ?_scene: Scene option -> PhysicsImpostor

    type [<AllowNullLiteral>] PhysicsJointData =
        abstract mainPivot: Vector3 option with get, set
        abstract connectedPivot: Vector3 option with get, set
        abstract mainAxis: Vector3 option with get, set
        abstract connectedAxis: Vector3 option with get, set
        abstract collision: bool option with get, set
        abstract nativeParams: obj option with get, set

    /// This is a holder class for the physics joint created by the physics plugin.
    /// It holds a set of functions to control the underlying joint.
    type [<AllowNullLiteral>] PhysicsJoint =
        abstract ``type``: float with get, set
        abstract jointData: PhysicsJointData with get, set
        abstract _physicsJoint: obj with get, set
        abstract _physicsPlugin: IPhysicsEnginePlugin with get, set
        abstract physicsJoint: obj option with get, set
        abstract physicsPlugin: IPhysicsEnginePlugin with get, set
        /// <summary>Execute a function that is physics-plugin specific.</summary>
        /// <param name="func">the function that will be executed.
        /// It accepts two parameters: the physics world and the physics joint.</param>
        abstract executeNativeFunction: func: (obj option -> obj option -> unit) -> unit
        abstract DistanceJoint: float with get, set
        abstract HingeJoint: float with get, set
        abstract BallAndSocketJoint: float with get, set
        abstract WheelJoint: float with get, set
        abstract SliderJoint: float with get, set
        abstract PrismaticJoint: float with get, set
        abstract UniversalJoint: float with get, set
        abstract Hinge2Joint: float with get, set
        abstract PointToPointJoint: float with get, set
        abstract SpringJoint: float with get, set
        abstract LockJoint: float with get, set

    /// This is a holder class for the physics joint created by the physics plugin.
    /// It holds a set of functions to control the underlying joint.
    type [<AllowNullLiteral>] PhysicsJointStatic =
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * jointData: PhysicsJointData -> PhysicsJoint

    /// A class representing a physics distance joint.
    type [<AllowNullLiteral>] DistanceJoint =
        inherit PhysicsJoint
        /// Update the predefined distance.
        abstract updateDistance: maxDistance: float * ?minDistance: float -> unit

    /// A class representing a physics distance joint.
    type [<AllowNullLiteral>] DistanceJointStatic =
        [<Emit "new $0($1...)">] abstract Create: jointData: DistanceJointData -> DistanceJoint

    type [<AllowNullLiteral>] MotorEnabledJoint =
        inherit PhysicsJoint
        inherit IMotorEnabledJoint
        /// <summary>Set the motor values.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="force">the force to apply</param>
        /// <param name="maxForce">max force for this motor.</param>
        abstract setMotor: ?force: float * ?maxForce: float -> unit
        /// Set the motor's limits.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.
        abstract setLimit: upperLimit: float * ?lowerLimit: float -> unit

    type [<AllowNullLiteral>] MotorEnabledJointStatic =
        [<Emit "new $0($1...)">] abstract Create: ``type``: float * jointData: PhysicsJointData -> MotorEnabledJoint

    /// This class represents a single hinge physics joint
    type [<AllowNullLiteral>] HingeJoint =
        inherit MotorEnabledJoint
        /// <summary>Set the motor values.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="force">the force to apply</param>
        /// <param name="maxForce">max force for this motor.</param>
        abstract setMotor: ?force: float * ?maxForce: float -> unit
        /// Set the motor's limits.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.
        abstract setLimit: upperLimit: float * ?lowerLimit: float -> unit

    /// This class represents a single hinge physics joint
    type [<AllowNullLiteral>] HingeJointStatic =
        [<Emit "new $0($1...)">] abstract Create: jointData: PhysicsJointData -> HingeJoint

    /// This class represents a dual hinge physics joint (same as wheel joint)
    type [<AllowNullLiteral>] Hinge2Joint =
        inherit MotorEnabledJoint
        /// <summary>Set the motor values.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="force">the force to apply</param>
        /// <param name="maxForce">max force for this motor.</param>
        abstract setMotor: ?force: float * ?maxForce: float * ?motorIndex: float -> unit
        /// <summary>Set the motor limits.
        /// Attention, this function is plugin specific. Engines won't react 100% the same.</summary>
        /// <param name="upperLimit">the upper limit</param>
        /// <param name="lowerLimit">lower limit</param>
        abstract setLimit: upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit

    /// This class represents a dual hinge physics joint (same as wheel joint)
    type [<AllowNullLiteral>] Hinge2JointStatic =
        [<Emit "new $0($1...)">] abstract Create: jointData: PhysicsJointData -> Hinge2Joint

    type [<AllowNullLiteral>] IMotorEnabledJoint =
        abstract physicsJoint: obj option with get, set
        abstract setMotor: ?force: float * ?maxForce: float * ?motorIndex: float -> unit
        abstract setLimit: upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit

    type [<AllowNullLiteral>] DistanceJointData =
        inherit PhysicsJointData
        abstract maxDistance: float with get, set

    type [<AllowNullLiteral>] SpringJointData =
        inherit PhysicsJointData
        abstract length: float with get, set
        abstract stiffness: float with get, set
        abstract damping: float with get, set

    type [<AllowNullLiteral>] AbstractMesh =
        inherit TransformNode
        inherit IDisposable
        inherit ICullable
        inherit IGetSetVerticesData
        abstract OCCLUSION_TYPE_NONE: float with get, set
        abstract OCCLUSION_TYPE_OPTIMISTIC: float with get, set
        abstract OCCLUSION_TYPE_STRICT: float with get, set
        abstract OCCLUSION_ALGORITHM_TYPE_ACCURATE: float with get, set
        abstract OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE: float with get, set
        abstract BILLBOARDMODE_NONE: float
        abstract BILLBOARDMODE_X: float
        abstract BILLBOARDMODE_Y: float
        abstract BILLBOARDMODE_Z: float
        abstract BILLBOARDMODE_ALL: float
        abstract _facetPositions: obj with get, set
        abstract _facetNormals: obj with get, set
        abstract _facetPartitioning: obj with get, set
        abstract _facetNb: obj with get, set
        abstract _partitioningSubdivisions: obj with get, set
        abstract _partitioningBBoxRatio: obj with get, set
        abstract _facetDataEnabled: obj with get, set
        abstract _facetParameters: obj with get, set
        abstract _bbSize: obj with get, set
        abstract _subDiv: obj with get, set
        abstract _facetDepthSort: obj with get, set
        abstract _facetDepthSortEnabled: obj with get, set
        abstract _depthSortedIndices: obj with get, set
        abstract _depthSortedFacets: obj with get, set
        abstract _facetDepthSortFunction: obj with get, set
        abstract _facetDepthSortFrom: obj with get, set
        abstract _facetDepthSortOrigin: obj with get, set
        abstract _invertedMatrix: obj with get, set
        /// Read-only : the number of facets in the mesh
        abstract facetNb: float
        /// The number (integer) of subdivisions per axis in the partioning space
        abstract partitioningSubdivisions: float with get, set
        /// The ratio (float) to apply to the bouding box size to set to the partioning space.
        /// Ex : 1.01 (default) the partioning space is 1% bigger than the bounding box.
        abstract partitioningBBoxRatio: float with get, set
        /// Boolean : must the facet be depth sorted on next call to `updateFacetData()` ?
        /// Works only for updatable meshes.
        /// Doesn't work with multi-materials.
        abstract mustDepthSortFacets: bool with get, set
        /// The location (Vector3) where the facet depth sort must be computed from.
        /// By default, the active camera position.
        /// Used only when facet depth sort is enabled.
        abstract facetDepthSortFrom: Vector3 with get, set
        /// Read-only boolean : is the feature facetData enabled ?
        abstract isFacetDataEnabled: bool
        abstract _updateNonUniformScalingState: value: bool -> bool
        /// An event triggered when this mesh collides with another one
        abstract onCollideObservable: Observable<AbstractMesh> with get, set
        abstract _onCollideObserver: obj with get, set
        abstract onCollide: (unit -> unit) with get, set
        /// An event triggered when the collision's position changes
        abstract onCollisionPositionChangeObservable: Observable<Vector3> with get, set
        abstract _onCollisionPositionChangeObserver: obj with get, set
        abstract onCollisionPositionChange: (unit -> unit) with get, set
        /// An event triggered when material is changed
        abstract onMaterialChangedObservable: Observable<AbstractMesh> with get, set
        abstract definedFacingForward: bool with get, set
        /// This property determines the type of occlusion query algorithm to run in WebGl, you can use:
        /// 
        /// AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE which is mapped to GL_ANY_SAMPLES_PASSED.
        /// 
        /// or
        /// 
        /// AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE (Default Value) which is mapped to GL_ANY_SAMPLES_PASSED_CONSERVATIVE which is a false positive algorithm that is faster than GL_ANY_SAMPLES_PASSED but less accurate.
        /// 
        /// for more info check WebGl documentations
        abstract occlusionQueryAlgorithmType: float with get, set
        /// This property is responsible for starting the occlusion query within the Mesh or not, this property is also used     to determine what should happen when the occlusionRetryCount is reached. It has supports 3 values:
        /// 
        /// OCCLUSION_TYPE_NONE (Default Value): this option means no occlusion query whith the Mesh.
        /// 
        /// OCCLUSION_TYPE_OPTIMISTIC: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken show the mesh.
        /// 
        ///    OCCLUSION_TYPE_STRICT: this option is means use occlusion query and if occlusionRetryCount is reached and the query is broken restore the last state of the mesh occlusion if the mesh was visible then show the mesh if was hidden then hide don't show.
        abstract occlusionType: float with get, set
        /// This number indicates the number of allowed retries before stop the occlusion query, this is useful if the        occlusion query is taking long time before to the query result is retireved, the query result indicates if the object is visible within the scene or not and based on that Babylon.Js engine decideds to show or hide the object.
        /// 
        /// The default value is -1 which means don't break the query and wait till the result.
        abstract occlusionRetryCount: float with get, set
        abstract _occlusionInternalRetryCounter: obj with get, set
        abstract _isOccluded: bool with get, set
        /// Property isOccluded : Gets or sets whether the mesh is occluded or not, it is used also to set the intial state of the mesh to be occluded or not.
        abstract isOccluded: bool with get, set
        abstract _isOcclusionQueryInProgress: obj with get, set
        /// Flag to check the progress status of the query
        abstract isOcclusionQueryInProgress: bool
        abstract _occlusionQuery: obj with get, set
        abstract _visibility: obj with get, set
        /// Gets or sets mesh visibility between 0 and 1 (defult is 1)
        /// Gets or sets mesh visibility between 0 and 1 (defult is 1)
        abstract visibility: float with get, set
        abstract alphaIndex: float with get, set
        abstract isVisible: bool with get, set
        abstract isPickable: bool with get, set
        abstract showBoundingBox: bool with get, set
        abstract showSubMeshesBoundingBox: bool with get, set
        abstract isBlocker: bool with get, set
        abstract enablePointerMoveEvents: bool with get, set
        abstract renderingGroupId: float with get, set
        abstract _material: obj with get, set
        abstract material: Nullable<Material> with get, set
        abstract _receiveShadows: obj with get, set
        abstract receiveShadows: bool with get, set
        abstract renderOutline: bool with get, set
        abstract outlineColor: Color3 with get, set
        abstract outlineWidth: float with get, set
        abstract renderOverlay: bool with get, set
        abstract overlayColor: Color3 with get, set
        abstract overlayAlpha: float with get, set
        abstract _hasVertexAlpha: obj with get, set
        abstract hasVertexAlpha: bool with get, set
        abstract _useVertexColors: obj with get, set
        abstract useVertexColors: bool with get, set
        abstract _computeBonesUsingShaders: obj with get, set
        abstract computeBonesUsingShaders: bool with get, set
        abstract _numBoneInfluencers: obj with get, set
        abstract numBoneInfluencers: float with get, set
        abstract _applyFog: obj with get, set
        abstract applyFog: bool with get, set
        abstract useOctreeForRenderingSelection: bool with get, set
        abstract useOctreeForPicking: bool with get, set
        abstract useOctreeForCollisions: bool with get, set
        abstract _layerMask: obj with get, set
        abstract layerMask: float with get, set
        /// True if the mesh must be rendered in any case.
        abstract alwaysSelectAsActiveMesh: bool with get, set
        /// This scene's action manager
        abstract actionManager: Nullable<ActionManager> with get, set
        abstract physicsImpostor: Nullable<PhysicsImpostor> with get, set
        abstract _checkCollisions: obj with get, set
        abstract _collisionMask: obj with get, set
        abstract _collisionGroup: obj with get, set
        abstract ellipsoid: Vector3 with get, set
        abstract ellipsoidOffset: Vector3 with get, set
        abstract _collider: obj with get, set
        abstract _oldPositionForCollisions: obj with get, set
        abstract _diffPositionForCollisions: obj with get, set
        abstract collisionMask: float with get, set
        abstract collisionGroup: float with get, set
        abstract edgesWidth: float with get, set
        abstract edgesColor: Color4 with get, set
        abstract _edgesRenderer: Nullable<EdgesRenderer> with get, set
        abstract _collisionsTransformMatrix: obj with get, set
        abstract _collisionsScalingMatrix: obj with get, set
        abstract _masterMesh: Nullable<AbstractMesh> with get, set
        abstract _boundingInfo: Nullable<BoundingInfo> with get, set
        abstract _renderId: float with get, set
        abstract subMeshes: ResizeArray<SubMesh> with get, set
        abstract _submeshesOctree: Octree<SubMesh> with get, set
        abstract _intersectionsInProgress: ResizeArray<AbstractMesh> with get, set
        abstract _unIndexed: bool with get, set
        abstract _lightSources: ResizeArray<Light> with get, set
        abstract _positions: Nullable<ResizeArray<Vector3>>
        abstract _waitingActions: obj option with get, set
        abstract _waitingFreezeWorldMatrix: Nullable<bool> with get, set
        abstract _skeleton: obj with get, set
        abstract _bonesTransformMatrices: Nullable<Float32Array> with get, set
        abstract skeleton: Nullable<Skeleton> with get, set
        /// Returns the string "AbstractMesh"
        abstract getClassName: unit -> string
        /// <param name="fullDetails">- support for multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string
        abstract _rebuild: unit -> unit
        abstract _resyncLightSources: unit -> unit
        abstract _resyncLighSource: light: Light -> unit
        abstract _unBindEffect: unit -> unit
        abstract _removeLightSource: light: Light -> unit
        abstract _markSubMeshesAsDirty: func: obj -> unit
        abstract _markSubMeshesAsLightDirty: unit -> unit
        abstract _markSubMeshesAsAttributesDirty: unit -> unit
        abstract _markSubMeshesAsMiscDirty: unit -> unit
        /// Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
        /// Default : (1.0, 1.0, 1.0)
        /// Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
        /// Default : (1.0, 1.0, 1.0)
        abstract scaling: Vector3 with get, set
        /// Disables the mesh edger rendering mode.
        /// Returns the AbstractMesh.
        abstract disableEdgesRendering: unit -> AbstractMesh
        /// Enables the edge rendering mode on the mesh.
        /// This mode makes the mesh edges visible.
        /// Returns the AbstractMesh.
        abstract enableEdgesRendering: ?epsilon: float * ?checkVerticesInsteadOfIndices: bool -> AbstractMesh
        /// Returns true if the mesh is blocked. Used by the class Mesh.
        /// Returns the boolean `false` by default.
        abstract isBlocked: bool
        /// Returns the mesh itself by default, used by the class Mesh.
        /// Returned type : AbstractMesh
        abstract getLOD: camera: Camera -> AbstractMesh
        /// Returns 0 by default, used by the class Mesh.
        /// Returns an integer.
        abstract getTotalVertices: unit -> float
        /// Returns null by default, used by the class Mesh.
        /// Returned type : integer array
        abstract getIndices: unit -> Nullable<IndicesArray>
        /// Returns the array of the requested vertex data kind. Used by the class Mesh. Returns null here.
        /// Returned type : float array or Float32Array
        abstract getVerticesData: kind: string -> Nullable<FloatArray>
        /// Sets the vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
        /// The `data` are either a numeric array either a Float32Array.
        /// The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
        /// The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
        /// Note that a new underlying VertexBuffer object is created each call.
        /// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> AbstractMesh
        /// Updates the existing vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, it is simply returned as it is.
        /// The `data` are either a numeric array either a Float32Array.
        /// No new underlying VertexBuffer object is created.
        /// If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> AbstractMesh
        /// Sets the mesh indices.
        /// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
        /// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
        /// This method creates a new index buffer each call.
        /// Returns the Mesh.
        abstract setIndices: indices: IndicesArray * totalVertices: Nullable<float> -> AbstractMesh
        /// Returns false by default, used by the class Mesh.
        /// Returns a boolean
        abstract isVerticesDataPresent: kind: string -> bool
        /// Returns the mesh BoundingInfo object or creates a new one and returns it if undefined.
        /// Returns a BoundingInfo
        abstract getBoundingInfo: unit -> BoundingInfo
        /// <summary>Uniformly scales the mesh to fit inside of a unit cube (1 X 1 X 1 units).</summary>
        /// <param name="includeDescendants">Take the hierarchy's bounding box instead of the mesh's bounding box.</param>
        abstract normalizeToUnitCube: ?includeDescendants: bool -> AbstractMesh
        /// Sets a mesh new object BoundingInfo.
        /// Returns the AbstractMesh.
        abstract setBoundingInfo: boundingInfo: BoundingInfo -> AbstractMesh
        abstract useBones: bool
        abstract _preActivate: unit -> unit
        abstract _preActivateForIntermediateRendering: renderId: float -> unit
        abstract _activate: renderId: float -> unit
        /// Returns the latest update of the World matrix
        /// Returns a Matrix.
        abstract getWorldMatrix: unit -> Matrix
        /// Returns the latest update of the World matrix determinant.
        abstract _getWorldMatrixDeterminant: unit -> float
        /// <summary>Perform relative position change from the point of view of behind the front of the mesh.
        /// This is performed taking into account the meshes current rotation, so you do not have to care.
        /// Supports definition of mesh facing forward or backward.</summary>
        /// <param name="amountRight"></param>
        /// <param name="amountUp"></param>
        /// <param name="amountForward">Returns the AbstractMesh.</param>
        abstract movePOV: amountRight: float * amountUp: float * amountForward: float -> AbstractMesh
        /// <summary>Calculate relative position change from the point of view of behind the front of the mesh.
        /// This is performed taking into account the meshes current rotation, so you do not have to care.
        /// Supports definition of mesh facing forward or backward.</summary>
        /// <param name="amountRight"></param>
        /// <param name="amountUp"></param>
        /// <param name="amountForward">Returns a new Vector3.</param>
        abstract calcMovePOV: amountRight: float * amountUp: float * amountForward: float -> Vector3
        /// <summary>Perform relative rotation change from the point of view of behind the front of the mesh.
        /// Supports definition of mesh facing forward or backward.</summary>
        /// <param name="flipBack"></param>
        /// <param name="twirlClockwise"></param>
        /// <param name="tiltRight">Returns the AbstractMesh.</param>
        abstract rotatePOV: flipBack: float * twirlClockwise: float * tiltRight: float -> AbstractMesh
        /// <summary>Calculate relative rotation change from the point of view of behind the front of the mesh.
        /// Supports definition of mesh facing forward or backward.</summary>
        /// <param name="flipBack"></param>
        /// <param name="twirlClockwise"></param>
        /// <param name="tiltRight">Returns a new Vector3.</param>
        abstract calcRotatePOV: flipBack: float * twirlClockwise: float * tiltRight: float -> Vector3
        /// <summary>Return the minimum and maximum world vectors of the entire hierarchy under current mesh</summary>
        /// <param name="includeDescendants">Include bounding info from descendants as well (true by default).</param>
        abstract getHierarchyBoundingVectors: ?includeDescendants: bool -> obj
        /// Updates the mesh BoundingInfo object and all its children BoundingInfo objects also.
        /// Returns the AbstractMesh.
        abstract _updateBoundingInfo: unit -> AbstractMesh
        /// Update a mesh's children BoundingInfo objects only.
        /// Returns the AbstractMesh.
        abstract _updateSubMeshesBoundingInfo: matrix: Matrix -> AbstractMesh
        abstract _afterComputeWorldMatrix: unit -> unit
        /// Returns `true` if the mesh is within the frustum defined by the passed array of planes.
        /// A mesh is in the frustum if its bounding box intersects the frustum.
        /// Boolean returned.
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// Returns `true` if the mesh is completely in the frustum defined be the passed array of planes.
        /// A mesh is completely in the frustum if its bounding box it completely inside the frustum.
        /// Boolean returned.
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// True if the mesh intersects another mesh or a SolidParticle object.
        /// Unless the parameter `precise` is set to `true` the intersection is computed according to Axis Aligned Bounding Boxes (AABB), else according to OBB (Oriented BBoxes)
        /// includeDescendants can be set to true to test if the mesh defined in parameters intersects with the current mesh or any child meshes
        /// Returns a boolean.
        abstract intersectsMesh: mesh: U2<AbstractMesh, SolidParticle> * ?precise: bool * ?includeDescendants: bool -> bool
        /// Returns true if the passed point (Vector3) is inside the mesh bounding box.
        /// Returns a boolean.
        abstract intersectsPoint: point: Vector3 -> bool
        abstract getPhysicsImpostor: unit -> Nullable<PhysicsImpostor>
        abstract getPositionInCameraSpace: ?camera: Nullable<Camera> -> Vector3
        /// Returns the distance from the mesh to the active camera.
        /// Returns a float.
        abstract getDistanceToCamera: ?camera: Nullable<Camera> -> float
        abstract applyImpulse: force: Vector3 * contactPoint: Vector3 -> AbstractMesh
        abstract setPhysicsLinkWith: otherMesh: Mesh * pivot1: Vector3 * pivot2: Vector3 * ?options: obj option -> AbstractMesh
        /// Property checkCollisions : Boolean, whether the camera should check the collisions against the mesh.
        /// Default `false`.
        abstract checkCollisions: bool with get, set
        /// Gets Collider object used to compute collisions (not physics)
        abstract collider: Collider
        abstract moveWithCollisions: displacement: Vector3 -> AbstractMesh
        abstract _onCollisionPositionChange: obj with get, set
        /// This function will create an octree to help to select the right submeshes for rendering, picking and collision computations.
        /// Please note that you must have a decent number of submeshes to get performance improvements when using an octree.
        /// Returns an Octree of submeshes.
        abstract createOrUpdateSubmeshesOctree: ?maxCapacity: float * ?maxDepth: float -> Octree<SubMesh>
        abstract _collideForSubMesh: subMesh: SubMesh * transformMatrix: Matrix * collider: Collider -> AbstractMesh
        abstract _processCollisionsForSubMeshes: collider: Collider * transformMatrix: Matrix -> AbstractMesh
        abstract _checkCollision: collider: Collider -> AbstractMesh
        abstract _generatePointsArray: unit -> bool
        /// Checks if the passed Ray intersects with the mesh.
        /// Returns an object PickingInfo.
        abstract intersects: ray: Ray * ?fastCheck: bool -> PickingInfo
        /// Clones the mesh, used by the class Mesh.
        /// Just returns `null` for an AbstractMesh.
        abstract clone: name: string * newParent: Node * ?doNotCloneChildren: bool -> Nullable<AbstractMesh>
        /// Disposes all the mesh submeshes.
        /// Returns the AbstractMesh.
        abstract releaseSubMeshes: unit -> AbstractMesh
        /// <summary>Releases resources associated with this abstract mesh.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        /// Adds the passed mesh as a child to the current mesh.
        /// Returns the AbstractMesh.
        abstract addChild: mesh: AbstractMesh -> AbstractMesh
        /// Removes the passed mesh from the current mesh children list.
        /// Returns the AbstractMesh.
        abstract removeChild: mesh: AbstractMesh -> AbstractMesh
        /// Initialize the facet data arrays : facetNormals, facetPositions and facetPartitioning.
        /// Returns the AbstractMesh.
        abstract _initFacetData: unit -> unit
        /// Updates the mesh facetData arrays and the internal partitioning when the mesh is morphed or updated.
        /// This method can be called within the render loop.
        /// You don't need to call this method by yourself in the render loop when you update/morph a mesh with the methods CreateXXX() as they automatically manage this computation.
        /// Returns the AbstractMesh.
        abstract updateFacetData: unit -> AbstractMesh
        /// Returns the facetLocalNormals array.
        /// The normals are expressed in the mesh local space.
        abstract getFacetLocalNormals: unit -> ResizeArray<Vector3>
        /// Returns the facetLocalPositions array.
        /// The facet positions are expressed in the mesh local space.
        abstract getFacetLocalPositions: unit -> ResizeArray<Vector3>
        /// Returns the facetLocalPartioning array.
        abstract getFacetLocalPartitioning: unit -> ResizeArray<ResizeArray<float>>
        /// Returns the i-th facet position in the world system.
        /// This method allocates a new Vector3 per call.
        abstract getFacetPosition: i: float -> Vector3
        /// Sets the reference Vector3 with the i-th facet position in the world system.
        /// Returns the AbstractMesh.
        abstract getFacetPositionToRef: i: float * ref: Vector3 -> AbstractMesh
        /// Returns the i-th facet normal in the world system.
        /// This method allocates a new Vector3 per call.
        abstract getFacetNormal: i: float -> Vector3
        /// Sets the reference Vector3 with the i-th facet normal in the world system.
        /// Returns the AbstractMesh.
        abstract getFacetNormalToRef: i: float * ref: Vector3 -> AbstractMesh
        /// Returns the facets (in an array) in the same partitioning block than the one the passed coordinates are located (expressed in the mesh local system).
        abstract getFacetsAtLocalCoordinates: x: float * y: float * z: float -> Nullable<ResizeArray<float>>
        /// Returns the closest mesh facet index at (x,y,z) World coordinates, null if not found.
        /// If the parameter projected (vector3) is passed, it is set as the (x,y,z) World projection on the facet.
        /// If checkFace is true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned.
        /// If facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position.
        /// If facing si false and checkFace is true, only the facet "turning their backs" to (x, y, z) are returned : negative dot (x, y, z) * facet position.
        abstract getClosestFacetAtCoordinates: x: float * y: float * z: float * ?projected: Vector3 * ?checkFace: bool * ?facing: bool -> Nullable<float>
        /// Returns the closest mesh facet index at (x,y,z) local coordinates, null if not found.
        /// If the parameter projected (vector3) is passed, it is set as the (x,y,z) local projection on the facet.
        /// If checkFace is true (default false), only the facet "facing" to (x,y,z) or only the ones "turning their backs", according to the parameter "facing" are returned.
        /// If facing and checkFace are true, only the facet "facing" to (x, y, z) are returned : positive dot (x, y, z) * facet position.
        /// If facing si false and checkFace is true, only the facet "turning their backs"  to (x, y, z) are returned : negative dot (x, y, z) * facet position.
        abstract getClosestFacetAtLocalCoordinates: x: float * y: float * z: float * ?projected: Vector3 * ?checkFace: bool * ?facing: bool -> Nullable<float>
        /// Returns the object "parameter" set with all the expected parameters for facetData computation by ComputeNormals()
        abstract getFacetDataParameters: unit -> obj option
        /// Disables the feature FacetData and frees the related memory.
        /// Returns the AbstractMesh.
        abstract disableFacetData: unit -> AbstractMesh
        /// Updates the AbstractMesh indices array. Actually, used by the Mesh object.
        /// Returns the mesh.
        abstract updateIndices: indices: IndicesArray -> AbstractMesh
        /// The mesh Geometry. Actually used by the Mesh object.
        /// Returns a blank geometry object.
        /// Creates new normals data for the mesh.
        abstract createNormals: updatable: bool -> unit
        /// Align the mesh with a normal.
        /// Returns the mesh.
        abstract alignWithNormal: normal: Vector3 * ?upDirection: Vector3 -> AbstractMesh
        abstract checkOcclusionQuery: unit -> unit

    type [<AllowNullLiteral>] AbstractMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Nullable<Scene> -> AbstractMesh

    type [<AllowNullLiteral>] Buffer =
        abstract _engine: obj with get, set
        abstract _buffer: obj with get, set
        abstract _data: obj with get, set
        abstract _updatable: obj with get, set
        abstract _instanced: obj with get, set
        /// Gets the byte stride.
        abstract byteStride: float
        /// <summary>Create a new {BABYLON.VertexBuffer} based on the current buffer</summary>
        /// <param name="kind">defines the vertex buffer kind (position, normal, etc.)</param>
        /// <param name="offset">defines offset in the buffer (0 by default)</param>
        /// <param name="size">defines the size in floats of attributes (position is 3 for instance)</param>
        /// <param name="stride">defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)</param>
        /// <param name="instanced">defines if the vertex buffer contains indexed data</param>
        /// <param name="useBytes">defines if the offset and stride are in bytes</param>
        abstract createVertexBuffer: kind: string * offset: float * size: float * ?stride: float * ?instanced: bool * ?useBytes: bool -> VertexBuffer
        abstract isUpdatable: unit -> bool
        abstract getData: unit -> Nullable<DataArray>
        abstract getBuffer: unit -> Nullable<WebGLBuffer>
        /// Gets the stride in float32 units (i.e. byte stride / 4).
        /// May not be an integer if the byte stride is not divisible by 4.
        /// DEPRECATED. Use byteStride instead.
        abstract getStrideSize: unit -> float
        abstract create: ?data: Nullable<DataArray> -> unit
        abstract _rebuild: unit -> unit
        abstract update: data: DataArray -> unit
        /// <summary>Updates the data directly.</summary>
        /// <param name="data">the new data</param>
        /// <param name="offset">the new offset</param>
        /// <param name="vertexCount">the vertex count (optional)</param>
        /// <param name="useBytes">set to true if the offset is in bytes</param>
        abstract updateDirectly: data: DataArray * offset: float * ?vertexCount: float * ?useBytes: bool -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] BufferStatic =
        /// <summary>Constructor</summary>
        /// <param name="engine">the engine</param>
        /// <param name="data">the data to use for this buffer</param>
        /// <param name="updatable">whether the data is updatable</param>
        /// <param name="stride">the stride (optional)</param>
        /// <param name="postponeInternalCreation">whether to postpone creating the internal WebGL buffer (optional)</param>
        /// <param name="instanced">whether the buffer is instanced (optional)</param>
        /// <param name="useBytes">set to true if the stride in in bytes (optional)</param>
        [<Emit "new $0($1...)">] abstract Create: engine: obj option * data: DataArray * updatable: bool * ?stride: float * ?postponeInternalCreation: bool * ?instanced: bool * ?useBytes: bool -> Buffer

    type [<AllowNullLiteral>] CSG =
        abstract polygons: obj with get, set
        abstract matrix: Matrix with get, set
        abstract position: Vector3 with get, set
        abstract rotation: Vector3 with get, set
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        abstract scaling: Vector3 with get, set
        abstract clone: unit -> CSG
        abstract union: csg: CSG -> CSG
        abstract unionInPlace: csg: CSG -> unit
        abstract subtract: csg: CSG -> CSG
        abstract subtractInPlace: csg: CSG -> unit
        abstract intersect: csg: CSG -> CSG
        abstract intersectInPlace: csg: CSG -> unit
        abstract inverse: unit -> CSG
        abstract inverseInPlace: unit -> unit
        abstract copyTransformAttributes: csg: CSG -> CSG
        abstract buildMeshGeometry: name: string * scene: Scene * keepSubMeshes: bool -> Mesh
        abstract toMesh: name: string * material: Nullable<Material> * scene: Scene * keepSubMeshes: bool -> Mesh

    type [<AllowNullLiteral>] CSGStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CSG
        abstract FromMesh: mesh: Mesh -> CSG
        abstract FromPolygons: polygons: obj -> unit

    /// Class used to store geometry data (vertex buffers + index buffer)
    type [<AllowNullLiteral>] Geometry =
        inherit IGetSetVerticesData
        /// Gets or sets the unique ID of the geometry
        abstract id: string with get, set
        /// Gets the delay loading state of the geometry (none by default which means not delayed)
        abstract delayLoadState: float with get, set
        /// Gets the file containing the data to load when running in delay load state
        abstract delayLoadingFile: Nullable<string> with get, set
        /// Callback called when the geometry is updated
        abstract onGeometryUpdated: (Geometry -> string -> unit) with get, set
        abstract _scene: obj with get, set
        abstract _engine: obj with get, set
        abstract _meshes: obj with get, set
        abstract _totalVertices: obj with get, set
        abstract _indices: obj with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _isDisposed: obj with get, set
        abstract _extend: obj with get, set
        abstract _boundingBias: obj with get, set
        abstract _delayInfo: Array<string> with get, set
        abstract _indexBuffer: obj with get, set
        abstract _indexBufferIsUpdatable: obj with get, set
        abstract _boundingInfo: Nullable<BoundingInfo> with get, set
        abstract _delayLoadingFunction: Nullable<(obj option -> Geometry -> unit)> with get, set
        abstract _softwareSkinningRenderId: float with get, set
        abstract _vertexArrayObjects: obj with get, set
        abstract _updatable: obj with get, set
        abstract _positions: Nullable<ResizeArray<Vector3>> with get, set
        /// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
        /// Gets or sets the Bias Vector to apply on the bounding elements (box/sphere), the max extend is computed as v += v * bias.x + bias.y, the min is computed as v -= v * bias.x + bias.y
        abstract boundingBias: Vector2 with get, set
        /// Gets the current extend of the geometry
        abstract extend: obj
        /// Gets the hosting scene
        abstract getScene: unit -> Scene
        /// Gets the hosting engine
        abstract getEngine: unit -> Engine
        /// Defines if the geometry is ready to use
        abstract isReady: unit -> bool
        /// Gets a value indicating that the geometry should not be serialized
        abstract doNotSerialize: bool
        abstract _rebuild: unit -> unit
        /// <summary>Affects all gemetry data in one call</summary>
        /// <param name="vertexData">defines the geometry data</param>
        /// <param name="updatable">defines if the geometry must be flagged as updatable (false as default)</param>
        abstract setAllVerticesData: vertexData: VertexData * ?updatable: bool -> unit
        /// <summary>Set specific vertex data</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="data">defines the vertex data to use</param>
        /// <param name="updatable">defines if the vertex must be flagged as updatable (false as default)</param>
        /// <param name="stride">defines the stride to use (0 by default). This value is deduced from the kind value if not specified</param>
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> unit
        /// <summary>Removes a specific vertex data</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract removeVerticesData: kind: string -> unit
        /// <summary>Affect a vertex buffer to the geometry. the vertexBuffer.getKind() function is used to determine where to store the data</summary>
        /// <param name="buffer">defines the vertex buffer to use</param>
        /// <param name="totalVertices">defines the total number of vertices for position kind (could be null)</param>
        abstract setVerticesBuffer: buffer: VertexBuffer * ?totalVertices: Nullable<float> -> unit
        /// <summary>Update a specific vertex buffer
        /// This function will directly update the underlying WebGLBuffer according to the passed numeric array or Float32Array
        /// It will do nothing if the buffer is not updatable</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="data">defines the data to use</param>
        /// <param name="offset">defines the offset in the target buffer where to store the data</param>
        /// <param name="useBytes">set to true if the offset is in bytes</param>
        abstract updateVerticesDataDirectly: kind: string * data: DataArray * offset: float * ?useBytes: bool -> unit
        /// <summary>Update a specific vertex buffer
        /// This function will create a new buffer if the current one is not updatable</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="data">defines the data to use</param>
        /// <param name="updateExtends">defines if the geometry extends must be recomputed (false by default)</param>
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool -> unit
        abstract _updateBoundingInfo: updateExtends: obj * data: obj -> unit
        abstract _bind: effect: Nullable<Effect> * ?indexToBind: Nullable<WebGLBuffer> -> unit
        /// Gets total number of vertices
        abstract getTotalVertices: unit -> float
        /// <summary>Gets a specific vertex data attached to this geometry. Float data is constructed if the vertex buffer data cannot be returned directly.</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        /// <param name="copyWhenShared">defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes</param>
        /// <param name="forceCopy">defines a boolean indicating that the returned array must be cloned upon returning it</param>
        abstract getVerticesData: kind: string * ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<FloatArray>
        /// <summary>Returns a boolean defining if the vertex data for the requested `kind` is updatable</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract isVertexBufferUpdatable: kind: string -> bool
        /// <summary>Gets a specific vertex buffer</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract getVertexBuffer: kind: string -> Nullable<VertexBuffer>
        /// Returns all vertex buffers
        abstract getVertexBuffers: unit -> Nullable<obj>
        /// <summary>Gets a boolean indicating if specific vertex buffer is present</summary>
        /// <param name="kind">defines the data kind (Position, normal, etc...)</param>
        abstract isVerticesDataPresent: kind: string -> bool
        /// Gets a list of all attached data kinds (Position, normal, etc...)
        abstract getVerticesDataKinds: unit -> ResizeArray<string>
        /// <summary>Update index buffer</summary>
        /// <param name="indices">defines the indices to store in the index buffer</param>
        /// <param name="offset">defines the offset in the target buffer where to store the data</param>
        abstract updateIndices: indices: IndicesArray * ?offset: float -> unit
        /// <summary>Creates a new index buffer</summary>
        /// <param name="indices">defines the indices to store in the index buffer</param>
        /// <param name="totalVertices">defines the total number of vertices (could be null)</param>
        /// <param name="updatable">defines if the index buffer must be flagged as updatable (false by default)</param>
        abstract setIndices: indices: IndicesArray * ?totalVertices: Nullable<float> * ?updatable: bool -> unit
        /// Return the total number of indices
        abstract getTotalIndices: unit -> float
        /// <summary>Gets the index buffer array</summary>
        /// <param name="copyWhenShared">defines if the returned array must be cloned upon returning it if the current geometry is shared between multiple meshes</param>
        abstract getIndices: ?copyWhenShared: bool -> Nullable<IndicesArray>
        /// Gets the index buffer
        abstract getIndexBuffer: unit -> Nullable<WebGLBuffer>
        abstract _releaseVertexArrayObject: ?effect: Nullable<Effect> -> unit
        /// <summary>Release the associated resources for a specific mesh</summary>
        /// <param name="mesh">defines the source mesh</param>
        /// <param name="shouldDispose">defines if the geometry must be disposed if there is no more mesh pointing to it</param>
        abstract releaseForMesh: mesh: Mesh * ?shouldDispose: bool -> unit
        /// <summary>Apply current geometry to a given mesh</summary>
        /// <param name="mesh">defines the mesh to apply geometry to</param>
        abstract applyToMesh: mesh: Mesh -> unit
        abstract _updateExtend: ?data: obj -> unit
        abstract _applyToMesh: mesh: obj -> unit
        abstract notifyUpdate: ?kind: obj -> unit
        /// <summary>Load the geometry if it was flagged as delay loaded</summary>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="onLoaded">defines a callback called when the geometry is loaded</param>
        abstract load: scene: Scene * ?onLoaded: (unit -> unit) -> unit
        abstract _queueLoad: scene: obj * ?onLoaded: obj -> unit
        /// Invert the geometry to move from a right handed system to a left handed one.
        abstract toLeftHanded: unit -> unit
        abstract _resetPointsArrayCache: unit -> unit
        abstract _generatePointsArray: unit -> bool
        /// Gets a value indicating if the geometry is disposed
        abstract isDisposed: unit -> bool
        abstract _disposeVertexArrayObjects: unit -> unit
        /// Free all associated resources
        abstract dispose: unit -> unit
        /// <summary>Clone the current geometry into a new geometry</summary>
        /// <param name="id">defines the unique ID of the new geometry</param>
        abstract copy: id: string -> Geometry
        /// Serialize the current geometry info (and not the vertices data) into a JSON object
        abstract serialize: unit -> obj option
        abstract toNumberArray: origin: obj -> unit
        /// Serialize all vertices data into a JSON oject
        abstract serializeVerticeData: unit -> obj option

    /// Class used to store geometry data (vertex buffers + index buffer)
    type [<AllowNullLiteral>] GeometryStatic =
        /// <summary>Static function used to attach a new empty geometry to a mesh</summary>
        /// <param name="mesh">defines the mesh to attach the geometry to</param>
        abstract CreateGeometryForMesh: mesh: Mesh -> Geometry
        /// <summary>Creates a new geometry</summary>
        /// <param name="id">defines the unique ID</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="vertexData">defines the {BABYLON.VertexData} used to get geometry data</param>
        /// <param name="updatable">defines if geometry must be updatable (false by default)</param>
        /// <param name="mesh">defines the mesh that will be associated with the geometry</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * ?vertexData: VertexData * ?updatable: bool * ?mesh: Nullable<Mesh> -> Geometry
        /// <summary>Extracts a clone of a mesh geometry</summary>
        /// <param name="mesh">defines the source mesh</param>
        /// <param name="id">defines the unique ID of the new geometry object</param>
        abstract ExtractFromMesh: mesh: Mesh * id: string -> Nullable<Geometry>
        /// You should now use Tools.RandomId(), this method is still here for legacy reasons.
        /// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
        /// Be aware Math.random() could cause collisions, but:
        /// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
        abstract RandomId: unit -> string
        abstract _ImportGeometry: parsedGeometry: obj option * mesh: Mesh -> unit
        abstract _CleanMatricesWeights: parsedGeometry: obj * mesh: obj -> unit
        /// <summary>Create a new geometry from persisted data (Using .babylon file format)</summary>
        /// <param name="parsedVertexData">defines the persisted data</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="rootUrl">defines the root url to use to load assets (like delayed data)</param>
        abstract Parse: parsedVertexData: obj option * scene: Scene * rootUrl: string -> Nullable<Geometry>

    /// Abstract class used to provide common services for all typed geometries
    type [<AllowNullLiteral>] _PrimitiveGeometry =
        inherit Geometry
        abstract _canBeRegenerated: obj with get, set
        abstract _beingRegenerated: obj with get, set
        /// Gets a value indicating if the geometry supports being regenerated with new parameters (false by default)
        abstract canBeRegenerated: unit -> bool
        /// If the geometry supports regeneration, the function will recreates the geometry with updated parameter values
        abstract regenerate: unit -> unit
        /// <summary>Clone the geometry</summary>
        /// <param name="id">defines the unique ID of the new geometry</param>
        abstract asNewGeometry: id: string -> Geometry
        abstract setAllVerticesData: vertexData: VertexData * ?updatable: bool -> unit
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool -> unit
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Abstract class used to provide common services for all typed geometries
    type [<AllowNullLiteral>] _PrimitiveGeometryStatic =
        /// <summary>Creates a new typed geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="_canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * ?_canBeRegenerated: bool * ?mesh: Nullable<Mesh> -> _PrimitiveGeometry

    /// Creates a ribbon geometry
    type [<AllowNullLiteral>] RibbonGeometry =
        inherit _PrimitiveGeometry
        /// Defines the array of paths to use
        abstract pathArray: ResizeArray<ResizeArray<Vector3>> with get, set
        /// Defines if the last and first points of each path in your pathArray must be joined
        abstract closeArray: bool with get, set
        /// Defines if the last and first points of each path in your pathArray must be joined
        abstract closePath: bool with get, set
        /// Defines the offset between points
        abstract offset: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry

    /// Creates a ribbon geometry
    type [<AllowNullLiteral>] RibbonGeometryStatic =
        /// <summary>Creates a ribbon geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="pathArray">defines the array of paths to use</param>
        /// <param name="closeArray">defines if the last path and the first path must be  joined</param>
        /// <param name="closePath">defines if the last and first points of each path in your pathArray must be joined</param>
        /// <param name="offset">defines the offset between points</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * pathArray: ResizeArray<ResizeArray<Vector3>> * closeArray: bool * closePath: bool * offset: float * ?canBeRegenerated: bool * ?mesh: Mesh * ?side: float -> RibbonGeometry

    /// Creates a box geometry
    type [<AllowNullLiteral>] BoxGeometry =
        inherit _PrimitiveGeometry
        /// Defines the zise of the box (width, height and depth are the same)
        abstract size: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a box geometry
    type [<AllowNullLiteral>] BoxGeometryStatic =
        /// <summary>Creates a box geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="size">defines the zise of the box (width, height and depth are the same)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * size: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> * ?side: float -> BoxGeometry
        abstract Parse: parsedBox: obj option * scene: Scene -> Nullable<BoxGeometry>

    /// Creates a sphere geometry
    type [<AllowNullLiteral>] SphereGeometry =
        inherit _PrimitiveGeometry
        /// Defines the number of segments to use to create the sphere
        abstract segments: float with get, set
        /// Defines the diameter of the sphere
        abstract diameter: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a sphere geometry
    type [<AllowNullLiteral>] SphereGeometryStatic =
        /// <summary>Create a new sphere geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="segments">defines the number of segments to use to create the sphere</param>
        /// <param name="diameter">defines the diameter of the sphere</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * segments: float * diameter: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> * ?side: float -> SphereGeometry
        abstract Parse: parsedSphere: obj option * scene: Scene -> Nullable<SphereGeometry>

    /// Creates a disc geometry
    type [<AllowNullLiteral>] DiscGeometry =
        inherit _PrimitiveGeometry
        /// Defines the radius of the disc
        abstract radius: float with get, set
        /// Defines the tesselation factor to apply to the disc
        abstract tessellation: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry

    /// Creates a disc geometry
    type [<AllowNullLiteral>] DiscGeometryStatic =
        /// <summary>Creates a new disc geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="radius">defines the radius of the disc</param>
        /// <param name="tessellation">defines the tesselation factor to apply to the disc</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * radius: float * tessellation: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> * ?side: float -> DiscGeometry

    /// Creates a new cylinder geometry
    type [<AllowNullLiteral>] CylinderGeometry =
        inherit _PrimitiveGeometry
        /// Defines the height of the cylinder
        abstract height: float with get, set
        /// Defines the diameter of the cylinder's top cap
        abstract diameterTop: float with get, set
        /// Defines the diameter of the cylinder's bottom cap
        abstract diameterBottom: float with get, set
        /// Defines the tessellation factor to apply to the cylinder
        abstract tessellation: float with get, set
        /// Defines the number of subdivisions to apply to the cylinder (1 by default)
        abstract subdivisions: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a new cylinder geometry
    type [<AllowNullLiteral>] CylinderGeometryStatic =
        /// <summary>Creates a new cylinder geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="height">defines the height of the cylinder</param>
        /// <param name="diameterTop">defines the diameter of the cylinder's top cap</param>
        /// <param name="diameterBottom">defines the diameter of the cylinder's bottom cap</param>
        /// <param name="tessellation">defines the tessellation factor to apply to the cylinder (number of radial sides)</param>
        /// <param name="subdivisions">defines the number of subdivisions to apply to the cylinder (number of rings) (1 by default)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * height: float * diameterTop: float * diameterBottom: float * tessellation: float * ?subdivisions: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> * ?side: float -> CylinderGeometry
        abstract Parse: parsedCylinder: obj option * scene: Scene -> Nullable<CylinderGeometry>

    /// Creates a new torus geometry
    type [<AllowNullLiteral>] TorusGeometry =
        inherit _PrimitiveGeometry
        /// Defines the diameter of the torus
        abstract diameter: float with get, set
        /// Defines the thickness of the torus (ie. internal diameter)
        abstract thickness: float with get, set
        /// Defines the tesselation factor to apply to the torus
        abstract tessellation: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a new torus geometry
    type [<AllowNullLiteral>] TorusGeometryStatic =
        /// <summary>Creates a new torus geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="diameter">defines the diameter of the torus</param>
        /// <param name="thickness">defines the thickness of the torus (ie. internal diameter)</param>
        /// <param name="tessellation">defines the tesselation factor to apply to the torus (number of segments along the circle)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * diameter: float * thickness: float * tessellation: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> * ?side: float -> TorusGeometry
        abstract Parse: parsedTorus: obj option * scene: Scene -> Nullable<TorusGeometry>

    /// Creates a new ground geometry
    type [<AllowNullLiteral>] GroundGeometry =
        inherit _PrimitiveGeometry
        /// Defines the width of the ground
        abstract width: float with get, set
        /// Defines the height of the ground
        abstract height: float with get, set
        /// Defines the subdivisions to apply to the ground
        abstract subdivisions: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a new ground geometry
    type [<AllowNullLiteral>] GroundGeometryStatic =
        /// <summary>Creates a new ground geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="width">defines the width of the ground</param>
        /// <param name="height">defines the height of the ground</param>
        /// <param name="subdivisions">defines the subdivisions to apply to the ground</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * width: float * height: float * subdivisions: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> -> GroundGeometry
        abstract Parse: parsedGround: obj option * scene: Scene -> Nullable<GroundGeometry>

    /// Creates a tiled ground geometry
    type [<AllowNullLiteral>] TiledGroundGeometry =
        inherit _PrimitiveGeometry
        /// Defines the minimum value on X axis
        abstract xmin: float with get, set
        /// Defines the minimum value on Z axis
        abstract zmin: float with get, set
        /// Defines the maximum value on X axis
        abstract xmax: float with get, set
        /// Defines the maximum value on Z axis
        abstract zmax: float with get, set
        /// Defines the subdivisions to apply to the ground
        abstract subdivisions: obj with get, set
        /// Defines the precision to use when computing the tiles
        abstract precision: obj with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry

    /// Creates a tiled ground geometry
    type [<AllowNullLiteral>] TiledGroundGeometryStatic =
        /// <summary>Creates a tiled ground geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="xmin">defines the minimum value on X axis</param>
        /// <param name="zmin">defines the minimum value on Z axis</param>
        /// <param name="xmax">defines the maximum value on X axis</param>
        /// <param name="zmax">defines the maximum value on Z axis</param>
        /// <param name="subdivisions">defines the subdivisions to apply to the ground (number of subdivisions (tiles) on the height and the width of the map)</param>
        /// <param name="precision">defines the precision to use when computing the tiles</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * xmin: float * zmin: float * xmax: float * zmax: float * subdivisions: TiledGroundGeometryStaticSubdivisions * precision: TiledGroundGeometryStaticPrecision * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> -> TiledGroundGeometry

    type [<AllowNullLiteral>] TiledGroundGeometryStaticSubdivisions =
        abstract w: float with get, set
        abstract h: float with get, set

    type [<AllowNullLiteral>] TiledGroundGeometryStaticPrecision =
        abstract w: float with get, set
        abstract h: float with get, set

    /// Creates a plane geometry
    type [<AllowNullLiteral>] PlaneGeometry =
        inherit _PrimitiveGeometry
        /// Defines the size of the plane (width === height)
        abstract size: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a plane geometry
    type [<AllowNullLiteral>] PlaneGeometryStatic =
        /// <summary>Creates a plane geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="size">defines the size of the plane (width === height)</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * size: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> * ?side: float -> PlaneGeometry
        abstract Parse: parsedPlane: obj option * scene: Scene -> Nullable<PlaneGeometry>

    /// Creates a torus knot geometry
    type [<AllowNullLiteral>] TorusKnotGeometry =
        inherit _PrimitiveGeometry
        /// Defines the radius of the torus knot
        abstract radius: float with get, set
        /// Defines the thickness of the torus knot tube
        abstract tube: float with get, set
        /// Defines the number of radial segments
        abstract radialSegments: float with get, set
        /// Defines the number of tubular segments
        abstract tubularSegments: float with get, set
        /// Defines the first number of windings
        abstract p: float with get, set
        /// Defines the second number of windings
        abstract q: float with get, set
        /// Defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)
        abstract side: float with get, set
        abstract _regenerateVertexData: unit -> VertexData
        abstract copy: id: string -> Geometry
        abstract serialize: unit -> obj option

    /// Creates a torus knot geometry
    type [<AllowNullLiteral>] TorusKnotGeometryStatic =
        /// <summary>Creates a torus knot geometry</summary>
        /// <param name="id">defines the unique ID of the geometry</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="radius">defines the radius of the torus knot</param>
        /// <param name="tube">defines the thickness of the torus knot tube</param>
        /// <param name="radialSegments">defines the number of radial segments</param>
        /// <param name="tubularSegments">defines the number of tubular segments</param>
        /// <param name="p">defines the first number of windings</param>
        /// <param name="q">defines the second number of windings</param>
        /// <param name="canBeRegenerated">defines if the geometry supports being regenerated with new parameters (false by default)</param>
        /// <param name="mesh">defines the hosting mesh (can be null)</param>
        /// <param name="side">defines if the created geometry is double sided or not (default is BABYLON.Mesh.DEFAULTSIDE)</param>
        [<Emit "new $0($1...)">] abstract Create: id: string * scene: Scene * radius: float * tube: float * radialSegments: float * tubularSegments: float * p: float * q: float * ?canBeRegenerated: bool * ?mesh: Nullable<Mesh> * ?side: float -> TorusKnotGeometry
        abstract Parse: parsedTorusKnot: obj option * scene: Scene -> Nullable<TorusKnotGeometry>

    type [<AllowNullLiteral>] GroundMesh =
        inherit Mesh
        abstract generateOctree: bool with get, set
        abstract _heightQuads: obj with get, set
        abstract _subdivisionsX: float with get, set
        abstract _subdivisionsY: float with get, set
        abstract _width: float with get, set
        abstract _height: float with get, set
        abstract _minX: float with get, set
        abstract _maxX: float with get, set
        abstract _minZ: float with get, set
        abstract _maxZ: float with get, set
        abstract getClassName: unit -> string
        abstract subdivisions: float
        abstract subdivisionsX: float
        abstract subdivisionsY: float
        abstract optimize: chunksCount: float * ?octreeBlocksSize: float -> unit
        /// Returns a height (y) value in the Worl system :
        /// the ground altitude at the coordinates (x, z) expressed in the World system.
        /// Returns the ground y position if (x, z) are outside the ground surface.
        abstract getHeightAtCoordinates: x: float * z: float -> float
        /// Returns a normalized vector (Vector3) orthogonal to the ground
        /// at the ground coordinates (x, z) expressed in the World system.
        /// Returns Vector3(0.0, 1.0, 0.0) if (x, z) are outside the ground surface.
        abstract getNormalAtCoordinates: x: float * z: float -> Vector3
        /// Updates the Vector3 passed a reference with a normalized vector orthogonal to the ground
        /// at the ground coordinates (x, z) expressed in the World system.
        /// Doesn't uptade the reference Vector3 if (x, z) are outside the ground surface.
        /// Returns the GroundMesh.
        abstract getNormalAtCoordinatesToRef: x: float * z: float * ref: Vector3 -> GroundMesh
        /// Force the heights to be recomputed for getHeightAtCoordinates() or getNormalAtCoordinates()
        /// if the ground has been updated.
        /// This can be used in the render loop.
        /// Returns the GroundMesh.
        abstract updateCoordinateHeights: unit -> GroundMesh
        abstract _getFacetAt: x: obj * z: obj -> unit
        abstract _initHeightQuads: unit -> unit
        abstract _computeHeightQuads: unit -> unit
        abstract serialize: serializationObject: obj option -> unit

    type [<AllowNullLiteral>] GroundMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> GroundMesh
        abstract Parse: parsedMesh: obj option * scene: Scene -> GroundMesh

    /// Creates an instance based on a source mesh.
    type [<AllowNullLiteral>] InstancedMesh =
        inherit AbstractMesh
        abstract _sourceMesh: obj with get, set
        abstract _currentLOD: obj with get, set
        /// Returns the string "InstancedMesh".
        abstract getClassName: unit -> string
        abstract receiveShadows: bool
        abstract material: Nullable<Material>
        abstract visibility: float
        abstract skeleton: Nullable<Skeleton>
        abstract renderingGroupId: float with get, set
        /// Returns the total number of vertices (integer).
        abstract getTotalVertices: unit -> float
        abstract sourceMesh: Mesh
        /// <summary>Is this node ready to be used/rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including materials and lights) has to be done (false by default)</param>
        abstract isReady: ?completeCheck: bool -> bool
        /// Returns a float array or a Float32Array of the requested kind of data : positons, normals, uvs, etc.
        abstract getVerticesData: kind: string * ?copyWhenShared: bool -> Nullable<FloatArray>
        /// Sets the vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
        /// The `data` are either a numeric array either a Float32Array.
        /// The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
        /// The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
        /// Note that a new underlying VertexBuffer object is created each call.
        /// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> Mesh
        /// Updates the existing vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, it is simply returned as it is.
        /// The `data` are either a numeric array either a Float32Array.
        /// No new underlying VertexBuffer object is created.
        /// If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> Mesh
        /// Sets the mesh indices.
        /// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
        /// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
        /// This method creates a new index buffer each call.
        /// Returns the Mesh.
        abstract setIndices: indices: IndicesArray * ?totalVertices: Nullable<float> -> Mesh
        /// Boolean : True if the mesh owns the requested kind of data.
        abstract isVerticesDataPresent: kind: string -> bool
        /// Returns an array of indices (IndicesArray).
        abstract getIndices: unit -> Nullable<IndicesArray>
        abstract _positions: Nullable<ResizeArray<Vector3>>
        /// Sets a new updated BoundingInfo to the mesh.
        /// Returns the mesh.
        abstract refreshBoundingInfo: unit -> InstancedMesh
        abstract _preActivate: unit -> InstancedMesh
        abstract _activate: renderId: float -> InstancedMesh
        /// Returns the current associated LOD AbstractMesh.
        abstract getLOD: camera: Camera -> AbstractMesh
        abstract _syncSubMeshes: unit -> InstancedMesh
        abstract _generatePointsArray: unit -> bool
        /// Creates a new InstancedMesh from the current mesh.
        /// - name (string) : the cloned mesh name
        /// - newParent (optional Node) : the optional Node to parent the clone to.
        /// - doNotCloneChildren (optional boolean, default `false`) : if `true` the model children aren't cloned.
        /// 
        /// Returns the clone.
        abstract clone: name: string * newParent: Node * ?doNotCloneChildren: bool -> InstancedMesh
        /// Disposes the InstancedMesh.
        /// Returns nothing.
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    /// Creates an instance based on a source mesh.
    type [<AllowNullLiteral>] InstancedMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * source: Mesh -> InstancedMesh

    type [<AllowNullLiteral>] LinesMesh =
        inherit Mesh
        abstract useVertexColor: bool option with get, set
        abstract useVertexAlpha: bool option with get, set
        abstract color: Color3 with get, set
        abstract alpha: float with get, set
        /// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
        /// This margin is expressed in world space coordinates, so its value may vary.
        /// Default value is 0.1
        /// The intersection Threshold is the margin applied when intersection a segment of the LinesMesh with a Ray.
        /// This margin is expressed in world space coordinates, so its value may vary.
        abstract intersectionThreshold: float with get, set
        abstract _intersectionThreshold: obj with get, set
        abstract _colorShader: obj with get, set
        /// Returns the string "LineMesh"
        abstract getClassName: unit -> string
        abstract material: Material with get, set
        abstract checkCollisions: bool
        abstract createInstance: name: string -> InstancedMesh
        abstract _bind: subMesh: SubMesh * effect: Effect * fillMode: float -> LinesMesh
        abstract _draw: subMesh: SubMesh * fillMode: float * ?instancesCount: float -> LinesMesh
        abstract dispose: ?doNotRecurse: bool -> unit
        /// Returns a new LineMesh object cloned from the current one.
        abstract clone: name: string * ?newParent: Node * ?doNotCloneChildren: bool -> LinesMesh

    type [<AllowNullLiteral>] LinesMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Nullable<Scene> * ?parent: Nullable<Node> * ?source: LinesMesh * ?doNotCloneChildren: bool * ?useVertexColor: bool option * ?useVertexAlpha: bool option -> LinesMesh

    type [<AllowNullLiteral>] _InstancesBatch =
        abstract mustReturn: bool with get, set
        abstract visibleInstances: ResizeArray<Nullable<ResizeArray<InstancedMesh>>> with get, set
        abstract renderSelf: ResizeArray<bool> with get, set

    type [<AllowNullLiteral>] _InstancesBatchStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _InstancesBatch

    type [<AllowNullLiteral>] Mesh =
        inherit AbstractMesh
        inherit IGetSetVerticesData
        abstract _FRONTSIDE: float with get, set
        abstract _BACKSIDE: float with get, set
        abstract _DOUBLESIDE: float with get, set
        abstract _DEFAULTSIDE: float with get, set
        abstract _NO_CAP: float with get, set
        abstract _CAP_START: float with get, set
        abstract _CAP_END: float with get, set
        abstract _CAP_ALL: float with get, set
        /// Mesh side orientation : usually the external or front surface
        abstract FRONTSIDE: float
        /// Mesh side orientation : usually the internal or back surface
        abstract BACKSIDE: float
        /// Mesh side orientation : both internal and external or front and back surfaces
        abstract DOUBLESIDE: float
        /// Mesh side orientation : by default, `FRONTSIDE`
        abstract DEFAULTSIDE: float
        /// Mesh cap setting : no cap
        abstract NO_CAP: float
        /// Mesh cap setting : one cap at the beginning of the mesh
        abstract CAP_START: float
        /// Mesh cap setting : one cap at the end of the mesh
        abstract CAP_END: float
        /// Mesh cap setting : two caps, one at the beginning  and one at the end of the mesh
        abstract CAP_ALL: float
        /// An event triggered before rendering the mesh
        abstract onBeforeRenderObservable: Observable<Mesh> with get, set
        /// An event triggered after rendering the mesh
        abstract onAfterRenderObservable: Observable<Mesh> with get, set
        /// An event triggered before drawing the mesh
        abstract onBeforeDrawObservable: Observable<Mesh> with get, set
        abstract _onBeforeDrawObserver: obj with get, set
        abstract onBeforeDraw: (unit -> unit) with get, set
        abstract delayLoadState: float with get, set
        abstract instances: ResizeArray<InstancedMesh> with get, set
        abstract delayLoadingFile: string with get, set
        abstract _binaryInfo: obj option with get, set
        abstract _LODLevels: obj with get, set
        abstract onLODLevelSelection: (float -> Mesh -> Mesh -> unit) with get, set
        abstract _morphTargetManager: obj with get, set
        abstract morphTargetManager: Nullable<MorphTargetManager> with get, set
        abstract _geometry: Nullable<Geometry> with get, set
        abstract _delayInfo: Array<string> with get, set
        abstract _delayLoadingFunction: (obj option -> Mesh -> unit) with get, set
        abstract _visibleInstances: obj option with get, set
        abstract _renderIdForInstances: obj with get, set
        abstract _batchCache: obj with get, set
        abstract _instancesBufferSize: obj with get, set
        abstract _instancesBuffer: obj with get, set
        abstract _instancesData: obj with get, set
        abstract _overridenInstanceCount: obj with get, set
        abstract _effectiveMaterial: obj with get, set
        abstract _shouldGenerateFlatShading: bool with get, set
        abstract _preActivateId: obj with get, set
        abstract _originalBuilderSideOrientation: float with get, set
        abstract overrideMaterialSideOrientation: Nullable<float> with get, set
        abstract _areNormalsFrozen: obj with get, set
        abstract _sourcePositions: obj with get, set
        abstract _sourceNormals: obj with get, set
        abstract _source: obj with get, set
        abstract source: Nullable<Mesh>
        abstract isUnIndexed: bool with get, set
        /// Returns the string "Mesh".
        abstract getClassName: unit -> string
        /// <summary>Returns a string.</summary>
        /// <param name="fullDetails">- support for multiple levels of logging within scene loading</param>
        abstract toString: ?fullDetails: bool -> string
        abstract _unBindEffect: unit -> unit
        /// True if the mesh has some Levels Of Details (LOD).
        /// Returns a boolean.
        abstract hasLODLevels: bool
        /// Gets the list of {BABYLON.MeshLODLevel} associated with the current mesh
        abstract getLODLevels: unit -> ResizeArray<MeshLODLevel>
        abstract _sortLODLevels: unit -> unit
        /// <summary>Add a mesh as LOD level triggered at the given distance.
        /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD</summary>
        /// <param name="distance">The distance from the center of the object to show this level</param>
        /// <param name="mesh">The mesh to be added as LOD level</param>
        abstract addLODLevel: distance: float * mesh: Mesh -> Mesh
        /// Returns the LOD level mesh at the passed distance or null if not found.
        /// It is related to the method `addLODLevel(distance, mesh)`.
        /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
        /// Returns an object Mesh or `null`.
        abstract getLODLevelAtDistance: distance: float -> Nullable<Mesh>
        /// <summary>Remove a mesh from the LOD array
        /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD</summary>
        /// <param name="mesh">The mesh to be removed.</param>
        abstract removeLODLevel: mesh: Mesh -> Mesh
        /// Returns the registered LOD mesh distant from the parameter `camera` position if any, else returns the current mesh.
        /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_LOD
        abstract getLOD: camera: Camera * ?boundingSphere: BoundingSphere -> AbstractMesh
        /// Returns the mesh internal Geometry object.
        abstract geometry: Nullable<Geometry>
        /// Returns a positive integer : the total number of vertices within the mesh geometry or zero if the mesh has no geometry.
        abstract getTotalVertices: unit -> float
        /// Returns an array of integers or floats, or a Float32Array, depending on the requested `kind` (positions, indices, normals, etc).
        /// If `copywhenShared` is true (default false) and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
        /// You can force the copy with forceCopy === true
        /// Returns null if the mesh has no geometry or no vertex buffer.
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        abstract getVerticesData: kind: string * ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<FloatArray>
        /// Returns the mesh VertexBuffer object from the requested `kind` : positions, indices, normals, etc.
        /// Returns `null` if the mesh has no geometry.
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        abstract getVertexBuffer: kind: string -> Nullable<VertexBuffer>
        /// Returns a boolean depending on the existence of the Vertex Data for the requested `kind`.
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        abstract isVerticesDataPresent: kind: string -> bool
        /// Returns a boolean defining if the vertex data for the requested `kind` is updatable.
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        abstract isVertexBufferUpdatable: kind: string -> bool
        /// Returns a string : the list of existing `kinds` of Vertex Data for this mesh.
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        abstract getVerticesDataKinds: unit -> ResizeArray<string>
        /// Returns a positive integer : the total number of indices in this mesh geometry.
        /// Returns zero if the mesh has no geometry.
        abstract getTotalIndices: unit -> float
        /// Returns an array of integers or a typed array (Int32Array, Uint32Array, Uint16Array) populated with the mesh indices.
        /// If the parameter `copyWhenShared` is true (default false) and and if the mesh geometry is shared among some other meshes, the returned array is a copy of the internal one.
        /// Returns an empty array if the mesh has no geometry.
        abstract getIndices: ?copyWhenShared: bool -> Nullable<IndicesArray>
        abstract isBlocked: bool
        /// <summary>Determine if the current mesh is ready to be rendered</summary>
        /// <param name="completeCheck">defines if a complete check (including materials and lights) has to be done (false by default)</param>
        /// <param name="forceInstanceSupport">will check if the mesh will be ready when used with instances (false by default)</param>
        abstract isReady: ?completeCheck: bool * ?forceInstanceSupport: bool -> bool
        /// Boolean : true if the normals aren't to be recomputed on next mesh `positions` array update.
        /// This property is pertinent only for updatable parametric shapes.
        abstract areNormalsFrozen: bool
        /// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.
        /// It has no effect at all on other shapes.
        /// It prevents the mesh normals from being recomputed on next `positions` array update.
        /// Returns the Mesh.
        abstract freezeNormals: unit -> Mesh
        /// This function affects parametric shapes on vertex position update only : ribbons, tubes, etc.
        /// It has no effect at all on other shapes.
        /// It reactivates the mesh normals computation if it was previously frozen.
        /// Returns the Mesh.
        abstract unfreezeNormals: unit -> Mesh
        /// Overrides instance count. Only applicable when custom instanced InterleavedVertexBuffer are used rather than InstancedMeshs
        abstract overridenInstanceCount: float with get, set
        abstract _preActivate: unit -> Mesh
        abstract _preActivateForIntermediateRendering: renderId: float -> Mesh
        abstract _registerInstanceForRenderId: instance: InstancedMesh * renderId: float -> Mesh
        /// This method recomputes and sets a new BoundingInfo to the mesh unless it is locked.
        /// This means the mesh underlying bounding box and sphere are recomputed.
        /// Returns the Mesh.
        abstract refreshBoundingInfo: unit -> Mesh
        abstract _refreshBoundingInfo: applySkeleton: bool -> Mesh
        abstract _getPositionData: applySkeleton: obj -> unit
        abstract _createGlobalSubMesh: force: bool -> Nullable<SubMesh>
        abstract subdivide: count: float -> unit
        /// Sets the vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, a new Geometry object is set to the mesh and then passed this vertex data.
        /// The `data` are either a numeric array either a Float32Array.
        /// The parameter `updatable` is passed as is to the underlying Geometry object constructor (if initianilly none) or updater.
        /// The parameter `stride` is an optional positive integer, it is usually automatically deducted from the `kind` (3 for positions or normals, 2 for UV, etc).
        /// Note that a new underlying VertexBuffer object is created each call.
        /// If the `kind` is the `PositionKind`, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract setVerticesData: kind: string * data: FloatArray * ?updatable: bool * ?stride: float -> Mesh
        abstract markVerticesDataAsUpdatable: kind: string * ?updatable: bool -> unit
        /// Sets the mesh VertexBuffer.
        /// Returns the Mesh.
        abstract setVerticesBuffer: buffer: VertexBuffer -> Mesh
        /// Updates the existing vertex data of the mesh geometry for the requested `kind`.
        /// If the mesh has no geometry, it is simply returned as it is.
        /// The `data` are either a numeric array either a Float32Array.
        /// No new underlying VertexBuffer object is created.
        /// If the `kind` is the `PositionKind` and if `updateExtends` is true, the mesh BoundingInfo is renewed, so the bounding box and sphere, and the mesh World Matrix is recomputed.
        /// If the parameter `makeItUnique` is true, a new global geometry is created from this positions and is set to the mesh.
        /// 
        /// Possible `kind` values :
        /// - BABYLON.VertexBuffer.PositionKind
        /// - BABYLON.VertexBuffer.UVKind
        /// - BABYLON.VertexBuffer.UV2Kind
        /// - BABYLON.VertexBuffer.UV3Kind
        /// - BABYLON.VertexBuffer.UV4Kind
        /// - BABYLON.VertexBuffer.UV5Kind
        /// - BABYLON.VertexBuffer.UV6Kind
        /// - BABYLON.VertexBuffer.ColorKind
        /// - BABYLON.VertexBuffer.MatricesIndicesKind
        /// - BABYLON.VertexBuffer.MatricesIndicesExtraKind
        /// - BABYLON.VertexBuffer.MatricesWeightsKind
        /// - BABYLON.VertexBuffer.MatricesWeightsExtraKind
        /// 
        /// Returns the Mesh.
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> Mesh
        /// This method updates the vertex positions of an updatable mesh according to the `positionFunction` returned values.
        /// tuto : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#other-shapes-updatemeshpositions
        /// The parameter `positionFunction` is a simple JS function what is passed the mesh `positions` array. It doesn't need to return anything.
        /// The parameter `computeNormals` is a boolean (default true) to enable/disable the mesh normal recomputation after the vertex position update.
        /// Returns the Mesh.
        abstract updateMeshPositions: positionFunction: (FloatArray -> unit) * ?computeNormals: bool -> Mesh
        /// Creates a un-shared specific occurence of the geometry for the mesh.
        /// Returns the Mesh.
        abstract makeGeometryUnique: unit -> Mesh
        /// Sets the mesh indices.
        /// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array).
        /// Type is Uint16Array by default unless the mesh has more than 65536 vertices.
        /// If the mesh has no geometry, a new Geometry object is created and set to the mesh.
        /// This method creates a new index buffer each call.
        /// Returns the Mesh.
        abstract setIndices: indices: IndicesArray * ?totalVertices: Nullable<float> * ?updatable: bool -> Mesh
        /// Update the current index buffer
        /// Expects an array populated with integers or a typed array (Int32Array, Uint32Array, Uint16Array)
        /// Returns the Mesh.
        abstract updateIndices: indices: IndicesArray * ?offset: float -> Mesh
        /// Invert the geometry to move from a right handed system to a left handed one.
        /// Returns the Mesh.
        abstract toLeftHanded: unit -> Mesh
        abstract _bind: subMesh: SubMesh * effect: Effect * fillMode: float -> Mesh
        abstract _draw: subMesh: SubMesh * fillMode: float * ?instancesCount: float * ?alternate: bool -> Mesh
        /// Registers for this mesh a javascript function called just before the rendering process.
        /// This function is passed the current mesh.
        /// Return the Mesh.
        abstract registerBeforeRender: func: (AbstractMesh -> unit) -> Mesh
        /// Disposes a previously registered javascript function called before the rendering.
        /// This function is passed the current mesh.
        /// Returns the Mesh.
        abstract unregisterBeforeRender: func: (AbstractMesh -> unit) -> Mesh
        /// Registers for this mesh a javascript function called just after the rendering is complete.
        /// This function is passed the current mesh.
        /// Returns the Mesh.
        abstract registerAfterRender: func: (AbstractMesh -> unit) -> Mesh
        /// Disposes a previously registered javascript function called after the rendering.
        /// This function is passed the current mesh.
        /// Return the Mesh.
        abstract unregisterAfterRender: func: (AbstractMesh -> unit) -> Mesh
        abstract _getInstancesRenderList: subMeshId: float -> _InstancesBatch
        abstract _renderWithInstances: subMesh: SubMesh * fillMode: float * batch: _InstancesBatch * effect: Effect * engine: Engine -> Mesh
        abstract _processRendering: subMesh: SubMesh * effect: Effect * fillMode: float * batch: _InstancesBatch * hardwareInstancedRendering: bool * onBeforeDraw: (bool -> Matrix -> Material -> unit) * ?effectiveMaterial: Material -> Mesh
        /// Triggers the draw call for the mesh.
        /// Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager.
        /// Returns the Mesh.
        abstract render: subMesh: SubMesh * enableAlphaMode: bool -> Mesh
        abstract _onBeforeDraw: isInstance: obj * world: obj * ?effectiveMaterial: obj -> unit
        /// Returns an array populated with ParticleSystem objects whose the mesh is the emitter.
        abstract getEmittedParticleSystems: unit -> ResizeArray<IParticleSystem>
        /// Returns an array populated with ParticleSystem objects whose the mesh or its children are the emitter.
        abstract getHierarchyEmittedParticleSystems: unit -> ResizeArray<IParticleSystem>
        abstract _checkDelayState: unit -> Mesh
        abstract _queueLoad: scene: obj -> unit
        /// Boolean, true is the mesh in the frustum defined by the Plane objects from the `frustumPlanes` array parameter.
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// Sets the mesh material by the material or multiMaterial `id` property.
        /// The material `id` is a string identifying the material or the multiMaterial.
        /// This method returns the Mesh.
        abstract setMaterialByID: id: string -> Mesh
        /// Returns as a new array populated with the mesh material and/or skeleton, if any.
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        /// Modifies the mesh geometry according to the passed transformation matrix.
        /// This method returns nothing but it really modifies the mesh even if it's originally not set as updatable.
        /// The mesh normals are modified accordingly the same transformation.
        /// tuto : http://doc.babylonjs.com/tutorials/How_Rotations_and_Translations_Work#baking-transform
        /// Note that, under the hood, this method sets a new VertexBuffer each call.
        /// Returns the Mesh.
        abstract bakeTransformIntoVertices: transform: Matrix -> Mesh
        /// Modifies the mesh geometry according to its own current World Matrix.
        /// The mesh World Matrix is then reset.
        /// This method returns nothing but really modifies the mesh even if it's originally not set as updatable.
        /// tuto : tuto : http://doc.babylonjs.com/resources/baking_transformations
        /// Note that, under the hood, this method sets a new VertexBuffer each call.
        /// Returns the Mesh.
        abstract bakeCurrentTransformIntoVertices: unit -> Mesh
        abstract _positions: Nullable<ResizeArray<Vector3>>
        abstract _resetPointsArrayCache: unit -> Mesh
        abstract _generatePointsArray: unit -> bool
        /// Returns a new Mesh object generated from the current mesh properties.
        /// This method must not get confused with createInstance().
        /// The parameter `name` is a string, the name given to the new mesh.
        /// The optional parameter `newParent` can be any Node object (default `null`).
        /// The optional parameter `doNotCloneChildren` (default `false`) allows/denies the recursive cloning of the original mesh children if any.
        /// The parameter `clonePhysicsImpostor` (default `true`)  allows/denies the cloning in the same time of the original mesh `body` used by the physics engine, if any.
        abstract clone: name: string * ?newParent: Node * ?doNotCloneChildren: bool * ?clonePhysicsImpostor: bool -> Mesh
        /// <summary>Releases resources associated with this mesh.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit
        /// Modifies the mesh geometry according to a displacement map.
        /// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
        /// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
        /// This method returns nothing.
        /// The parameter `url` is a string, the URL from the image file is to be downloaded.
        /// The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.
        /// The parameter `onSuccess` is an optional Javascript function to be called just after the mesh is modified. It is passed the modified mesh and must return nothing.
        /// The parameter `uvOffset` is an optional vector2 used to offset UV.
        /// The parameter `uvScale` is an optional vector2 used to scale UV.
        /// 
        /// Returns the Mesh.
        abstract applyDisplacementMap: url: string * minHeight: float * maxHeight: float * ?onSuccess: (Mesh -> unit) * ?uvOffset: Vector2 * ?uvScale: Vector2 -> Mesh
        /// Modifies the mesh geometry according to a displacementMap buffer.
        /// A displacement map is a colored image. Each pixel color value (actually a gradient computed from red, green, blue values) will give the displacement to apply to each mesh vertex.
        /// The mesh must be set as updatable. Its internal geometry is directly modified, no new buffer are allocated.
        /// This method returns nothing.
        /// The parameter `buffer` is a `Uint8Array` buffer containing series of `Uint8` lower than 255, the red, green, blue and alpha values of each successive pixel.
        /// The parameters `heightMapWidth` and `heightMapHeight` are positive integers to set the width and height of the buffer image.
        /// The parameters `minHeight` and `maxHeight` are the lower and upper limits of the displacement.
        /// The parameter `uvOffset` is an optional vector2 used to offset UV.
        /// The parameter `uvScale` is an optional vector2 used to scale UV.
        /// 
        /// Returns the Mesh.
        abstract applyDisplacementMapFromBuffer: buffer: Uint8Array * heightMapWidth: float * heightMapHeight: float * minHeight: float * maxHeight: float * ?uvOffset: Vector2 * ?uvScale: Vector2 -> Mesh
        /// Modify the mesh to get a flat shading rendering.
        /// This means each mesh facet will then have its own normals. Usually new vertices are added in the mesh geometry to get this result.
        /// This method returns the Mesh.
        /// Warning : the mesh is really modified even if not set originally as updatable and, under the hood, a new VertexBuffer is allocated.
        abstract convertToFlatShadedMesh: unit -> Mesh
        /// This method removes all the mesh indices and add new vertices (duplication) in order to unfold facets into buffers.
        /// In other words, more vertices, no more indices and a single bigger VBO.
        /// The mesh is really modified even if not set originally as updatable. Under the hood, a new VertexBuffer is allocated.
        /// Returns the Mesh.
        abstract convertToUnIndexedMesh: unit -> Mesh
        /// Inverses facet orientations and inverts also the normals with `flipNormals` (default `false`) if true.
        /// This method returns the Mesh.
        /// Warning : the mesh is really modified even if not set originally as updatable. A new VertexBuffer is created under the hood each call.
        abstract flipFaces: ?flipNormals: bool -> Mesh
        /// Creates a new InstancedMesh object from the mesh model.
        /// An instance shares the same properties and the same material than its model.
        /// Only these properties of each instance can then be set individually :
        /// - position
        /// - rotation
        /// - rotationQuaternion
        /// - setPivotMatrix
        /// - scaling
        /// tuto : http://doc.babylonjs.com/tutorials/How_to_use_Instances
        /// Warning : this method is not supported for Line mesh and LineSystem
        abstract createInstance: name: string -> InstancedMesh
        /// Synchronises all the mesh instance submeshes to the current mesh submeshes, if any.
        /// After this call, all the mesh instances have the same submeshes than the current mesh.
        /// This method returns the Mesh.
        abstract synchronizeInstances: unit -> Mesh
        /// <summary>Simplify the mesh according to the given array of settings.
        /// Function will return immediately and will simplify async. It returns the Mesh.</summary>
        /// <param name="settings">a collection of simplification settings.</param>
        /// <param name="parallelProcessing">should all levels calculate parallel or one after the other.</param>
        /// <param name="successCallback">optional success callback to be called after the simplification finished processing all settings.</param>
        abstract simplify: settings: Array<ISimplificationSettings> * ?parallelProcessing: bool * ?simplificationType: SimplificationType * ?successCallback: (Mesh -> float -> unit) -> Mesh
        /// <summary>Optimization of the mesh's indices, in case a mesh has duplicated vertices.
        /// The function will only reorder the indices and will not remove unused vertices to avoid problems with submeshes.
        /// This should be used together with the simplification to avoid disappearing triangles.
        /// Returns the Mesh.</summary>
        /// <param name="successCallback">an optional success callback to be called after the optimization finished.</param>
        abstract optimizeIndices: ?successCallback: (Mesh -> unit) -> Mesh
        abstract serialize: serializationObject: obj option -> unit
        abstract _syncGeometryWithMorphTargetManager: unit -> unit
        abstract setPositionsForCPUSkinning: unit -> Float32Array
        abstract setNormalsForCPUSkinning: unit -> Float32Array
        /// <summary>Updates the vertex buffer by applying transformation from the bones.
        /// Returns the Mesh.</summary>
        /// <param name="skeleton">to apply</param>
        abstract applySkeleton: skeleton: Skeleton -> Mesh

    type [<AllowNullLiteral>] MeshStatic =
        /// <param name="name">The value used by scene.getMeshByName() to do a lookup.</param>
        /// <param name="scene">The scene to add this mesh to.</param>
        /// <param name="parent">The parent of this mesh, if it has one</param>
        /// <param name="source">An optional Mesh from which geometry is shared, cloned.</param>
        /// <param name="doNotCloneChildren">When cloning, skip cloning child meshes of source, default False.
        /// When false, achieved by calling a clone(), also passing False.
        /// This will make creation of children, recursive.</param>
        /// <param name="clonePhysicsImpostor">When cloning, include cloning mesh physics impostor, default True.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Nullable<Scene> * ?parent: Nullable<Node> * ?source: Nullable<Mesh> * ?doNotCloneChildren: bool * ?clonePhysicsImpostor: bool -> Mesh
        /// Returns a new Mesh object parsed from the source provided.
        /// The parameter `parsedMesh` is the source.
        /// The parameter `rootUrl` is a string, it's the root URL to prefix the `delayLoadingFile` property with
        abstract Parse: parsedMesh: obj option * scene: Scene * rootUrl: string -> Mesh
        /// Creates a ribbon mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The ribbon is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
        /// 
        /// Please read this full tutorial to understand how to design a ribbon : http://doc.babylonjs.com/tutorials/Ribbon_Tutorial
        /// The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry.
        /// The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array.
        /// The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array.
        /// The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path.
        /// It's the offset to join together the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11.
        /// The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateRibbon: name: string * pathArray: ResizeArray<ResizeArray<Vector3>> * closeArray: bool option * closePath: bool * offset: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// Creates a plane polygonal mesh.  By default, this is a disc.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `radius` sets the radius size (float) of the polygon (default 0.5).
        /// The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc.
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateDisc: name: string * radius: float * tessellation: float * ?scene: Nullable<Scene> * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates a box mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `size` sets the size (float) of each box side (default 1).
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateBox: name: string * size: float * ?scene: Nullable<Scene> * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates a sphere mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `diameter` sets the diameter size (float) of the sphere (default 1).
        /// The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32).
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateSphere: name: string * segments: float * diameter: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates a cylinder or a cone mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
        /// The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
        /// The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
        /// The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
        /// The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateCylinder: name: string * height: float * diameterTop: float * diameterBottom: float * tessellation: float * subdivisions: obj option * ?scene: Scene * ?updatable: obj option * ?sideOrientation: float -> Mesh
        /// Creates a torus mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `diameter` sets the diameter size (float) of the torus (default 1).
        /// The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5).
        /// The parameter `tessellation` sets the number of torus sides (postive integer, default 16).
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateTorus: name: string * diameter: float * thickness: float * tessellation: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates a torus knot mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `radius` sets the global radius size (float) of the torus knot (default 2).
        /// The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32).
        /// The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32).
        /// The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3).
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateTorusKnot: name: string * radius: float * tube: float * radialSegments: float * tubularSegments: float * p: float * q: float * ?scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates a line mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.
        /// Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.
        /// The parameter `points` is an array successive Vector3.
        /// The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// When updating an instance, remember that only point positions can change, not the number of points.
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateLines: name: string * points: ResizeArray<Vector3> * ?scene: Nullable<Scene> * ?updatable: bool * ?instance: Nullable<LinesMesh> -> LinesMesh
        /// Creates a dashed line mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter.
        /// Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function.
        /// The parameter `points` is an array successive Vector3.
        /// The parameter `dashNb` is the intended total number of dashes (positive integer, default 200).
        /// The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3).
        /// The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1).
        /// The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// When updating an instance, remember that only point positions can change, not the number of points.
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateDashedLines: name: string * points: ResizeArray<Vector3> * dashSize: float * gapSize: float * dashNb: float * ?scene: Nullable<Scene> * ?updatable: bool * ?instance: LinesMesh -> LinesMesh
        /// Creates a polygon mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh.
        /// The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors.
        /// You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        /// Remember you can only change the shape positions, not their number when updating a polygon.
        abstract CreatePolygon: name: string * shape: ResizeArray<Vector3> * scene: Scene * ?holes: ResizeArray<ResizeArray<Vector3>> * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates an extruded polygon mesh, with depth in the Y direction.
        /// Please consider using the same method from the MeshBuilder class instead.
        abstract ExtrudePolygon: name: string * shape: ResizeArray<Vector3> * depth: float * scene: Scene * ?holes: ResizeArray<ResizeArray<Vector3>> * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates an extruded shape mesh.
        /// The extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// 
        /// Please read this full tutorial to understand how to design an extruded shape : http://doc.babylonjs.com/tutorials/Parametric_Shapes#extrusion
        /// The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be
        /// extruded along the Z axis.
        /// The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
        /// The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
        /// The parameter `scale` (float, default 1) is the value to scale the shape.
        /// The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
        /// Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract ExtrudeShape: name: string * shape: ResizeArray<Vector3> * path: ResizeArray<Vector3> * scale: float * rotation: float * cap: float * ?scene: Nullable<Scene> * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// Creates an custom extruded shape mesh.
        /// The custom extrusion is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// 
        /// Please read this full tutorial to understand how to design a custom extruded shape : http://doc.babylonjs.com/tutorials/Parametric_Shapes#extrusion
        /// The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be
        /// extruded along the Z axis.
        /// The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
        /// The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path
        /// and the distance of this point from the begining of the path :
        /// ```javascript
        /// var rotationFunction = function(i, distance) {
        ///      // do things
        ///      return rotationValue; }
        /// ```
        /// It must returns a float value that will be the rotation in radians applied to the shape on each path point.
        /// The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path
        /// and the distance of this point from the begining of the path :
        /// ```javascript
        /// var scaleFunction = function(i, distance) {
        ///      // do things
        ///     return scaleValue;}
        /// ```
        /// It must returns a float value that will be the scale value applied to the shape on each path point.
        /// The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`.
        /// The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`.
        /// The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
        /// Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract ExtrudeShapeCustom: name: string * shape: ResizeArray<Vector3> * path: ResizeArray<Vector3> * scaleFunction: Function * rotationFunction: Function * ribbonCloseArray: bool * ribbonClosePath: bool * cap: float * scene: Scene * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// Creates lathe mesh.
        /// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be
        /// rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero.
        /// The parameter `radius` (positive float, default 1) is the radius value of the lathe.
        /// The parameter `tessellation` (positive integer, default 64) is the side number of the lathe.
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateLathe: name: string * shape: ResizeArray<Vector3> * radius: float * tessellation: float * scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates a plane mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `size` sets the size (float) of both sides of the plane at once (default 1).
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreatePlane: name: string * size: float * scene: Scene * ?updatable: bool * ?sideOrientation: float -> Mesh
        /// Creates a ground mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground.
        /// The parameter `subdivisions` (positive integer) sets the number of subdivisions per side.
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateGround: name: string * width: float * height: float * subdivisions: float * ?scene: Scene * ?updatable: bool -> Mesh
        /// Creates a tiled ground mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates.
        /// The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates.
        /// The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the
        /// numbers of subdivisions on the ground width and height. Each subdivision is called a tile.
        /// The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the
        /// numbers of subdivisions on the ground width and height of each tile.
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateTiledGround: name: string * xmin: float * zmin: float * xmax: float * zmax: float * subdivisions: MeshStaticCreateTiledGroundSubdivisions * precision: MeshStaticCreateTiledGroundPrecision * scene: Scene * ?updatable: bool -> Mesh
        /// Creates a ground mesh from a height map.
        /// tuto : http://doc.babylonjs.com/tutorials/14._Height_Map
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `url` sets the URL of the height map image resource.
        /// The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
        /// The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
        /// The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
        /// The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
        /// The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
        /// This function is passed the newly built mesh :
        /// ```javascript
        /// function(mesh) { // do things
        ///      return; }
        /// ```
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateGroundFromHeightMap: name: string * url: string * width: float * height: float * subdivisions: float * minHeight: float * maxHeight: float * scene: Scene * ?updatable: bool * ?onReady: (GroundMesh -> unit) -> GroundMesh
        /// Creates a tube mesh.
        /// The tube is a parametric shape :  http://doc.babylonjs.com/tutorials/Parametric_Shapes.  It has no predefined shape. Its final shape will depend on the input parameters.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube.
        /// The parameter `radius` (positive float, default 1) sets the tube radius size.
        /// The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface.
        /// The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`.
        /// This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path.
        /// It must return a radius value (positive float) :
        /// ```javascript
        /// var radiusFunction = function(i, distance) {
        ///      // do things
        ///      return radius; }
        /// ```
        /// The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateTube: name: string * path: ResizeArray<Vector3> * radius: float * tessellation: float * radiusFunction: MeshStaticCreateTubeRadiusFunction * cap: float * scene: Scene * ?updatable: bool * ?sideOrientation: float * ?instance: Mesh -> Mesh
        /// Creates a polyhedron mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial
        ///   to choose the wanted type.
        /// The parameter `size` (positive float, default 1) sets the polygon size.
        /// You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value).
        /// You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`.
        /// A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
        /// You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`).
        /// To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
        /// The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored.
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreatePolyhedron: name: string * options: MeshStaticCreatePolyhedronOptions * scene: Scene -> Mesh
        /// Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// The parameter `radius` sets the radius size (float) of the icosphere (default 1).
        /// You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`).
        /// The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size.
        /// The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface.
        /// You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.
        abstract CreateIcoSphere: name: string * options: MeshStaticCreateIcoSphereOptions * scene: Scene -> Mesh
        /// Creates a decal mesh.
        /// Please consider using the same method from the MeshBuilder class instead.
        /// A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal.
        /// The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates.
        /// The parameter `normal` (Vector3, default Vector3.Up) sets the normal of the mesh where the decal is applied onto in World coordinates.
        /// The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling.
        /// The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal.
        abstract CreateDecal: name: string * sourceMesh: AbstractMesh * position: Vector3 * normal: Vector3 * size: Vector3 * angle: float -> Mesh
        /// Returns an object `{min:` Vector3`, max:` Vector3`}`
        /// This min and max Vector3 are the minimum and maximum vectors of each mesh bounding box from the passed array, in the World system
        abstract MinMax: meshes: ResizeArray<AbstractMesh> -> obj
        /// Returns a Vector3, the center of the `{min:` Vector3`, max:` Vector3`}` or the center of MinMax vector3 computed from a mesh array.
        abstract Center: meshesOrMinMaxVector: U2<obj, ResizeArray<AbstractMesh>> -> Vector3
        /// <summary>Merge the array of meshes into a single mesh for performance reasons.</summary>
        /// <param name="meshes">- The vertices source.  They should all be of the same material.  Entries can empty</param>
        /// <param name="disposeSource">- When true (default), dispose of the vertices from the source meshes</param>
        /// <param name="allow32BitsIndices">- When the sum of the vertices > 64k, this must be set to true.</param>
        /// <param name="meshSubclass">- When set, vertices inserted into this Mesh.  Meshes can then be merged into a Mesh sub-class.</param>
        /// <param name="subdivideWithSubMeshes">- When true (false default), subdivide mesh to his subMesh array with meshes source.</param>
        abstract MergeMeshes: meshes: Array<Mesh> * ?disposeSource: bool * ?allow32BitsIndices: bool * ?meshSubclass: Mesh * ?subdivideWithSubMeshes: bool -> Nullable<Mesh>

    type [<AllowNullLiteral>] MeshStaticCreateTiledGroundSubdivisions =
        abstract w: float with get, set
        abstract h: float with get, set

    type [<AllowNullLiteral>] MeshStaticCreateTiledGroundPrecision =
        abstract w: float with get, set
        abstract h: float with get, set

    type [<AllowNullLiteral>] MeshStaticCreateTubeRadiusFunction =
        [<Emit "$0($1...)">] abstract Invoke: i: float * distance: float -> float

    type [<AllowNullLiteral>] MeshStaticCreatePolyhedronOptions =
        abstract ``type``: float option with get, set
        abstract size: float option with get, set
        abstract sizeX: float option with get, set
        abstract sizeY: float option with get, set
        abstract sizeZ: float option with get, set
        abstract custom: obj option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set

    type [<AllowNullLiteral>] MeshStaticCreateIcoSphereOptions =
        abstract radius: float option with get, set
        abstract flat: bool option with get, set
        abstract subdivisions: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract updatable: bool option with get, set

    /// Define an interface for all classes that will get and set the data on vertices
    type [<AllowNullLiteral>] IGetSetVerticesData =
        abstract isVerticesDataPresent: kind: string -> bool
        abstract getVerticesData: kind: string * ?copyWhenShared: bool * ?forceCopy: bool -> Nullable<FloatArray>
        abstract getIndices: ?copyWhenShared: bool -> Nullable<IndicesArray>
        abstract setVerticesData: kind: string * data: FloatArray * updatable: bool -> unit
        abstract updateVerticesData: kind: string * data: FloatArray * ?updateExtends: bool * ?makeItUnique: bool -> unit
        abstract setIndices: indices: IndicesArray * totalVertices: Nullable<float> * ?updatable: bool -> unit

    /// This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
    type [<AllowNullLiteral>] VertexData =
        /// An array of the x, y, z position of each vertex  [...., x, y, z, .....]
        abstract positions: Nullable<FloatArray> with get, set
        /// An array of the x, y, z normal vector of each vertex  [...., x, y, z, .....]
        abstract normals: Nullable<FloatArray> with get, set
        /// An array of the x, y, z tangent vector of each vertex  [...., x, y, z, .....]
        abstract tangents: Nullable<FloatArray> with get, set
        /// An array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs: Nullable<FloatArray> with get, set
        /// A second array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs2: Nullable<FloatArray> with get, set
        /// A third array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs3: Nullable<FloatArray> with get, set
        /// A fourth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs4: Nullable<FloatArray> with get, set
        /// A fifth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs5: Nullable<FloatArray> with get, set
        /// A sixth array of u,v which maps a texture image onto each vertex  [...., u, v, .....]
        abstract uvs6: Nullable<FloatArray> with get, set
        /// An array of the r, g, b, a, color of each vertex  [...., r, g, b, a, .....]
        abstract colors: Nullable<FloatArray> with get, set
        /// An array containing the list of indices to the array of matrices produced by bones, each vertex have up to 4 indices (8 if the matricesIndicesExtra is set).
        abstract matricesIndices: Nullable<FloatArray> with get, set
        /// An array containing the list of weights defining the weight of each indexed matrix in the final computation
        abstract matricesWeights: Nullable<FloatArray> with get, set
        /// An array extending the number of possible indices
        abstract matricesIndicesExtra: Nullable<FloatArray> with get, set
        /// An array extending the number of possible weights when the number of indices is extended
        abstract matricesWeightsExtra: Nullable<FloatArray> with get, set
        /// An array of i, j, k the three vertex indices required for each triangular facet  [...., i, j, k .....]
        abstract indices: Nullable<IndicesArray> with get, set
        /// <summary>Uses the passed data array to set the set the values for the specified kind of data</summary>
        /// <param name="data">a linear array of floating numbers</param>
        /// <param name="kind">the type of data that is being set, eg positions, colors etc</param>
        abstract set: data: FloatArray * kind: string -> unit
        /// <summary>Associates the vertexData to the passed Mesh.
        /// Sets it as updatable or not (default `false`)</summary>
        /// <param name="mesh">the mesh the vertexData is applied to</param>
        /// <param name="updatable">when used and having the value true allows new data to update the vertexData</param>
        abstract applyToMesh: mesh: Mesh * ?updatable: bool -> VertexData
        /// <summary>Associates the vertexData to the passed Geometry.
        /// Sets it as updatable or not (default `false`)</summary>
        /// <param name="geometry">the geometry the vertexData is applied to</param>
        /// <param name="updatable">when used and having the value true allows new data to update the vertexData</param>
        abstract applyToGeometry: geometry: Geometry * ?updatable: bool -> VertexData
        /// <summary>Updates the associated mesh</summary>
        /// <param name="mesh">the mesh to be updated</param>
        /// <param name="updateExtends">when true the mesh BoundingInfo will be renewed when and if position kind is updated, optional with default false</param>
        /// <param name="makeItUnique">when true, and when and if position kind is updated, a new global geometry will be  created from these positions and set to the mesh, optional with default false</param>
        abstract updateMesh: mesh: Mesh * ?updateExtends: bool * ?makeItUnique: bool -> VertexData
        /// <summary>Updates the associated geometry</summary>
        /// <param name="geometry">the geometry to be updated</param>
        /// <param name="updateExtends">when true BoundingInfo will be renewed when and if position kind is updated, optional with default false</param>
        /// <param name="makeItUnique">when true, and when and if position kind is updated, a new global geometry will be created from these positions and set to the mesh, optional with default false</param>
        abstract updateGeometry: geometry: Geometry * ?updateExtends: bool * ?makeItUnique: bool -> VertexData
        abstract _applyTo: meshOrGeometry: obj * ?updatable: obj -> unit
        abstract _update: meshOrGeometry: obj * ?updateExtends: obj * ?makeItUnique: obj -> unit
        /// <summary>Transforms each position and each normal of the vertexData according to the passed Matrix</summary>
        /// <param name="matrix">the transforming matrix</param>
        abstract transform: matrix: Matrix -> VertexData
        /// <summary>Merges the passed VertexData into the current one</summary>
        /// <param name="other">the VertexData to be merged into the current one</param>
        abstract merge: other: VertexData -> VertexData
        abstract _mergeElement: source: obj * other: obj -> unit
        abstract _validate: unit -> unit
        /// Serializes the VertexData
        abstract serialize: unit -> obj option

    /// This class contains the various kinds of data on every vertex of a mesh used in determining its shape and appearance
    type [<AllowNullLiteral>] VertexDataStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> VertexData
        /// <summary>Extracts the vertexData from a mesh</summary>
        /// <param name="mesh">the mesh from which to extract the VertexData</param>
        /// <param name="copyWhenShared">defines if the VertexData must be cloned when shared between multiple meshes, optional, default false</param>
        /// <param name="forceCopy">indicating that the VertexData must be cloned, optional, default false</param>
        abstract ExtractFromMesh: mesh: Mesh * ?copyWhenShared: bool * ?forceCopy: bool -> VertexData
        /// <summary>Extracts the vertexData from the geometry</summary>
        /// <param name="geometry">the geometry from which to extract the VertexData</param>
        /// <param name="copyWhenShared">defines if the VertexData must be cloned when the geometrty is shared between multiple meshes, optional, default false</param>
        /// <param name="forceCopy">indicating that the VertexData must be cloned, optional, default false</param>
        abstract ExtractFromGeometry: geometry: Geometry * ?copyWhenShared: bool * ?forceCopy: bool -> VertexData
        abstract _ExtractFrom: meshOrGeometry: obj * ?copyWhenShared: obj * ?forceCopy: obj -> unit
        /// <summary>Creates the VertexData for a Ribbon</summary>
        /// <param name="options">an object used to set the following optional parameters for the ribbon, required but can be empty
        /// * pathArray array of paths, each of which an array of successive Vector3
        /// * closeArray creates a seam between the first and the last paths of the pathArray, optional, default false
        /// * closePath creates a seam between the first and the last points of each path of the path array, optional, default false
        /// * offset a positive integer, only used when pathArray contains a single path (offset = 10 means the point 1 is joined to the point 11), default rounded half size of the pathArray length
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)
        /// * invertUV swaps in the U and V coordinates when applying a texture, optional, default false
        /// * uvs a linear array, of length 2 * number of vertices, of custom UV values, optional
        /// * colors a linear array, of length 4 * number of vertices, of custom color values, optional</param>
        abstract CreateRibbon: options: VertexDataStaticCreateRibbonOptions -> VertexData
        /// <summary>Creates the VertexData for a box</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * size sets the width, height and depth of the box to the value of size, optional default 1
        /// * width sets the width (x direction) of the box, overwrites the width set by size, optional, default size
        /// * height sets the height (y direction) of the box, overwrites the height set by size, optional, default size
        /// * depth sets the depth (z direction) of the box, overwrites the depth set by size, optional, default size
        /// * faceUV an array of 6 Vector4 elements used to set different images to each box side
        /// * faceColors an array of 6 Color3 elements used to set different colors to each box side
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateBox: options: VertexDataStaticCreateBoxOptions -> VertexData
        /// <summary>Creates the VertexData for an ellipsoid, defaults to a sphere</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * segments sets the number of horizontal strips optional, default 32
        /// * diameter sets the axes dimensions, diameterX, diameterY and diameterZ to the value of diameter, optional default 1
        /// * diameterX sets the diameterX (x direction) of the ellipsoid, overwrites the diameterX set by diameter, optional, default diameter
        /// * diameterY sets the diameterY (y direction) of the ellipsoid, overwrites the diameterY set by diameter, optional, default diameter
        /// * diameterZ sets the diameterZ (z direction) of the ellipsoid, overwrites the diameterZ set by diameter, optional, default diameter
        /// * arc a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the circumference (latitude) given by the arc value, optional, default 1
        /// * slice a number from 0 to 1, to create an unclosed ellipsoid based on the fraction of the height (latitude) given by the arc value, optional, default 1
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateSphere: options: VertexDataStaticCreateSphereOptions -> VertexData
        /// <summary>Creates the VertexData for a cylinder, cone or prism</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * height sets the height (y direction) of the cylinder, optional, default 2
        /// * diameterTop sets the diameter of the top of the cone, overwrites diameter,  optional, default diameter
        /// * diameterBottom sets the diameter of the bottom of the cone, overwrites diameter,  optional, default diameter
        /// * diameter sets the diameter of the top and bottom of the cone, optional default 1
        /// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
        /// * subdivisions` the number of rings along the cylinder height, optional, default 1
        /// * arc a number from 0 to 1, to create an unclosed cylinder based on the fraction of the circumference given by the arc value, optional, default 1
        /// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
        /// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
        /// * hasRings when true makes each subdivision independantly treated as a face for faceUV and faceColors, optional, default false
        /// * enclose when true closes an open cylinder by adding extra flat faces between the height axis and vertical edges, think cut cake
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateCylinder: options: VertexDataStaticCreateCylinderOptions -> VertexData
        /// <summary>Creates the VertexData for a torus</summary>
        /// <param name="options">an object used to set the following optional parameters for the box, required but can be empty
        /// * diameter the diameter of the torus, optional default 1
        /// * thickness the diameter of the tube forming the torus, optional default 0.5
        /// * tessellation the number of prism sides, 3 for a triangular prism, optional, default 24
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateTorus: options: VertexDataStaticCreateTorusOptions -> VertexData
        /// <summary>Creates the VertexData of the LineSystem</summary>
        /// <param name="options">an object used to set the following optional parameters for the LineSystem, required but can be empty
        /// - lines an array of lines, each line being an array of successive Vector3
        /// - colors an array of line colors, each of the line colors being an array of successive Color4, one per line point</param>
        abstract CreateLineSystem: options: VertexDataStaticCreateLineSystemOptions -> VertexData
        /// <summary>Create the VertexData for a DashedLines</summary>
        /// <param name="options">an object used to set the following optional parameters for the DashedLines, required but can be empty
        /// - points an array successive Vector3
        /// - dashSize the size of the dashes relative to the dash number, optional, default 3
        /// - gapSize the size of the gap between two successive dashes relative to the dash number, optional, default 1
        /// - dashNb the intended total number of dashes, optional, default 200</param>
        abstract CreateDashedLines: options: VertexDataStaticCreateDashedLinesOptions -> VertexData
        /// <summary>Creates the VertexData for a Ground</summary>
        /// <param name="options">an object used to set the following optional parameters for the Ground, required but can be empty
        /// - width the width (x direction) of the ground, optional, default 1
        /// - height the height (z direction) of the ground, optional, default 1
        /// - subdivisions the number of subdivisions per side, optional, default 1</param>
        abstract CreateGround: options: VertexDataStaticCreateGroundOptions -> VertexData
        /// <summary>Creates the VertexData for a TiledGround by subdividing the ground into tiles</summary>
        /// <param name="options">an object used to set the following optional parameters for the Ground, required but can be empty
        /// * xmin the ground minimum X coordinate, optional, default -1
        /// * zmin the ground minimum Z coordinate, optional, default -1
        /// * xmax the ground maximum X coordinate, optional, default 1
        /// * zmax the ground maximum Z coordinate, optional, default 1
        /// * subdivisions a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the ground width and height creating 'tiles', default {w: 6, h: 6}
        /// * precision a javascript object {w: positive integer, h: positive integer}, `w` and `h` are the numbers of subdivisions on the tile width and height, default {w: 2, h: 2}</param>
        abstract CreateTiledGround: options: VertexDataStaticCreateTiledGroundOptions -> VertexData
        /// <summary>Creates the VertexData of the Ground designed from a heightmap</summary>
        /// <param name="options">an object used to set the following parameters for the Ground, required and provided by MeshBuilder.CreateGroundFromHeightMap
        /// * width the width (x direction) of the ground
        /// * height the height (z direction) of the ground
        /// * subdivisions the number of subdivisions per side
        /// * minHeight the minimum altitude on the ground, optional, default 0
        /// * maxHeight the maximum altitude on the ground, optional default 1
        /// * colorFilter the filter to apply to the image pixel colors to compute the height, optional Color3, default (0.3, 0.59, 0.11)
        /// * buffer the array holding the image color data
        /// * bufferWidth the width of image
        /// * bufferHeight the height of image</param>
        abstract CreateGroundFromHeightMap: options: VertexDataStaticCreateGroundFromHeightMapOptions -> VertexData
        /// <summary>Creates the VertexData for a Plane</summary>
        /// <param name="options">an object used to set the following optional parameters for the plane, required but can be empty
        /// * size sets the width and height of the plane to the value of size, optional default 1
        /// * width sets the width (x direction) of the plane, overwrites the width set by size, optional, default size
        /// * height sets the height (y direction) of the plane, overwrites the height set by size, optional, default size
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreatePlane: options: VertexDataStaticCreatePlaneOptions -> VertexData
        /// <summary>Creates the VertexData of the Disc or regular Polygon</summary>
        /// <param name="options">an object used to set the following optional parameters for the disc, required but can be empty
        /// * radius the radius of the disc, optional default 0.5
        /// * tessellation the number of polygon sides, optional, default 64
        /// * arc a number from 0 to 1, to create an unclosed polygon based on the fraction of the circumference given by the arc value, optional, default 1
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateDisc: options: VertexDataStaticCreateDiscOptions -> VertexData
        /// <summary>Creates the VertexData for an irregular Polygon in the XoZ plane using a mesh built by polygonTriangulation.build()
        /// All parameters are provided by MeshBuilder.CreatePolygon as needed</summary>
        /// <param name="polygon">a mesh built from polygonTriangulation.build()</param>
        /// <param name="sideOrientation">takes the values BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE</param>
        /// <param name="fUV">an array of Vector4 elements used to set different images to the top, rings and bottom respectively</param>
        /// <param name="fColors">an array of Color3 elements used to set different colors to the top, rings and bottom respectively</param>
        /// <param name="frontUVs">only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)</param>
        /// <param name="backUVs">only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreatePolygon: polygon: Mesh * sideOrientation: float * ?fUV: ResizeArray<Vector4> * ?fColors: ResizeArray<Color4> * ?frontUVs: Vector4 * ?backUVs: Vector4 -> VertexData
        /// <summary>Creates the VertexData of the IcoSphere</summary>
        /// <param name="options">an object used to set the following optional parameters for the IcoSphere, required but can be empty
        /// * radius the radius of the IcoSphere, optional default 1
        /// * radiusX allows stretching in the x direction, optional, default radius
        /// * radiusY allows stretching in the y direction, optional, default radius
        /// * radiusZ allows stretching in the z direction, optional, default radius
        /// * flat when true creates a flat shaded mesh, optional, default true
        /// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateIcoSphere: options: VertexDataStaticCreateIcoSphereOptions -> VertexData
        /// <summary>Creates the VertexData for a Polyhedron</summary>
        /// <param name="options">an object used to set the following optional parameters for the polyhedron, required but can be empty
        /// * type provided types are:
        /// * 0 : Tetrahedron, 1 : Octahedron, 2 : Dodecahedron, 3 : Icosahedron, 4 : Rhombicuboctahedron, 5 : Triangular Prism, 6 : Pentagonal Prism, 7 : Hexagonal Prism, 8 : Square Pyramid (J1)
        /// * 9 : Pentagonal Pyramid (J2), 10 : Triangular Dipyramid (J12), 11 : Pentagonal Dipyramid (J13), 12 : Elongated Square Dipyramid (J15), 13 : Elongated Pentagonal Dipyramid (J16), 14 : Elongated Pentagonal Cupola (J20)
        /// * size the size of the IcoSphere, optional default 1
        /// * sizeX allows stretching in the x direction, optional, default size
        /// * sizeY allows stretching in the y direction, optional, default size
        /// * sizeZ allows stretching in the z direction, optional, default size
        /// * custom a number that overwrites the type to create from an extended set of polyhedron from https://www.babylonjs-playground.com/#21QRSK#15 with minimised editor
        /// * faceUV an array of Vector4 elements used to set different images to the top, rings and bottom respectively
        /// * faceColors an array of Color3 elements used to set different colors to the top, rings and bottom respectively
        /// * flat when true creates a flat shaded mesh, optional, default true
        /// * subdivisions increasing the subdivisions increases the number of faces, optional, default 4
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreatePolyhedron: options: VertexDataStaticCreatePolyhedronOptions -> VertexData
        /// <summary>Creates the VertexData for a TorusKnot</summary>
        /// <param name="options">an object used to set the following optional parameters for the TorusKnot, required but can be empty
        /// * radius the radius of the torus knot, optional, default 2
        /// * tube the thickness of the tube, optional, default 0.5
        /// * radialSegments the number of sides on each tube segments, optional, default 32
        /// * tubularSegments the number of tubes to decompose the knot into, optional, default 32
        /// * p the number of windings around the z axis, optional,  default 2
        /// * q the number of windings around the x axis, optional,  default 3
        /// * sideOrientation optional and takes the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * frontUvs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the front side, optional, default vector4 (0, 0, 1, 1)
        /// * backUVs only usable when you create a double-sided mesh, used to choose what parts of the texture image to crop and apply on the back side, optional, default vector4 (0, 0, 1, 1)</param>
        abstract CreateTorusKnot: options: VertexDataStaticCreateTorusKnotOptions -> VertexData
        /// <summary>Compute normals for given positions and indices</summary>
        /// <param name="positions">an array of vertex positions, [...., x, y, z, ......]</param>
        /// <param name="indices">an array of indices in groups of three for each triangular facet, [...., i, j, k, ......]</param>
        /// <param name="normals">an array of vertex normals, [...., x, y, z, ......]</param>
        /// <param name="options">an object used to set the following optional parameters for the TorusKnot, optional
        /// * facetNormals : optional array of facet normals (vector3)
        /// * facetPositions : optional array of facet positions (vector3)
        /// * facetPartitioning : optional partitioning array. facetPositions is required for facetPartitioning computation
        /// * ratio : optional partitioning ratio / bounding box, required for facetPartitioning computation
        /// * bInfo : optional bounding info, required for facetPartitioning computation
        /// * bbSize : optional bounding box size data, required for facetPartitioning computation
        /// * subDiv : optional partitioning data about subdivsions on  each axis (int), required for facetPartitioning computation
        /// * useRightHandedSystem: optional boolean to for right handed system computation
        /// * depthSort : optional boolean to enable the facet depth sort computation
        /// * distanceTo : optional Vector3 to compute the facet depth from this location
        /// * depthSortedFacets : optional array of depthSortedFacets to store the facet distances from the reference location</param>
        abstract ComputeNormals: positions: obj option * indices: obj option * normals: obj option * ?options: VertexDataStaticComputeNormalsOptions -> unit
        abstract _ComputeSides: sideOrientation: obj * positions: obj * indices: obj * normals: obj * uvs: obj * ?frontUVs: obj * ?backUVs: obj -> unit
        /// <summary>Applies VertexData created from the imported parameters to the geometry</summary>
        /// <param name="parsedVertexData">the parsed data from an imported file</param>
        /// <param name="geometry">the geometry to apply the VertexData to</param>
        abstract ImportVertexData: parsedVertexData: obj option * geometry: Geometry -> unit

    type [<AllowNullLiteral>] VertexDataStaticCreateRibbonOptions =
        abstract pathArray: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract closeArray: bool option with get, set
        abstract closePath: bool option with get, set
        abstract offset: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract invertUV: bool option with get, set
        abstract uvs: ResizeArray<Vector2> option with get, set
        abstract colors: ResizeArray<Color4> option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateBoxOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateSphereOptions =
        abstract segments: float option with get, set
        abstract diameter: float option with get, set
        abstract diameterX: float option with get, set
        abstract diameterY: float option with get, set
        abstract diameterZ: float option with get, set
        abstract arc: float option with get, set
        abstract slice: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateCylinderOptions =
        abstract height: float option with get, set
        abstract diameterTop: float option with get, set
        abstract diameterBottom: float option with get, set
        abstract diameter: float option with get, set
        abstract tessellation: float option with get, set
        abstract subdivisions: float option with get, set
        abstract arc: float option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract hasRings: bool option with get, set
        abstract enclose: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateTorusOptions =
        abstract diameter: float option with get, set
        abstract thickness: float option with get, set
        abstract tessellation: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateLineSystemOptions =
        abstract lines: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract colors: Nullable<ResizeArray<ResizeArray<Color4>>> option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateDashedLinesOptions =
        abstract points: ResizeArray<Vector3> with get, set
        abstract dashSize: float option with get, set
        abstract gapSize: float option with get, set
        abstract dashNb: float option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateGroundOptions =
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract subdivisions: float option with get, set
        abstract subdivisionsX: float option with get, set
        abstract subdivisionsY: float option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateTiledGroundOptions =
        abstract xmin: float with get, set
        abstract zmin: float with get, set
        abstract xmax: float with get, set
        abstract zmax: float with get, set
        abstract subdivisions: obj option with get, set
        abstract precision: obj option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateGroundFromHeightMapOptions =
        abstract width: float with get, set
        abstract height: float with get, set
        abstract subdivisions: float with get, set
        abstract minHeight: float with get, set
        abstract maxHeight: float with get, set
        abstract colorFilter: Color3 with get, set
        abstract buffer: Uint8Array with get, set
        abstract bufferWidth: float with get, set
        abstract bufferHeight: float with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreatePlaneOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateDiscOptions =
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract arc: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateIcoSphereOptions =
        abstract radius: float option with get, set
        abstract radiusX: float option with get, set
        abstract radiusY: float option with get, set
        abstract radiusZ: float option with get, set
        abstract flat: bool option with get, set
        abstract subdivisions: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreatePolyhedronOptions =
        abstract ``type``: float option with get, set
        abstract size: float option with get, set
        abstract sizeX: float option with get, set
        abstract sizeY: float option with get, set
        abstract sizeZ: float option with get, set
        abstract custom: obj option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract flat: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticCreateTorusKnotOptions =
        abstract radius: float option with get, set
        abstract tube: float option with get, set
        abstract radialSegments: float option with get, set
        abstract tubularSegments: float option with get, set
        abstract p: float option with get, set
        abstract q: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] VertexDataStaticComputeNormalsOptions =
        abstract facetNormals: obj option with get, set
        abstract facetPositions: obj option with get, set
        abstract facetPartitioning: obj option with get, set
        abstract ratio: float option with get, set
        abstract bInfo: obj option with get, set
        abstract bbSize: Vector3 option with get, set
        abstract subDiv: obj option with get, set
        abstract useRightHandedSystem: bool option with get, set
        abstract depthSort: bool option with get, set
        abstract distanceTo: Vector3 option with get, set
        abstract depthSortedFacets: obj option with get, set

    /// Class containing static functions to help procedurally build meshes
    type [<AllowNullLiteral>] MeshBuilder =
        interface end

    /// Class containing static functions to help procedurally build meshes
    type [<AllowNullLiteral>] MeshBuilderStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MeshBuilder
        abstract updateSideOrientation: ?orientation: obj -> unit
        /// <summary>Creates a box mesh
        /// * The parameter `size` sets the size (float) of each box side (default 1)
        /// * You can set some different box dimensions by using the parameters `width`, `height` and `depth` (all by default have the same value than `size`)
        /// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of 6 Color3 elements) and `faceUV` (an array of 6 Vector4 elements)
        /// * Please read this tutorial : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateBox: name: string * options: MeshBuilderStaticCreateBoxOptions * ?scene: Nullable<Scene> -> Mesh
        /// <summary>Creates a sphere mesh
        /// * The parameter `diameter` sets the diameter size (float) of the sphere (default 1)
        /// * You can set some different sphere dimensions, for instance to build an ellipsoid, by using the parameters `diameterX`, `diameterY` and `diameterZ` (all by default have the same value than `diameter`)
        /// * The parameter `segments` sets the sphere number of horizontal stripes (positive integer, default 32)
        /// * You can create an unclosed sphere with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference (latitude) : 2 x PI x ratio
        /// * You can create an unclosed sphere on its height with the parameter `slice` (positive float, default1), valued between 0 and 1, what is the height ratio (longitude)
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateSphere: name: string * options: MeshBuilderStaticCreateSphereOptions * scene: obj option -> Mesh
        /// <summary>Creates a plane polygonal mesh.  By default, this is a disc
        /// * The parameter `radius` sets the radius size (float) of the polygon (default 0.5)
        /// * The parameter `tessellation` sets the number of polygon sides (positive integer, default 64). So a tessellation valued to 3 will build a triangle, to 4 a square, etc
        /// * You can create an unclosed polygon with the parameter `arc` (positive float, default 1), valued between 0 and 1, what is the ratio of the circumference : 2 x PI x ratio
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateDisc: name: string * options: MeshBuilderStaticCreateDiscOptions * ?scene: Nullable<Scene> -> Mesh
        /// <summary>Creates a sphere based upon an icosahedron with 20 triangular faces which can be subdivided
        /// * The parameter `radius` sets the radius size (float) of the icosphere (default 1)
        /// * You can set some different icosphere dimensions, for instance to build an ellipsoid, by using the parameters `radiusX`, `radiusY` and `radiusZ` (all by default have the same value than `radius`)
        /// * The parameter `subdivisions` sets the number of subdivisions (postive integer, default 4). The more subdivisions, the more faces on the icosphere whatever its size
        /// * The parameter `flat` (boolean, default true) gives each side its own normals. Set it to false to get a smooth continuous light reflection on the surface
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateIcoSphere: name: string * options: MeshBuilderStaticCreateIcoSphereOptions * scene: Scene -> Mesh
        /// <summary>Creates a ribbon mesh. The ribbon is a parametric shape.  It has no predefined shape. Its final shape will depend on the input parameters
        /// * The parameter `pathArray` is a required array of paths, what are each an array of successive Vector3. The pathArray parameter depicts the ribbon geometry
        /// * The parameter `closeArray` (boolean, default false) creates a seam between the first and the last paths of the path array
        /// * The parameter `closePath` (boolean, default false) creates a seam between the first and the last points of each path of the path array
        /// * The parameter `offset` (positive integer, default : rounded half size of the pathArray length), is taken in account only if the `pathArray` is containing a single path
        /// * It's the offset to join the points from the same path. Ex : offset = 10 means the point 1 is joined to the point 11
        /// * The optional parameter `instance` is an instance of an existing Ribbon object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#ribbon
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The parameter `uvs` is an optional flat array of `Vector2` to update/set each ribbon vertex with its own custom UV values instead of the computed ones
        /// * The parameters `colors` is an optional flat array of `Color4` to set/update each ribbon vertex with its own custom color values
        /// * Note that if you use the parameters `uvs` or `colors`, the passed arrays must be populated with the right number of elements, it is to say the number of ribbon vertices. Remember that if you set `closePath` to `true`, there's one extra vertex per path in the geometry
        /// * Moreover, you can use the parameter `color` with `instance` (to update the ribbon), only if you previously used it at creation time
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateRibbon: name: string * options: MeshBuilderStaticCreateRibbonOptions * ?scene: Nullable<Scene> -> Mesh
        /// <summary>Creates a cylinder or a cone mesh
        /// * The parameter `height` sets the height size (float) of the cylinder/cone (float, default 2).
        /// * The parameter `diameter` sets the diameter of the top and bottom cap at once (float, default 1).
        /// * The parameters `diameterTop` and `diameterBottom` overwrite the parameter `diameter` and set respectively the top cap and bottom cap diameter (floats, default 1). The parameter "diameterBottom" can't be zero.
        /// * The parameter `tessellation` sets the number of cylinder sides (positive integer, default 24). Set it to 3 to get a prism for instance.
        /// * The parameter `subdivisions` sets the number of rings along the cylinder height (positive integer, default 1).
        /// * The parameter `hasRings` (boolean, default false) makes the subdivisions independent from each other, so they become different faces.
        /// * The parameter `enclose`  (boolean, default false) adds two extra faces per subdivision to a sliced cylinder to close it around its height axis.
        /// * The parameter `arc` (float, default 1) is the ratio (max 1) to apply to the circumference to slice the cylinder.
        /// * You can set different colors and different images to each box side by using the parameters `faceColors` (an array of n Color3 elements) and `faceUV` (an array of n Vector4 elements).
        /// * The value of n is the number of cylinder faces. If the cylinder has only 1 subdivisions, n equals : top face + cylinder surface + bottom face = 3
        /// * Now, if the cylinder has 5 independent subdivisions (hasRings = true), n equals : top face + 5 stripe surfaces + bottom face = 2 + 5 = 7
        /// * Finally, if the cylinder has 5 independent subdivisions and is enclose, n equals : top face + 5 x (stripe surface + 2 closing faces) + bottom face = 2 + 5 * 3 = 17
        /// * Each array (color or UVs) is always ordered the same way : the first element is the bottom cap, the last element is the top cap. The other elements are each a ring surface.
        /// * If `enclose` is false, a ring surface is one element.
        /// * If `enclose` is true, a ring surface is 3 successive elements in the array : the tubular surface, then the two closing faces.
        /// * Example how to set colors and textures on a sliced cylinder : http://www.html5gamedevs.com/topic/17945-creating-a-closed-slice-of-a-cylinder/#comment-106379
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateCylinder: name: string * options: MeshBuilderStaticCreateCylinderOptions * scene: obj option -> Mesh
        /// <summary>Creates a torus mesh
        /// * The parameter `diameter` sets the diameter size (float) of the torus (default 1)
        /// * The parameter `thickness` sets the diameter size of the tube of the torus (float, default 0.5)
        /// * The parameter `tessellation` sets the number of torus sides (postive integer, default 16)
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTorus: name: string * options: MeshBuilderStaticCreateTorusOptions * scene: obj option -> Mesh
        /// <summary>Creates a torus knot mesh
        /// * The parameter `radius` sets the global radius size (float) of the torus knot (default 2)
        /// * The parameter `radialSegments` sets the number of sides on each tube segments (positive integer, default 32)
        /// * The parameter `tubularSegments` sets the number of tubes to decompose the knot into (positive integer, default 32)
        /// * The parameters `p` and `q` are the number of windings on each axis (positive integers, default 2 and 3)
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTorusKnot: name: string * options: MeshBuilderStaticCreateTorusKnotOptions * scene: obj option -> Mesh
        /// <summary>Creates a line system mesh. A line system is a pool of many lines gathered in a single mesh
        /// * A line system mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of lines as an input parameter
        /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineSystem to this static function
        /// * The parameter `lines` is an array of lines, each line being an array of successive Vector3
        /// * The optional parameter `instance` is an instance of an existing LineSystem object to be updated with the passed `lines` parameter
        /// * The optional parameter `colors` is an array of line colors, each line colors being an array of successive Color4, one per line point
        /// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need the alpha blending (faster)
        /// * Updating a simple Line mesh, you just need to update every line in the `lines` array : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// * When updating an instance, remember that only line point positions can change, not the number of points, neither the number of lines
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the new line system</param>
        /// <param name="options">defines the options used to create the line system</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateLineSystem: name: string * options: MeshBuilderStaticCreateLineSystemOptions * scene: Nullable<Scene> -> LinesMesh
        /// <summary>Creates a line mesh
        /// A line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
        /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
        /// * The parameter `points` is an array successive Vector3
        /// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// * The optional parameter `colors` is an array of successive Color4, one per line point
        /// * The optional parameter `useVertexAlpha` is to be set to `false` (default `true`) when you don't need alpha blending (faster)
        /// * When updating an instance, remember that only point positions can change, not the number of points
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the new line system</param>
        /// <param name="options">defines the options used to create the line system</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateLines: name: string * options: MeshBuilderStaticCreateLinesOptions * ?scene: Nullable<Scene> -> LinesMesh
        /// <summary>Creates a dashed line mesh
        /// * A dashed line mesh is considered as a parametric shape since it has no predefined original shape. Its shape is determined by the passed array of points as an input parameter
        /// * Like every other parametric shape, it is dynamically updatable by passing an existing instance of LineMesh to this static function
        /// * The parameter `points` is an array successive Vector3
        /// * The parameter `dashNb` is the intended total number of dashes (positive integer, default 200)
        /// * The parameter `dashSize` is the size of the dashes relatively the dash number (positive float, default 3)
        /// * The parameter `gapSize` is the size of the gap between two successive dashes relatively the dash number (positive float, default 1)
        /// * The optional parameter `instance` is an instance of an existing LineMesh object to be updated with the passed `points` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#lines-and-dashedlines
        /// * When updating an instance, remember that only point positions can change, not the number of points
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateDashedLines: name: string * options: MeshBuilderStaticCreateDashedLinesOptions * ?scene: Nullable<Scene> -> LinesMesh
        /// <summary>Creates an extruded shape mesh. The extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
        /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
        /// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
        /// * The parameter `rotation` (float, default 0 radians) is the angle value to rotate the shape each step (each path point), from the former step (so rotation added each step) along the curve.
        /// * The parameter `scale` (float, default 1) is the value to scale the shape.
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
        /// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape.
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture.
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ExtrudeShape: name: string * options: MeshBuilderStaticExtrudeShapeOptions * ?scene: Nullable<Scene> -> Mesh
        /// <summary>Creates an custom extruded shape mesh.
        /// The custom extrusion is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters.
        /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be extruded in its local space : the shape must be designed in the xOy plane and will be extruded along the Z axis.
        /// * The parameter `path` is a required array of successive Vector3. This is the axis curve the shape is extruded along.
        /// * The parameter `rotationFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
        /// * It must returns a float value that will be the rotation in radians applied to the shape on each path point.
        /// * The parameter `scaleFunction` (JS function) is a custom Javascript function called on each path point. This function is passed the position i of the point in the path and the distance of this point from the begining of the path
        /// * It must returns a float value that will be the scale value applied to the shape on each path point
        /// * The parameter `ribbonClosePath` (boolean, default false) forces the extrusion underlying ribbon to close all the paths in its `pathArray`
        /// * The parameter `ribbonCloseArray` (boolean, default false) forces the extrusion underlying ribbon to close its `pathArray`
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * The optional parameter `instance` is an instance of an existing ExtrudedShape object to be updated with the passed `shape`, `path`, `scale` or `rotation` parameters : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#extruded-shape
        /// * Remember you can only change the shape or path point positions, not their number when updating an extruded shape
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ExtrudeShapeCustom: name: string * options: MeshBuilderStaticExtrudeShapeCustomOptions * scene: Scene -> Mesh
        /// <summary>Creates lathe mesh.
        /// The lathe is a shape with a symetry axis : a 2D model shape is rotated around this axis to design the lathe
        /// * The parameter `shape` is a required array of successive Vector3. This array depicts the shape to be rotated in its local space : the shape must be designed in the xOy plane and will be rotated around the Y axis. It's usually a 2D shape, so the Vector3 z coordinates are often set to zero
        /// * The parameter `radius` (positive float, default 1) is the radius value of the lathe
        /// * The parameter `tessellation` (positive integer, default 64) is the side number of the lathe
        /// * The parameter `arc` (positive float, default 1) is the ratio of the lathe. 0.5 builds for instance half a lathe, so an opened shape
        /// * The parameter `closed` (boolean, default true) opens/closes the lathe circumference. This should be set to false when used with the parameter "arc"
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateLathe: name: string * options: MeshBuilderStaticCreateLatheOptions * scene: Scene -> Mesh
        /// <summary>Creates a plane mesh
        /// * The parameter `size` sets the size (float) of both sides of the plane at once (default 1)
        /// * You can set some different plane dimensions by using the parameters `width` and `height` (both by default have the same value than `size`)
        /// * The parameter `sourcePlane` is a Plane instance. It builds a mesh plane from a Math plane
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreatePlane: name: string * options: MeshBuilderStaticCreatePlaneOptions * scene: Scene -> Mesh
        /// <summary>Creates a ground mesh
        /// * The parameters `width` and `height` (floats, default 1) set the width and height sizes of the ground
        /// * The parameter `subdivisions` (positive integer) sets the number of subdivisions per side
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateGround: name: string * options: MeshBuilderStaticCreateGroundOptions * scene: obj option -> Mesh
        /// <summary>Creates a tiled ground mesh
        /// * The parameters `xmin` and `xmax` (floats, default -1 and 1) set the ground minimum and maximum X coordinates
        /// * The parameters `zmin` and `zmax` (floats, default -1 and 1) set the ground minimum and maximum Z coordinates
        /// * The parameter `subdivisions` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 6, h: 6}`). `w` and `h` are the numbers of subdivisions on the ground width and height. Each subdivision is called a tile
        /// * The parameter `precision` is a javascript object `{w: positive integer, h: positive integer}` (default `{w: 2, h: 2}`). `w` and `h` are the numbers of subdivisions on the ground width and height of each tile
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTiledGround: name: string * options: MeshBuilderStaticCreateTiledGroundOptions * scene: Scene -> Mesh
        /// <summary>Creates a ground mesh from a height map
        /// * The parameter `url` sets the URL of the height map image resource.
        /// * The parameters `width` and `height` (positive floats, default 10) set the ground width and height sizes.
        /// * The parameter `subdivisions` (positive integer, default 1) sets the number of subdivision per side.
        /// * The parameter `minHeight` (float, default 0) is the minimum altitude on the ground.
        /// * The parameter `maxHeight` (float, default 1) is the maximum altitude on the ground.
        /// * The parameter `colorFilter` (optional Color3, default (0.3, 0.59, 0.11) ) is the filter to apply to the image pixel colors to compute the height.
        /// * The parameter `onReady` is a javascript callback function that will be called  once the mesh is just built (the height map download can last some time).
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created.</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="url">defines the url to the height map</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateGroundFromHeightMap: name: string * url: string * options: MeshBuilderStaticCreateGroundFromHeightMapOptions * scene: Scene -> GroundMesh
        /// <summary>Creates a polygon mesh
        /// The polygon's shape will depend on the input parameters and is constructed parallel to a ground mesh
        /// * The parameter `shape` is a required array of successive Vector3 representing the corners of the polygon in th XoZ plane, that is y = 0 for all vectors
        /// * You can set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4)
        /// * Remember you can only change the shape positions, not their number when updating a polygon</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreatePolygon: name: string * options: MeshBuilderStaticCreatePolygonOptions * scene: Scene -> Mesh
        /// <summary>Creates an extruded polygon mesh, with depth in the Y direction.
        /// * You can set different colors and different images to the top, bottom and extruded side by using the parameters `faceColors` (an array of 3 Color3 elements) and `faceUV` (an array of 3 Vector4 elements)</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract ExtrudePolygon: name: string * options: MeshBuilderStaticExtrudePolygonOptions * scene: Scene -> Mesh
        /// <summary>Creates a tube mesh.
        /// The tube is a parametric shape. It has no predefined shape. Its final shape will depend on the input parameters
        /// * The parameter `path` is a required array of successive Vector3. It is the curve used as the axis of the tube
        /// * The parameter `radius` (positive float, default 1) sets the tube radius size
        /// * The parameter `tessellation` (positive float, default 64) is the number of sides on the tubular surface
        /// * The parameter `radiusFunction` (javascript function, default null) is a vanilla javascript function. If it is not null, it overwrittes the parameter `radius`
        /// * This function is called on each point of the tube path and is passed the index `i` of the i-th point and the distance of this point from the first point of the path. It must return a radius value (positive float)
        /// * The parameter `arc` (positive float, maximum 1, default 1) is the ratio to apply to the tube circumference : 2 x PI x arc
        /// * The parameter `cap` sets the way the extruded shape is capped. Possible values : BABYLON.Mesh.NO_CAP (default), BABYLON.Mesh.CAP_START, BABYLON.Mesh.CAP_END, BABYLON.Mesh.CAP_ALL
        /// * The optional parameter `instance` is an instance of an existing Tube object to be updated with the passed `pathArray` parameter : http://doc.babylonjs.com/tutorials/How_to_dynamically_morph_a_mesh#tube
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The optional parameter `invertUV` (boolean, default false) swaps in the geometry the U and V coordinates to apply a texture
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreateTube: name: string * options: MeshBuilderStaticCreateTubeOptions * scene: Scene -> Mesh
        /// <summary>Creates a polyhedron mesh
        /// * The parameter `type` (positive integer, max 14, default 0) sets the polyhedron type to build among the 15 embbeded types. Please refer to the type sheet in the tutorial to choose the wanted type
        /// * The parameter `size` (positive float, default 1) sets the polygon size
        /// * You can overwrite the `size` on each dimension bu using the parameters `sizeX`, `sizeY` or `sizeZ` (positive floats, default to `size` value)
        /// * You can build other polyhedron types than the 15 embbeded ones by setting the parameter `custom` (`polyhedronObject`, default null). If you set the parameter `custom`, this overwrittes the parameter `type`
        /// * A `polyhedronObject` is a formatted javascript object. You'll find a full file with pre-set polyhedra here : https://github.com/BabylonJS/Extensions/tree/master/Polyhedron
        /// * You can set the color and the UV of each side of the polyhedron with the parameters `faceColors` (Color4, default `(1, 1, 1, 1)`) and faceUV (Vector4, default `(0, 0, 1, 1)`)
        /// * To understand how to set `faceUV` or `faceColors`, please read this by considering the right number of faces of your polyhedron, instead of only 6 for the box : http://doc.babylonjs.com/tutorials/CreateBox_Per_Face_Textures_And_Colors
        /// * The parameter `flat` (boolean, default true). If set to false, it gives the polyhedron a single global face, so less vertices and shared normals. In this case, `faceColors` and `faceUV` are ignored
        /// * You can also set the mesh side orientation with the values : BABYLON.Mesh.FRONTSIDE (default), BABYLON.Mesh.BACKSIDE or BABYLON.Mesh.DOUBLESIDE
        /// * If you create a double-sided mesh, you can choose what parts of the texture image to crop and stick respectively on the front and the back sides with the parameters `frontUVs` and `backUVs` (Vector4). Detail here : http://doc.babylonjs.com/tutorials/02._Discover_Basic_Elements#side-orientation
        /// * The mesh can be set to updatable with the boolean parameter `updatable` (default false) if its internal geometry is supposed to change once created</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="options">defines the options used to create the mesh</param>
        /// <param name="scene">defines the hosting scene</param>
        abstract CreatePolyhedron: name: string * options: MeshBuilderStaticCreatePolyhedronOptions * scene: Scene -> Mesh
        /// <summary>Creates a decal mesh.
        /// A decal is a mesh usually applied as a model onto the surface of another mesh. So don't forget the parameter `sourceMesh` depicting the decal
        /// * The parameter `position` (Vector3, default `(0, 0, 0)`) sets the position of the decal in World coordinates
        /// * The parameter `normal` (Vector3, default `Vector3.Up`) sets the normal of the mesh where the decal is applied onto in World coordinates
        /// * The parameter `size` (Vector3, default `(1, 1, 1)`) sets the decal scaling
        /// * The parameter `angle` (float in radian, default 0) sets the angle to rotate the decal</summary>
        /// <param name="name">defines the name of the mesh</param>
        /// <param name="sourceMesh">defines the mesh where the decal must be applied</param>
        /// <param name="options">defines the options used to create the mesh</param>
        abstract CreateDecal: name: string * sourceMesh: AbstractMesh * options: MeshBuilderStaticCreateDecalOptions -> Mesh
        abstract _ExtrudeShapeGeneric: name: obj * shape: obj * curve: obj * scale: obj * rotation: obj * scaleFunction: obj * rotateFunction: obj * rbCA: obj * rbCP: obj * cap: obj * custom: obj * scene: obj * updtbl: obj * side: obj * instance: obj * invertUV: obj * frontUVs: obj * backUVs: obj -> unit

    type [<AllowNullLiteral>] MeshBuilderStaticCreateBoxOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateSphereOptions =
        abstract segments: float option with get, set
        abstract diameter: float option with get, set
        abstract diameterX: float option with get, set
        abstract diameterY: float option with get, set
        abstract diameterZ: float option with get, set
        abstract arc: float option with get, set
        abstract slice: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateDiscOptions =
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract arc: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateIcoSphereOptions =
        abstract radius: float option with get, set
        abstract radiusX: float option with get, set
        abstract radiusY: float option with get, set
        abstract radiusZ: float option with get, set
        abstract flat: bool option with get, set
        abstract subdivisions: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateRibbonOptions =
        abstract pathArray: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract closeArray: bool option with get, set
        abstract closePath: bool option with get, set
        abstract offset: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set
        abstract uvs: ResizeArray<Vector2> option with get, set
        abstract colors: ResizeArray<Color4> option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateCylinderOptions =
        abstract height: float option with get, set
        abstract diameterTop: float option with get, set
        abstract diameterBottom: float option with get, set
        abstract diameter: float option with get, set
        abstract tessellation: float option with get, set
        abstract subdivisions: float option with get, set
        abstract arc: float option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract updatable: bool option with get, set
        abstract hasRings: bool option with get, set
        abstract enclose: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTorusOptions =
        abstract diameter: float option with get, set
        abstract thickness: float option with get, set
        abstract tessellation: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTorusKnotOptions =
        abstract radius: float option with get, set
        abstract tube: float option with get, set
        abstract radialSegments: float option with get, set
        abstract tubularSegments: float option with get, set
        abstract p: float option with get, set
        abstract q: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateLineSystemOptions =
        abstract lines: ResizeArray<ResizeArray<Vector3>> with get, set
        abstract updatable: bool option with get, set
        abstract instance: Nullable<LinesMesh> option with get, set
        abstract colors: Nullable<ResizeArray<ResizeArray<Color4>>> option with get, set
        abstract useVertexAlpha: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateLinesOptions =
        abstract points: ResizeArray<Vector3> with get, set
        abstract updatable: bool option with get, set
        abstract instance: Nullable<LinesMesh> option with get, set
        abstract colors: ResizeArray<Color4> option with get, set
        abstract useVertexAlpha: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateDashedLinesOptions =
        abstract points: ResizeArray<Vector3> with get, set
        abstract dashSize: float option with get, set
        abstract gapSize: float option with get, set
        abstract dashNb: float option with get, set
        abstract updatable: bool option with get, set
        abstract instance: LinesMesh option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticExtrudeShapeOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract path: ResizeArray<Vector3> with get, set
        abstract scale: float option with get, set
        abstract rotation: float option with get, set
        abstract cap: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticExtrudeShapeCustomOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract path: ResizeArray<Vector3> with get, set
        abstract scaleFunction: obj option with get, set
        abstract rotationFunction: obj option with get, set
        abstract ribbonCloseArray: bool option with get, set
        abstract ribbonClosePath: bool option with get, set
        abstract cap: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateLatheOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract arc: float option with get, set
        abstract closed: bool option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract cap: float option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreatePlaneOptions =
        abstract size: float option with get, set
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract updatable: bool option with get, set
        abstract sourcePlane: Plane option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateGroundOptions =
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract subdivisions: float option with get, set
        abstract subdivisionsX: float option with get, set
        abstract subdivisionsY: float option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTiledGroundOptions =
        abstract xmin: float with get, set
        abstract zmin: float with get, set
        abstract xmax: float with get, set
        abstract zmax: float with get, set
        abstract subdivisions: obj option with get, set
        abstract precision: obj option with get, set
        abstract updatable: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateGroundFromHeightMapOptions =
        abstract width: float option with get, set
        abstract height: float option with get, set
        abstract subdivisions: float option with get, set
        abstract minHeight: float option with get, set
        abstract maxHeight: float option with get, set
        abstract colorFilter: Color3 option with get, set
        abstract updatable: bool option with get, set
        abstract onReady: (GroundMesh -> unit) option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreatePolygonOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract holes: ResizeArray<ResizeArray<Vector3>> option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticExtrudePolygonOptions =
        abstract shape: ResizeArray<Vector3> with get, set
        abstract holes: ResizeArray<ResizeArray<Vector3>> option with get, set
        abstract depth: float option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateTubeOptions =
        abstract path: ResizeArray<Vector3> with get, set
        abstract radius: float option with get, set
        abstract tessellation: float option with get, set
        abstract radiusFunction: obj option with get, set
        abstract cap: float option with get, set
        abstract arc: float option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set
        abstract instance: Mesh option with get, set
        abstract invertUV: bool option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreatePolyhedronOptions =
        abstract ``type``: float option with get, set
        abstract size: float option with get, set
        abstract sizeX: float option with get, set
        abstract sizeY: float option with get, set
        abstract sizeZ: float option with get, set
        abstract custom: obj option with get, set
        abstract faceUV: ResizeArray<Vector4> option with get, set
        abstract faceColors: ResizeArray<Color4> option with get, set
        abstract flat: bool option with get, set
        abstract updatable: bool option with get, set
        abstract sideOrientation: float option with get, set
        abstract frontUVs: Vector4 option with get, set
        abstract backUVs: Vector4 option with get, set

    type [<AllowNullLiteral>] MeshBuilderStaticCreateDecalOptions =
        abstract position: Vector3 option with get, set
        abstract normal: Vector3 option with get, set
        abstract size: Vector3 option with get, set
        abstract angle: float option with get, set

    type [<AllowNullLiteral>] MeshLODLevel =
        abstract distance: float with get, set
        abstract mesh: Mesh with get, set

    type [<AllowNullLiteral>] MeshLODLevelStatic =
        [<Emit "new $0($1...)">] abstract Create: distance: float * mesh: Mesh -> MeshLODLevel

    /// A simplifier interface for future simplification implementations.
    type [<AllowNullLiteral>] ISimplifier =
        /// <summary>Simplification of a given mesh according to the given settings.
        /// Since this requires computation, it is assumed that the function runs async.</summary>
        /// <param name="settings">The settings of the simplification, including quality and distance</param>
        /// <param name="successCallback">A callback that will be called after the mesh was simplified.</param>
        /// <param name="errorCallback">in case of an error, this callback will be called. optional.</param>
        abstract simplify: settings: ISimplificationSettings * successCallback: (Mesh -> unit) * ?errorCallback: (unit -> unit) -> unit

    /// Expected simplification settings.
    /// Quality should be between 0 and 1 (1 being 100%, 0 being 0%);
    type [<AllowNullLiteral>] ISimplificationSettings =
        abstract quality: float with get, set
        abstract distance: float with get, set
        abstract optimizeMesh: bool option with get, set

    type [<AllowNullLiteral>] SimplificationSettings =
        inherit ISimplificationSettings
        abstract quality: float with get, set
        abstract distance: float with get, set
        abstract optimizeMesh: bool option with get, set

    type [<AllowNullLiteral>] SimplificationSettingsStatic =
        [<Emit "new $0($1...)">] abstract Create: quality: float * distance: float * ?optimizeMesh: bool option -> SimplificationSettings

    type [<AllowNullLiteral>] ISimplificationTask =
        abstract settings: Array<ISimplificationSettings> with get, set
        abstract simplificationType: SimplificationType with get, set
        abstract mesh: Mesh with get, set
        abstract successCallback: (unit -> unit) option with get, set
        abstract parallelProcessing: bool with get, set

    type [<AllowNullLiteral>] SimplificationQueue =
        abstract _simplificationArray: obj with get, set
        abstract running: bool with get, set
        abstract addTask: task: ISimplificationTask -> unit
        abstract executeNext: unit -> unit
        abstract runSimplification: task: ISimplificationTask -> unit
        abstract getSimplifier: task: obj -> unit

    type [<AllowNullLiteral>] SimplificationQueueStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SimplificationQueue

    type [<RequireQualifiedAccess>] SimplificationType =
        | QUADRATIC = 0

    type [<AllowNullLiteral>] DecimationTriangle =
        abstract vertices: Array<DecimationVertex> with get, set
        abstract normal: Vector3 with get, set
        abstract error: Array<float> with get, set
        abstract deleted: bool with get, set
        abstract isDirty: bool with get, set
        abstract borderFactor: float with get, set
        abstract deletePending: bool with get, set
        abstract originalOffset: float with get, set

    type [<AllowNullLiteral>] DecimationTriangleStatic =
        [<Emit "new $0($1...)">] abstract Create: vertices: Array<DecimationVertex> -> DecimationTriangle

    type [<AllowNullLiteral>] DecimationVertex =
        abstract position: Vector3 with get, set
        abstract id: float with get, set
        abstract q: QuadraticMatrix with get, set
        abstract isBorder: bool with get, set
        abstract triangleStart: float with get, set
        abstract triangleCount: float with get, set
        abstract originalOffsets: Array<float> with get, set
        abstract updatePosition: newPosition: Vector3 -> unit

    type [<AllowNullLiteral>] DecimationVertexStatic =
        [<Emit "new $0($1...)">] abstract Create: position: Vector3 * id: float -> DecimationVertex

    type [<AllowNullLiteral>] QuadraticMatrix =
        abstract data: Array<float> with get, set
        abstract det: a11: float * a12: float * a13: float * a21: float * a22: float * a23: float * a31: float * a32: float * a33: float -> float
        abstract addInPlace: matrix: QuadraticMatrix -> unit
        abstract addArrayInPlace: data: Array<float> -> unit
        abstract add: matrix: QuadraticMatrix -> QuadraticMatrix

    type [<AllowNullLiteral>] QuadraticMatrixStatic =
        [<Emit "new $0($1...)">] abstract Create: ?data: Array<float> -> QuadraticMatrix
        abstract FromData: a: float * b: float * c: float * d: float -> QuadraticMatrix
        abstract DataFromNumbers: a: float * b: float * c: float * d: float -> ResizeArray<float>

    type [<AllowNullLiteral>] Reference =
        abstract vertexId: float with get, set
        abstract triangleId: float with get, set

    type [<AllowNullLiteral>] ReferenceStatic =
        [<Emit "new $0($1...)">] abstract Create: vertexId: float * triangleId: float -> Reference

    /// An implementation of the Quadratic Error simplification algorithm.
    /// Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf
    /// Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS
    type [<AllowNullLiteral>] QuadraticErrorSimplification =
        inherit ISimplifier
        abstract _mesh: obj with get, set
        abstract triangles: obj with get, set
        abstract vertices: obj with get, set
        abstract references: obj with get, set
        abstract _reconstructedMesh: obj with get, set
        abstract syncIterations: float with get, set
        abstract aggressiveness: float with get, set
        abstract decimationIterations: float with get, set
        abstract boundingBoxEpsilon: float with get, set
        abstract simplify: settings: ISimplificationSettings * successCallback: (Mesh -> unit) -> unit
        abstract runDecimation: settings: obj * submeshIndex: obj * successCallback: obj -> unit
        abstract initWithMesh: submeshIndex: obj * callback: obj * ?optimizeMesh: obj -> unit
        abstract init: callback: obj -> unit
        abstract reconstructMesh: submeshIndex: obj -> unit
        abstract initDecimatedMesh: unit -> unit
        abstract isFlipped: vertex1: obj * vertex2: obj * point: obj * deletedArray: obj * borderFactor: obj * delTr: obj -> unit
        abstract updateTriangles: origVertex: obj * vertex: obj * deletedArray: obj * deletedTriangles: obj -> unit
        abstract identifyBorder: unit -> unit
        abstract updateMesh: ?identifyBorders: obj -> unit
        abstract vertexError: q: obj * point: obj -> unit
        abstract calculateError: vertex1: obj * vertex2: obj * ?pointResult: obj * ?normalResult: obj * ?uvResult: obj * ?colorResult: obj -> unit

    /// An implementation of the Quadratic Error simplification algorithm.
    /// Original paper : http://www1.cs.columbia.edu/~cs4162/html05s/garland97.pdf
    /// Ported mostly from QSlim and http://voxels.blogspot.de/2014/05/quadric-mesh-simplification-with-source.html to babylon JS
    type [<AllowNullLiteral>] QuadraticErrorSimplificationStatic =
        [<Emit "new $0($1...)">] abstract Create: _mesh: Mesh -> QuadraticErrorSimplification

    type [<AllowNullLiteral>] Polygon =
        interface end

    type [<AllowNullLiteral>] PolygonStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Polygon
        abstract Rectangle: xmin: float * ymin: float * xmax: float * ymax: float -> ResizeArray<Vector2>
        abstract Circle: radius: float * ?cx: float * ?cy: float * ?numberOfSides: float -> ResizeArray<Vector2>
        abstract Parse: input: string -> ResizeArray<Vector2>
        abstract StartingAt: x: float * y: float -> Path2

    type [<AllowNullLiteral>] PolygonMeshBuilder =
        abstract _points: obj with get, set
        abstract _outlinepoints: obj with get, set
        abstract _holes: obj with get, set
        abstract _name: obj with get, set
        abstract _scene: obj with get, set
        abstract _epoints: obj with get, set
        abstract _eholes: obj with get, set
        abstract _addToepoint: points: obj -> unit
        abstract addHole: hole: ResizeArray<Vector2> -> PolygonMeshBuilder
        abstract build: ?updatable: bool * ?depth: float -> Mesh
        abstract addSide: positions: obj * normals: obj * uvs: obj * indices: obj * bounds: obj * points: obj * depth: obj * flip: obj -> unit

    type [<AllowNullLiteral>] PolygonMeshBuilderStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * contours: Path2 * scene: Scene -> PolygonMeshBuilder
        [<Emit "new $0($1...)">] abstract Create: name: string * contours: ResizeArray<Vector2> * scene: Scene -> PolygonMeshBuilder

    type [<AllowNullLiteral>] BaseSubMesh =
        abstract _materialDefines: Nullable<MaterialDefines> with get, set
        abstract _materialEffect: Nullable<Effect> with get, set
        abstract effect: Nullable<Effect>
        abstract setEffect: effect: Nullable<Effect> * ?defines: Nullable<MaterialDefines> -> unit

    type [<AllowNullLiteral>] BaseSubMeshStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> BaseSubMesh

    type [<AllowNullLiteral>] SubMesh =
        inherit BaseSubMesh
        inherit ICullable
        abstract materialIndex: float with get, set
        abstract verticesStart: float with get, set
        abstract verticesCount: float with get, set
        abstract indexStart: float with get, set
        abstract indexCount: float with get, set
        abstract linesIndexCount: float with get, set
        abstract _mesh: obj with get, set
        abstract _renderingMesh: obj with get, set
        abstract _boundingInfo: obj with get, set
        abstract _linesIndexBuffer: obj with get, set
        abstract _lastColliderWorldVertices: Nullable<ResizeArray<Vector3>> with get, set
        abstract _trianglePlanes: ResizeArray<Plane> with get, set
        abstract _lastColliderTransformMatrix: Matrix with get, set
        abstract _renderId: float with get, set
        abstract _alphaIndex: float with get, set
        abstract _distanceToCamera: float with get, set
        abstract _id: float with get, set
        abstract _currentMaterial: obj with get, set
        abstract IsGlobal: bool
        /// Returns the submesh BoudingInfo object.
        abstract getBoundingInfo: unit -> BoundingInfo
        /// Sets the submesh BoundingInfo.
        /// Return the SubMesh.
        abstract setBoundingInfo: boundingInfo: BoundingInfo -> SubMesh
        /// Returns the mesh of the current submesh.
        abstract getMesh: unit -> AbstractMesh
        /// Returns the rendering mesh of the submesh.
        abstract getRenderingMesh: unit -> Mesh
        /// Returns the submesh material.
        abstract getMaterial: unit -> Nullable<Material>
        /// Sets a new updated BoundingInfo object to the submesh.
        /// Returns the SubMesh.
        abstract refreshBoundingInfo: unit -> SubMesh
        abstract _checkCollision: collider: Collider -> bool
        /// Updates the submesh BoundingInfo.
        /// Returns the Submesh.
        abstract updateBoundingInfo: world: Matrix -> SubMesh
        /// True is the submesh bounding box intersects the frustum defined by the passed array of planes.
        /// Boolean returned.
        abstract isInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// True is the submesh bounding box is completely inside the frustum defined by the passed array of planes.
        /// Boolean returned.
        abstract isCompletelyInFrustum: frustumPlanes: ResizeArray<Plane> -> bool
        /// Renders the submesh.
        /// Returns it.
        abstract render: enableAlphaMode: bool -> SubMesh
        /// Returns a new Index Buffer.
        /// Type returned : WebGLBuffer.
        abstract getLinesIndexBuffer: indices: IndicesArray * engine: Engine -> WebGLBuffer
        /// True is the passed Ray intersects the submesh bounding box.
        /// Boolean returned.
        abstract canIntersects: ray: Ray -> bool
        /// Returns an object IntersectionInfo.
        abstract intersects: ray: Ray * positions: ResizeArray<Vector3> * indices: IndicesArray * ?fastCheck: bool -> Nullable<IntersectionInfo>
        abstract _rebuild: unit -> unit
        /// Creates a new Submesh from the passed Mesh.
        abstract clone: newMesh: AbstractMesh * ?newRenderingMesh: Mesh -> SubMesh
        /// Disposes the Submesh.
        /// Returns nothing.
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] SubMeshStatic =
        abstract AddToMesh: materialIndex: float * verticesStart: float * verticesCount: float * indexStart: float * indexCount: float * mesh: AbstractMesh * ?renderingMesh: Mesh * ?createBoundingBox: bool -> SubMesh
        [<Emit "new $0($1...)">] abstract Create: materialIndex: float * verticesStart: float * verticesCount: float * indexStart: float * indexCount: float * mesh: AbstractMesh * ?renderingMesh: Mesh * ?createBoundingBox: bool -> SubMesh
        /// Creates a new Submesh from the passed parameters :
        /// - materialIndex (integer) : the index of the main mesh material.
        /// - startIndex (integer) : the index where to start the copy in the mesh indices array.
        /// - indexCount (integer) : the number of indices to copy then from the startIndex.
        /// - mesh (Mesh) : the main mesh to create the submesh from.
        /// - renderingMesh (optional Mesh) : rendering mesh.
        abstract CreateFromIndices: materialIndex: float * startIndex: float * indexCount: float * mesh: AbstractMesh * ?renderingMesh: Mesh -> SubMesh

    type [<AllowNullLiteral>] TransformNode =
        inherit Node
        abstract BILLBOARDMODE_NONE: float with get, set
        abstract BILLBOARDMODE_X: float with get, set
        abstract BILLBOARDMODE_Y: float with get, set
        abstract BILLBOARDMODE_Z: float with get, set
        abstract BILLBOARDMODE_ALL: float with get, set
        abstract _forward: obj with get, set
        abstract _forwardInverted: obj with get, set
        abstract _up: obj with get, set
        abstract _right: obj with get, set
        abstract _rightInverted: obj with get, set
        abstract _rotation: obj with get, set
        abstract _rotationQuaternion: obj with get, set
        abstract _scaling: Vector3 with get, set
        abstract _isDirty: bool with get, set
        abstract _transformToBoneReferal: obj with get, set
        abstract billboardMode: float with get, set
        abstract scalingDeterminant: float with get, set
        abstract infiniteDistance: bool with get, set
        abstract position: Vector3 with get, set
        abstract _poseMatrix: Matrix with get, set
        abstract _localWorld: obj with get, set
        abstract _worldMatrix: Matrix with get, set
        abstract _worldMatrixDeterminant: float with get, set
        abstract _absolutePosition: obj with get, set
        abstract _pivotMatrix: obj with get, set
        abstract _pivotMatrixInverse: obj with get, set
        abstract _postMultiplyPivotMatrix: obj with get, set
        abstract _isWorldMatrixFrozen: bool with get, set
        /// An event triggered after the world matrix is updated
        abstract onAfterWorldMatrixUpdateObservable: Observable<TransformNode> with get, set
        /// Gets a string idenfifying the name of the class
        abstract getClassName: unit -> string
        /// Rotation property : a Vector3 depicting the rotation value in radians around each local axis X, Y, Z.
        /// If rotation quaternion is set, this Vector3 will (almost always) be the Zero vector!
        /// Default : (0.0, 0.0, 0.0)
        abstract rotation: Vector3 with get, set
        /// Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
        /// Default : (1.0, 1.0, 1.0)
        /// Scaling property : a Vector3 depicting the mesh scaling along each local axis X, Y, Z.
        /// Default : (1.0, 1.0, 1.0)
        abstract scaling: Vector3 with get, set
        /// Rotation Quaternion property : this a Quaternion object depicting the mesh rotation by using a unit quaternion.
        /// It's null by default.
        /// If set, only the rotationQuaternion is then used to compute the mesh rotation and its property `.rotation\ is then ignored and set to (0.0, 0.0, 0.0)
        abstract rotationQuaternion: Nullable<Quaternion> with get, set
        /// The forward direction of that transform in world space.
        abstract forward: Vector3
        /// The up direction of that transform in world space.
        abstract up: Vector3
        /// The right direction of that transform in world space.
        abstract right: Vector3
        /// Returns the latest update of the World matrix
        /// Returns a Matrix.
        abstract getWorldMatrix: unit -> Matrix
        /// Returns the latest update of the World matrix determinant.
        abstract _getWorldMatrixDeterminant: unit -> float
        /// Returns directly the latest state of the mesh World matrix.
        /// A Matrix is returned.
        abstract worldMatrixFromCache: Matrix
        /// Copies the paramater passed Matrix into the mesh Pose matrix.
        /// Returns the TransformNode.
        abstract updatePoseMatrix: matrix: Matrix -> TransformNode
        /// Returns the mesh Pose matrix.
        /// Returned object : Matrix
        abstract getPoseMatrix: unit -> Matrix
        abstract _isSynchronized: unit -> bool
        abstract _initCache: unit -> unit
        abstract markAsDirty: property: string -> TransformNode
        /// Returns the current mesh absolute position.
        /// Retuns a Vector3.
        abstract absolutePosition: Vector3
        /// <summary>Sets a new matrix to apply before all other transformation</summary>
        /// <param name="matrix">defines the transform matrix</param>
        abstract setPreTransformMatrix: matrix: Matrix -> TransformNode
        /// <summary>Sets a new pivot matrix to the current node</summary>
        /// <param name="matrix">defines the new pivot matrix to use</param>
        /// <param name="postMultiplyPivotMatrix">defines if the pivot matrix must be cancelled in the world matrix. When this parameter is set to true (default), the inverse of the pivot matrix is also applied at the end to cancel the transformation effect</param>
        abstract setPivotMatrix: matrix: Matrix * ?postMultiplyPivotMatrix: bool -> TransformNode
        /// Returns the mesh pivot matrix.
        /// Default : Identity.
        /// A Matrix is returned.
        abstract getPivotMatrix: unit -> Matrix
        /// Prevents the World matrix to be computed any longer.
        /// Returns the TransformNode.
        abstract freezeWorldMatrix: unit -> TransformNode
        /// Allows back the World matrix computation.
        /// Returns the TransformNode.
        abstract unfreezeWorldMatrix: unit -> TransformNode
        /// True if the World matrix has been frozen.
        /// Returns a boolean.
        abstract isWorldMatrixFrozen: bool
        /// Retuns the mesh absolute position in the World.
        /// Returns a Vector3.
        abstract getAbsolutePosition: unit -> Vector3
        /// Sets the mesh absolute position in the World from a Vector3 or an Array(3).
        /// Returns the TransformNode.
        abstract setAbsolutePosition: absolutePosition: Vector3 -> TransformNode
        /// Sets the mesh position in its local space.
        /// Returns the TransformNode.
        abstract setPositionWithLocalVector: vector3: Vector3 -> TransformNode
        /// Returns the mesh position in the local space from the current World matrix values.
        /// Returns a new Vector3.
        abstract getPositionExpressedInLocalSpace: unit -> Vector3
        /// Translates the mesh along the passed Vector3 in its local space.
        /// Returns the TransformNode.
        abstract locallyTranslate: vector3: Vector3 -> TransformNode
        abstract _lookAtVectorCache: obj with get, set
        /// <summary>Orients a mesh towards a target point. Mesh must be drawn facing user.</summary>
        /// <param name="targetPoint">the position (must be in same space as current mesh) to look at</param>
        /// <param name="yawCor">optional yaw (y-axis) correction in radians</param>
        /// <param name="pitchCor">optional pitch (x-axis) correction in radians</param>
        /// <param name="rollCor">optional roll (z-axis) correction in radians</param>
        /// <param name="space">the choosen space of the target</param>
        abstract lookAt: targetPoint: Vector3 * ?yawCor: float * ?pitchCor: float * ?rollCor: float * ?space: Space -> TransformNode
        /// Returns a new Vector3 what is the localAxis, expressed in the mesh local space, rotated like the mesh.
        /// This Vector3 is expressed in the World space.
        abstract getDirection: localAxis: Vector3 -> Vector3
        /// Sets the Vector3 "result" as the rotated Vector3 "localAxis" in the same rotation than the mesh.
        /// localAxis is expressed in the mesh local space.
        /// result is computed in the Wordl space from the mesh World matrix.
        /// Returns the TransformNode.
        abstract getDirectionToRef: localAxis: Vector3 * result: Vector3 -> TransformNode
        /// <summary>Sets a new pivot point to the current node</summary>
        /// <param name="point">defines the new pivot point to use</param>
        /// <param name="space">defines if the point is in world or local space (local by default)</param>
        abstract setPivotPoint: point: Vector3 * ?space: Space -> TransformNode
        /// Returns a new Vector3 set with the mesh pivot point coordinates in the local space.
        abstract getPivotPoint: unit -> Vector3
        /// Sets the passed Vector3 "result" with the coordinates of the mesh pivot point in the local space.
        /// Returns the TransformNode.
        abstract getPivotPointToRef: result: Vector3 -> TransformNode
        /// Returns a new Vector3 set with the mesh pivot point World coordinates.
        abstract getAbsolutePivotPoint: unit -> Vector3
        /// Sets the Vector3 "result" coordinates with the mesh pivot point World coordinates.
        /// Returns the TransformNode.
        abstract getAbsolutePivotPointToRef: result: Vector3 -> TransformNode
        /// Defines the passed node as the parent of the current node.
        /// The node will remain exactly where it is and its position / rotation will be updated accordingly
        /// Returns the TransformNode.
        abstract setParent: node: Nullable<Node> -> TransformNode
        abstract _nonUniformScaling: obj with get, set
        abstract nonUniformScaling: bool
        abstract _updateNonUniformScalingState: value: bool -> bool
        /// <summary>Attach the current TransformNode to another TransformNode associated with a bone</summary>
        /// <param name="bone">Bone affecting the TransformNode</param>
        /// <param name="affectedTransformNode">TransformNode associated with the bone</param>
        abstract attachToBone: bone: Bone * affectedTransformNode: TransformNode -> TransformNode
        abstract detachFromBone: unit -> TransformNode
        abstract _rotationAxisCache: obj with get, set
        /// Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in the given space.
        /// space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.
        /// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
        /// The passed axis is also normalized.
        /// Returns the TransformNode.
        abstract rotate: axis: Vector3 * amount: float * ?space: Space -> TransformNode
        /// Rotates the mesh around the axis vector for the passed angle (amount) expressed in radians, in world space.
        /// Note that the property `rotationQuaternion` is then automatically updated and the property `rotation` is set to (0,0,0) and no longer used.
        /// The passed axis is also normalized.
        /// Returns the TransformNode.
        /// Method is based on http://www.euclideanspace.com/maths/geometry/affine/aroundPoint/index.htm
        abstract rotateAround: point: Vector3 * axis: Vector3 * amount: float -> TransformNode
        /// Translates the mesh along the axis vector for the passed distance in the given space.
        /// space (default LOCAL) can be either BABYLON.Space.LOCAL, either BABYLON.Space.WORLD.
        /// Returns the TransformNode.
        abstract translate: axis: Vector3 * distance: float * ?space: Space -> TransformNode
        /// Adds a rotation step to the mesh current rotation.
        /// x, y, z are Euler angles expressed in radians.
        /// This methods updates the current mesh rotation, either mesh.rotation, either mesh.rotationQuaternion if it's set.
        /// This means this rotation is made in the mesh local space only.
        /// It's useful to set a custom rotation order different from the BJS standard one YXZ.
        /// Example : this rotates the mesh first around its local X axis, then around its local Z axis, finally around its local Y axis.
        /// ```javascript
        /// mesh.addRotation(x1, 0, 0).addRotation(0, 0, z2).addRotation(0, 0, y3);
        /// ```
        /// Note that `addRotation()` accumulates the passed rotation values to the current ones and computes the .rotation or .rotationQuaternion updated values.
        /// Under the hood, only quaternions are used. So it's a little faster is you use .rotationQuaternion because it doesn't need to translate them back to Euler angles.
        /// Returns the TransformNode.
        abstract addRotation: x: float * y: float * z: float -> TransformNode
        /// Computes the mesh World matrix and returns it.
        /// If the mesh world matrix is frozen, this computation does nothing more than returning the last frozen values.
        /// If the parameter `force` is let to `false` (default), the current cached World matrix is returned.
        /// If the parameter `force`is set to `true`, the actual computation is done.
        /// Returns the mesh World Matrix.
        abstract computeWorldMatrix: ?force: bool -> Matrix
        abstract _afterComputeWorldMatrix: unit -> unit
        /// <summary>If you'd like to be called back after the mesh position, rotation or scaling has been updated.</summary>
        /// <param name="func">: callback function to add
        /// 
        /// Returns the TransformNode.</param>
        abstract registerAfterWorldMatrixUpdate: func: (TransformNode -> unit) -> TransformNode
        /// Removes a registered callback function.
        /// Returns the TransformNode.
        abstract unregisterAfterWorldMatrixUpdate: func: (TransformNode -> unit) -> TransformNode
        /// <summary>Clone the current transform node
        /// Returns the new transform node</summary>
        /// <param name="name">Name of the new clone</param>
        /// <param name="newParent">New parent for the clone</param>
        /// <param name="doNotCloneChildren">Do not clone children hierarchy</param>
        abstract clone: name: string * newParent: Node * ?doNotCloneChildren: bool -> Nullable<TransformNode>
        abstract serialize: ?currentSerializationObject: obj option -> obj option
        /// <summary>Releases resources associated with this transform node.</summary>
        /// <param name="doNotRecurse">Set to true to not recurse into each children (recurse into each children by default)</param>
        /// <param name="disposeMaterialAndTextures">Set to true to also dispose referenced materials and textures (false by default)</param>
        abstract dispose: ?doNotRecurse: bool * ?disposeMaterialAndTextures: bool -> unit

    type [<AllowNullLiteral>] TransformNodeStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * ?scene: Nullable<Scene> * ?isPure: bool -> TransformNode
        /// Returns a new TransformNode object parsed from the source provided.
        /// The parameter `parsedMesh` is the source.
        /// The parameter `rootUrl` is a string, it's the root URL to prefix the `delayLoadingFile` property with
        abstract Parse: parsedTransformNode: obj option * scene: Scene * rootUrl: string -> TransformNode

    type [<AllowNullLiteral>] VertexBuffer =
        abstract _buffer: obj with get, set
        abstract _kind: obj with get, set
        abstract _size: obj with get, set
        abstract _ownsBuffer: obj with get, set
        abstract _instanced: obj with get, set
        abstract _instanceDivisor: obj with get, set
        /// The byte type.
        abstract BYTE: float
        /// The unsigned byte type.
        abstract UNSIGNED_BYTE: float
        /// The short type.
        abstract SHORT: float
        /// The unsigned short type.
        abstract UNSIGNED_SHORT: float
        /// The integer type.
        abstract INT: float
        /// The unsigned integer type.
        abstract UNSIGNED_INT: float
        /// The float type.
        abstract FLOAT: float
        /// Gets or sets the instance divisor when in instanced mode
        abstract instanceDivisor: float with get, set
        /// Gets the byte stride.
        abstract byteStride: float
        /// Gets the byte offset.
        abstract byteOffset: float
        /// Gets whether integer data values should be normalized into a certain range when being casted to a float.
        abstract normalized: bool
        /// Gets the data type of each component in the array.
        abstract ``type``: float
        abstract _rebuild: unit -> unit
        /// Returns the kind of the VertexBuffer (string).
        abstract getKind: unit -> string
        /// Boolean : is the VertexBuffer updatable ?
        abstract isUpdatable: unit -> bool
        /// Returns an array of numbers or a typed array containing the VertexBuffer data.
        abstract getData: unit -> Nullable<DataArray>
        /// Returns the WebGLBuffer associated to the VertexBuffer.
        abstract getBuffer: unit -> Nullable<WebGLBuffer>
        /// Returns the stride as a multiple of the type byte length.
        /// DEPRECATED. Use byteStride instead.
        abstract getStrideSize: unit -> float
        /// Returns the offset as a multiple of the type byte length.
        /// DEPRECATED. Use byteOffset instead.
        abstract getOffset: unit -> float
        /// Returns the number of components per vertex attribute (integer).
        abstract getSize: unit -> float
        /// Boolean : is the WebGLBuffer of the VertexBuffer instanced now ?
        abstract getIsInstanced: unit -> bool
        /// Returns the instancing divisor, zero for non-instanced (integer).
        abstract getInstanceDivisor: unit -> float
        /// Creates the underlying WebGLBuffer from the passed numeric array or Float32Array.
        /// Returns the created WebGLBuffer.
        abstract create: ?data: DataArray -> unit
        /// Updates the underlying WebGLBuffer according to the passed numeric array or Float32Array.
        /// This function will create a new buffer if the current one is not updatable
        /// Returns the updated WebGLBuffer.
        abstract update: data: DataArray -> unit
        /// <summary>Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.
        /// Returns the directly updated WebGLBuffer.</summary>
        /// <param name="data">the new data</param>
        /// <param name="offset">the new offset</param>
        /// <param name="useBytes">set to true if the offset is in bytes</param>
        abstract updateDirectly: data: DataArray * offset: float * ?useBytes: bool -> unit
        /// Disposes the VertexBuffer and the underlying WebGLBuffer.
        abstract dispose: unit -> unit
        /// <summary>Enumerates each value of this vertex buffer as numbers.</summary>
        /// <param name="count">the number of values to enumerate</param>
        /// <param name="callback">the callback function called for each value</param>
        abstract forEach: count: float * callback: (float -> float -> unit) -> unit
        abstract _PositionKind: obj with get, set
        abstract _NormalKind: obj with get, set
        abstract _TangentKind: obj with get, set
        abstract _UVKind: obj with get, set
        abstract _UV2Kind: obj with get, set
        abstract _UV3Kind: obj with get, set
        abstract _UV4Kind: obj with get, set
        abstract _UV5Kind: obj with get, set
        abstract _UV6Kind: obj with get, set
        abstract _ColorKind: obj with get, set
        abstract _MatricesIndicesKind: obj with get, set
        abstract _MatricesWeightsKind: obj with get, set
        abstract _MatricesIndicesExtraKind: obj with get, set
        abstract _MatricesWeightsExtraKind: obj with get, set
        abstract PositionKind: string
        abstract NormalKind: string
        abstract TangentKind: string
        abstract UVKind: string
        abstract UV2Kind: string
        abstract UV3Kind: string
        abstract UV4Kind: string
        abstract UV5Kind: string
        abstract UV6Kind: string
        abstract ColorKind: string
        abstract MatricesIndicesKind: string
        abstract MatricesWeightsKind: string
        abstract MatricesIndicesExtraKind: string
        abstract MatricesWeightsExtraKind: string

    type [<AllowNullLiteral>] VertexBufferStatic =
        /// <summary>Constructor</summary>
        /// <param name="engine">the engine</param>
        /// <param name="data">the data to use for this vertex buffer</param>
        /// <param name="kind">the vertex buffer kind</param>
        /// <param name="updatable">whether the data is updatable</param>
        /// <param name="postponeInternalCreation">whether to postpone creating the internal WebGL buffer (optional)</param>
        /// <param name="stride">the stride (optional)</param>
        /// <param name="instanced">whether the buffer is instanced (optional)</param>
        /// <param name="offset">the offset of the data (optional)</param>
        /// <param name="size">the number of components (optional)</param>
        /// <param name="type">the type of the component (optional)</param>
        /// <param name="normalized">whether the data contains normalized data (optional)</param>
        /// <param name="useBytes">set to true if stride and offset are in bytes (optional)</param>
        [<Emit "new $0($1...)">] abstract Create: engine: obj option * data: U2<DataArray, Buffer> * kind: string * updatable: bool * ?postponeInternalCreation: bool * ?stride: float * ?instanced: bool * ?offset: float * ?size: float * ?``type``: float * ?normalized: bool * ?useBytes: bool -> VertexBuffer
        /// <summary>Deduces the stride given a kind.</summary>
        /// <param name="kind">The kind string to deduce</param>
        abstract DeduceStride: kind: string -> float
        /// <summary>Gets the byte length of the given type.</summary>
        /// <param name="type">the type</param>
        abstract GetTypeByteLength: ``type``: float -> float
        /// <summary>Enumerates each value of the given parameters as numbers.</summary>
        /// <param name="data">the data to enumerate</param>
        /// <param name="byteOffset">the byte offset of the data</param>
        /// <param name="byteStride">the byte stride of the data</param>
        /// <param name="componentCount">the number of components per element</param>
        /// <param name="componentType">the type of the component</param>
        /// <param name="count">the total number of components</param>
        /// <param name="normalized">whether the data is normalized</param>
        /// <param name="callback">the callback function called for each value</param>
        abstract ForEach: data: DataArray * byteOffset: float * byteStride: float * componentCount: float * componentType: float * count: float * normalized: bool * callback: (float -> float -> unit) -> unit
        abstract _GetFloatValue: dataView: obj * ``type``: obj * byteOffset: obj * normalized: obj -> unit

    type [<AllowNullLiteral>] ReflectionProbe =
        abstract name: string with get, set
        abstract _scene: obj with get, set
        abstract _renderTargetTexture: obj with get, set
        abstract _projectionMatrix: obj with get, set
        abstract _viewMatrix: obj with get, set
        abstract _target: obj with get, set
        abstract _add: obj with get, set
        abstract _attachedMesh: obj with get, set
        abstract _invertYAxis: obj with get, set
        abstract position: Vector3 with get, set
        abstract samples: float with get, set
        abstract refreshRate: float with get, set
        abstract getScene: unit -> Scene
        abstract cubeTexture: RenderTargetTexture
        abstract renderList: Nullable<ResizeArray<AbstractMesh>>
        abstract attachToMesh: mesh: AbstractMesh -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] ReflectionProbeStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * size: float * scene: Scene * ?generateMipMaps: bool -> ReflectionProbe

    type [<AllowNullLiteral>] BoundingBoxRenderer =
        abstract frontColor: Color3 with get, set
        abstract backColor: Color3 with get, set
        abstract showBackLines: bool with get, set
        abstract renderList: SmartArray<BoundingBox> with get, set
        abstract _scene: obj with get, set
        abstract _colorShader: obj with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _prepareRessources: unit -> unit
        abstract _createIndexBuffer: unit -> unit
        abstract _rebuild: unit -> unit
        abstract reset: unit -> unit
        abstract render: unit -> unit
        abstract renderOcclusionBoundingBox: mesh: AbstractMesh -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] BoundingBoxRendererStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> BoundingBoxRenderer

    /// This represents a depth renderer in Babylon.
    /// A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
    type [<AllowNullLiteral>] DepthRenderer =
        abstract _scene: obj with get, set
        abstract _depthMap: obj with get, set
        abstract _effect: obj with get, set
        abstract _cachedDefines: obj with get, set
        abstract _camera: obj with get, set
        /// <summary>Creates the depth rendering effect and checks if the effect is ready.</summary>
        /// <param name="subMesh">The submesh to be used to render the depth map of</param>
        /// <param name="useInstances">If multiple world instances should be used</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Gets the texture which the depth map will be written to.
        abstract getDepthMap: unit -> RenderTargetTexture
        /// Disposes of the depth renderer.
        abstract dispose: unit -> unit

    /// This represents a depth renderer in Babylon.
    /// A depth renderer will render to it's depth map every frame which can be displayed or used in post processing
    type [<AllowNullLiteral>] DepthRendererStatic =
        /// <summary>Instantiates a depth renderer</summary>
        /// <param name="scene">The scene the renderer belongs to</param>
        /// <param name="type">The texture type of the depth map (default: Engine.TEXTURETYPE_FLOAT)</param>
        /// <param name="camera">The camera to be used to render the depth map (default: scene's active camera)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?``type``: float * ?camera: Nullable<Camera> -> DepthRenderer

    type [<AllowNullLiteral>] EdgesRenderer =
        abstract edgesWidthScalerForOrthographic: float with get, set
        abstract edgesWidthScalerForPerspective: float with get, set
        abstract _source: obj with get, set
        abstract _linesPositions: obj with get, set
        abstract _linesNormals: obj with get, set
        abstract _linesIndices: obj with get, set
        abstract _epsilon: obj with get, set
        abstract _indicesCount: obj with get, set
        abstract _lineShader: obj with get, set
        abstract _ib: obj with get, set
        abstract _buffers: obj with get, set
        abstract _checkVerticesInsteadOfIndices: obj with get, set
        abstract _prepareRessources: unit -> unit
        abstract _rebuild: unit -> unit
        abstract dispose: unit -> unit
        abstract _processEdgeForAdjacencies: pa: obj * pb: obj * p0: obj * p1: obj * p2: obj -> unit
        abstract _processEdgeForAdjacenciesWithVertices: pa: obj * pb: obj * p0: obj * p1: obj * p2: obj -> unit
        abstract _checkEdge: faceIndex: obj * edge: obj * faceNormals: obj * p0: obj * p1: obj -> unit
        abstract _generateEdgesLines: unit -> unit
        abstract render: unit -> unit

    type [<AllowNullLiteral>] EdgesRendererStatic =
        [<Emit "new $0($1...)">] abstract Create: source: AbstractMesh * ?epsilon: float * ?checkVerticesInsteadOfIndices: bool -> EdgesRenderer

    /// This renderer is helpfull to fill one of the render target with a geometry buffer.
    type [<AllowNullLiteral>] GeometryBufferRenderer =
        abstract _scene: obj with get, set
        abstract _multiRenderTarget: obj with get, set
        abstract _ratio: obj with get, set
        abstract _enablePosition: obj with get, set
        abstract _effect: Effect with get, set
        abstract _cachedDefines: string with get, set
        /// Set the render list (meshes to be rendered) used in the G buffer.
        abstract renderList: ResizeArray<Mesh> with get, set
        /// Gets wether or not G buffer are supported by the running hardware.
        /// This requires draw buffer supports
        abstract isSupported: bool
        /// Gets wether or not position are enabled for the G buffer.
        /// Sets wether or not position are enabled for the G buffer.
        abstract enablePosition: bool with get, set
        /// Gets the scene associated with the buffer.
        abstract scene: Scene
        /// Gets the ratio used by the buffer during its creation.
        /// How big is the buffer related to the main canvas.
        abstract ratio: float
        /// <summary>Checks wether everything is ready to render a submesh to the G buffer.</summary>
        /// <param name="subMesh">the submesh to check readiness for</param>
        /// <param name="useInstances">is the mesh drawn using instance or not</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// Gets the current underlying G Buffer.
        abstract getGBuffer: unit -> MultiRenderTarget
        /// Gets the number of samples used to render the buffer (anti aliasing).
        /// Sets the number of samples used to render the buffer (anti aliasing).
        abstract samples: float with get, set
        /// Disposes the renderer and frees up associated resources.
        abstract dispose: unit -> unit
        abstract _createRenderTargets: unit -> unit

    /// This renderer is helpfull to fill one of the render target with a geometry buffer.
    type [<AllowNullLiteral>] GeometryBufferRendererStatic =
        /// <summary>Creates a new G Buffer for the scene</summary>
        /// <param name="scene">The scene the buffer belongs to</param>
        /// <param name="ratio">How big is the buffer related to the main canvas.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?ratio: float -> GeometryBufferRenderer

    type [<AllowNullLiteral>] OutlineRenderer =
        abstract _scene: obj with get, set
        abstract _effect: obj with get, set
        abstract _cachedDefines: obj with get, set
        abstract zOffset: float with get, set
        abstract render: subMesh: SubMesh * batch: _InstancesBatch * ?useOverlay: bool -> unit
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool

    type [<AllowNullLiteral>] OutlineRendererStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> OutlineRenderer

    type [<AllowNullLiteral>] RenderingGroup =
        abstract index: float with get, set
        abstract _scene: obj with get, set
        abstract _opaqueSubMeshes: obj with get, set
        abstract _transparentSubMeshes: obj with get, set
        abstract _alphaTestSubMeshes: obj with get, set
        abstract _depthOnlySubMeshes: obj with get, set
        abstract _particleSystems: obj with get, set
        abstract _spriteManagers: obj with get, set
        abstract _opaqueSortCompareFn: obj with get, set
        abstract _alphaTestSortCompareFn: obj with get, set
        abstract _transparentSortCompareFn: obj with get, set
        abstract _renderOpaque: obj with get, set
        abstract _renderAlphaTest: obj with get, set
        abstract _renderTransparent: obj with get, set
        abstract _edgesRenderers: obj with get, set
        abstract onBeforeTransparentRendering: (unit -> unit) with get, set
        /// Set the opaque sort comparison function.
        /// If null the sub meshes will be render in the order they were created
        abstract opaqueSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> with get, set
        /// Set the alpha test sort comparison function.
        /// If null the sub meshes will be render in the order they were created
        abstract alphaTestSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> with get, set
        /// Set the transparent sort comparison function.
        /// If null the sub meshes will be render in the order they were created
        abstract transparentSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> with get, set
        /// <summary>Render all the sub meshes contained in the group.</summary>
        /// <param name="customRenderFunction">Used to override the default render behaviour of the group.</param>
        abstract render: customRenderFunction: Nullable<(SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> unit)> * renderSprites: bool * renderParticles: bool * activeMeshes: Nullable<ResizeArray<AbstractMesh>> -> unit
        /// <summary>Renders the opaque submeshes in the order from the opaqueSortCompareFn.</summary>
        /// <param name="subMeshes">The submeshes to render</param>
        abstract renderOpaqueSorted: subMeshes: obj -> unit
        /// <summary>Renders the opaque submeshes in the order from the alphatestSortCompareFn.</summary>
        /// <param name="subMeshes">The submeshes to render</param>
        abstract renderAlphaTestSorted: subMeshes: obj -> unit
        /// <summary>Renders the opaque submeshes in the order from the transparentSortCompareFn.</summary>
        /// <param name="subMeshes">The submeshes to render</param>
        abstract renderTransparentSorted: subMeshes: obj -> unit
        /// Resets the different lists of submeshes to prepare a new frame.
        abstract prepare: unit -> unit
        abstract dispose: unit -> unit
        /// <summary>Inserts the submesh in its correct queue depending on its material.</summary>
        /// <param name="subMesh">The submesh to dispatch</param>
        /// <param name="mesh">Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.</param>
        /// <param name="material">Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.</param>
        abstract dispatch: subMesh: SubMesh * ?mesh: AbstractMesh * ?material: Nullable<Material> -> unit
        abstract dispatchSprites: spriteManager: SpriteManager -> unit
        abstract dispatchParticles: particleSystem: IParticleSystem -> unit
        abstract _renderParticles: activeMeshes: obj -> unit
        abstract _renderSprites: unit -> unit

    type [<AllowNullLiteral>] RenderingGroupStatic =
        /// <summary>Creates a new rendering group.</summary>
        /// <param name="index">The rendering group index</param>
        /// <param name="opaqueSortCompareFn">The opaque sort comparison function. If null no order is applied</param>
        /// <param name="alphaTestSortCompareFn">The alpha test sort comparison function. If null no order is applied</param>
        /// <param name="transparentSortCompareFn">The transparent sort comparison function. If null back to front + alpha index sort is applied</param>
        [<Emit "new $0($1...)">] abstract Create: index: float * scene: Scene * ?opaqueSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?alphaTestSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?transparentSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> -> RenderingGroup
        /// <summary>Renders the submeshes in a specified order.</summary>
        /// <param name="subMeshes">The submeshes to sort before render</param>
        /// <param name="sortCompareFn">The comparison function use to sort</param>
        /// <param name="transparent">Specifies to activate blending if true</param>
        abstract renderSorted: subMeshes: obj * sortCompareFn: obj * camera: obj * transparent: obj -> unit
        /// <summary>Renders the submeshes in the order they were dispatched (no sort applied).</summary>
        /// <param name="subMeshes">The submeshes to render</param>
        abstract renderUnsorted: subMeshes: obj -> unit
        /// <summary>Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
        /// are rendered back to front if in the same alpha index.</summary>
        /// <param name="a">The first submesh</param>
        /// <param name="b">The second submesh</param>
        abstract defaultTransparentSortCompare: a: SubMesh * b: SubMesh -> float
        /// <summary>Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
        /// are rendered back to front.</summary>
        /// <param name="a">The first submesh</param>
        /// <param name="b">The second submesh</param>
        abstract backToFrontSortCompare: a: SubMesh * b: SubMesh -> float
        /// <summary>Build in function which can be applied to ensure meshes of a special queue (opaque, alpha test, transparent)
        /// are rendered front to back (prevent overdraw).</summary>
        /// <param name="a">The first submesh</param>
        /// <param name="b">The second submesh</param>
        abstract frontToBackSortCompare: a: SubMesh * b: SubMesh -> float

    type [<AllowNullLiteral>] RenderingManager =
        /// The max id used for rendering groups (not included)
        abstract MAX_RENDERINGGROUPS: float with get, set
        /// The min id used for rendering groups (included)
        abstract MIN_RENDERINGGROUPS: float with get, set
        /// Used to globally prevent autoclearing scenes.
        abstract AUTOCLEAR: bool with get, set
        abstract _scene: obj with get, set
        abstract _renderingGroups: obj with get, set
        abstract _depthStencilBufferAlreadyCleaned: obj with get, set
        abstract _autoClearDepthStencil: obj with get, set
        abstract _customOpaqueSortCompareFn: obj with get, set
        abstract _customAlphaTestSortCompareFn: obj with get, set
        abstract _customTransparentSortCompareFn: obj with get, set
        abstract _renderinGroupInfo: obj with get, set
        abstract _clearDepthStencilBuffer: ?depth: obj * ?stencil: obj -> unit
        abstract render: customRenderFunction: Nullable<(SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> unit)> * activeMeshes: Nullable<ResizeArray<AbstractMesh>> * renderParticles: bool * renderSprites: bool -> unit
        abstract reset: unit -> unit
        abstract dispose: unit -> unit
        /// Clear the info related to rendering groups preventing retention points during dispose.
        abstract freeRenderingGroups: unit -> unit
        abstract _prepareRenderingGroup: renderingGroupId: obj -> unit
        abstract dispatchSprites: spriteManager: SpriteManager -> unit
        abstract dispatchParticles: particleSystem: IParticleSystem -> unit
        /// <param name="subMesh">The submesh to dispatch</param>
        /// <param name="mesh">Optional reference to the submeshes's mesh. Provide if you have an exiting reference to improve performance.</param>
        /// <param name="material">Optional reference to the submeshes's material. Provide if you have an exiting reference to improve performance.</param>
        abstract dispatch: subMesh: SubMesh * ?mesh: AbstractMesh * ?material: Nullable<Material> -> unit
        /// <summary>Overrides the default sort function applied in the renderging group to prepare the meshes.
        /// This allowed control for front to back rendering or reversly depending of the special needs.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="opaqueSortCompareFn">The opaque queue comparison function use to sort.</param>
        /// <param name="alphaTestSortCompareFn">The alpha test queue comparison function use to sort.</param>
        /// <param name="transparentSortCompareFn">The transparent queue comparison function use to sort.</param>
        abstract setRenderingOrder: renderingGroupId: float * ?opaqueSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?alphaTestSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?transparentSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        /// <param name="depth">Automatically clears depth between groups if true and autoClear is true.</param>
        /// <param name="stencil">Automatically clears stencil between groups if true and autoClear is true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool * ?depth: bool * ?stencil: bool -> unit

    type [<AllowNullLiteral>] RenderingManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> RenderingManager

    type [<AllowNullLiteral>] Sprite =
        abstract name: string with get, set
        abstract position: Vector3 with get, set
        abstract color: Color4 with get, set
        abstract width: float with get, set
        abstract height: float with get, set
        abstract angle: float with get, set
        abstract cellIndex: float with get, set
        abstract invertU: float with get, set
        abstract invertV: float with get, set
        abstract disposeWhenFinishedAnimating: bool with get, set
        abstract animations: ResizeArray<Animation> with get, set
        abstract isPickable: bool with get, set
        abstract actionManager: ActionManager with get, set
        abstract _animationStarted: obj with get, set
        abstract _loopAnimation: obj with get, set
        abstract _fromIndex: obj with get, set
        abstract _toIndex: obj with get, set
        abstract _delay: obj with get, set
        abstract _direction: obj with get, set
        abstract _manager: obj with get, set
        abstract _time: obj with get, set
        abstract _onAnimationEnd: obj with get, set
        abstract size: float with get, set
        abstract playAnimation: from: float * ``to``: float * loop: bool * delay: float * onAnimationEnd: (unit -> unit) -> unit
        abstract stopAnimation: unit -> unit
        abstract _animate: deltaTime: float -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] SpriteStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * manager: SpriteManager -> Sprite

    type [<AllowNullLiteral>] SpriteManager =
        abstract name: string with get, set
        abstract sprites: ResizeArray<Sprite> with get, set
        abstract renderingGroupId: float with get, set
        abstract layerMask: float with get, set
        abstract fogEnabled: bool with get, set
        abstract isPickable: bool with get, set
        abstract cellWidth: float with get, set
        abstract cellHeight: float with get, set
        /// An event triggered when the manager is disposed.
        abstract onDisposeObservable: Observable<SpriteManager> with get, set
        abstract _onDisposeObserver: obj with get, set
        abstract onDispose: (unit -> unit) with get, set
        abstract _capacity: obj with get, set
        abstract _spriteTexture: obj with get, set
        abstract _epsilon: obj with get, set
        abstract _scene: obj with get, set
        abstract _vertexData: obj with get, set
        abstract _buffer: obj with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _effectBase: obj with get, set
        abstract _effectFog: obj with get, set
        abstract texture: Texture with get, set
        abstract _appendSpriteVertex: index: obj * sprite: obj * offsetX: obj * offsetY: obj * rowSize: obj -> unit
        abstract intersects: ray: Ray * camera: Camera * ?predicate: (Sprite -> bool) * ?fastCheck: bool -> Nullable<PickingInfo>
        abstract render: unit -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] SpriteManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * imgUrl: string * capacity: float * cellSize: obj option * scene: Scene * ?epsilon: float * ?samplingMode: float -> SpriteManager

    type [<AllowNullLiteral>] _AlphaState =
        abstract _isAlphaBlendDirty: obj with get, set
        abstract _isBlendFunctionParametersDirty: obj with get, set
        abstract _isBlendEquationParametersDirty: obj with get, set
        abstract _isBlendConstantsDirty: obj with get, set
        abstract _alphaBlend: obj with get, set
        abstract _blendFunctionParameters: obj with get, set
        abstract _blendEquationParameters: obj with get, set
        abstract _blendConstants: obj with get, set
        abstract isDirty: bool
        abstract alphaBlend: bool with get, set
        abstract setAlphaBlendConstants: r: float * g: float * b: float * a: float -> unit
        abstract setAlphaBlendFunctionParameters: value0: float * value1: float * value2: float * value3: float -> unit
        abstract setAlphaEquationParameters: rgb: float * alpha: float -> unit
        abstract reset: unit -> unit
        abstract apply: gl: WebGLRenderingContext -> unit

    type [<AllowNullLiteral>] _AlphaStateStatic =
        /// Initializes the state.
        [<Emit "new $0($1...)">] abstract Create: unit -> _AlphaState

    type [<AllowNullLiteral>] _DepthCullingState =
        abstract _isDepthTestDirty: obj with get, set
        abstract _isDepthMaskDirty: obj with get, set
        abstract _isDepthFuncDirty: obj with get, set
        abstract _isCullFaceDirty: obj with get, set
        abstract _isCullDirty: obj with get, set
        abstract _isZOffsetDirty: obj with get, set
        abstract _isFrontFaceDirty: obj with get, set
        abstract _depthTest: obj with get, set
        abstract _depthMask: obj with get, set
        abstract _depthFunc: obj with get, set
        abstract _cull: obj with get, set
        abstract _cullFace: obj with get, set
        abstract _zOffset: obj with get, set
        abstract _frontFace: obj with get, set
        abstract isDirty: bool
        abstract zOffset: float with get, set
        abstract cullFace: Nullable<float> with get, set
        abstract cull: Nullable<bool> with get, set
        abstract depthFunc: Nullable<float> with get, set
        abstract depthMask: bool with get, set
        abstract depthTest: bool with get, set
        abstract frontFace: Nullable<float> with get, set
        abstract reset: unit -> unit
        abstract apply: gl: WebGLRenderingContext -> unit

    type [<AllowNullLiteral>] _DepthCullingStateStatic =
        /// Initializes the state.
        [<Emit "new $0($1...)">] abstract Create: unit -> _DepthCullingState

    type [<AllowNullLiteral>] _StencilState =
        abstract _isStencilTestDirty: obj with get, set
        abstract _isStencilMaskDirty: obj with get, set
        abstract _isStencilFuncDirty: obj with get, set
        abstract _isStencilOpDirty: obj with get, set
        abstract _stencilTest: obj with get, set
        abstract _stencilMask: obj with get, set
        abstract _stencilFunc: obj with get, set
        abstract _stencilFuncRef: obj with get, set
        abstract _stencilFuncMask: obj with get, set
        abstract _stencilOpStencilFail: obj with get, set
        abstract _stencilOpDepthFail: obj with get, set
        abstract _stencilOpStencilDepthPass: obj with get, set
        abstract isDirty: bool
        abstract stencilFunc: float with get, set
        abstract stencilFuncRef: float with get, set
        abstract stencilFuncMask: float with get, set
        abstract stencilOpStencilFail: float with get, set
        abstract stencilOpDepthFail: float with get, set
        abstract stencilOpStencilDepthPass: float with get, set
        abstract stencilMask: float with get, set
        abstract stencilTest: bool with get, set
        abstract reset: unit -> unit
        abstract apply: gl: WebGLRenderingContext -> unit

    type [<AllowNullLiteral>] _StencilStateStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> _StencilState

    type [<AllowNullLiteral>] AnaglyphPostProcess =
        inherit PostProcess
        abstract _passedProcess: obj with get, set

    type [<AllowNullLiteral>] AnaglyphPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * rigCameras: ResizeArray<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> AnaglyphPostProcess

    type [<AllowNullLiteral>] BlackAndWhitePostProcess =
        inherit PostProcess
        abstract degree: float with get, set

    type [<AllowNullLiteral>] BlackAndWhitePostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> BlackAndWhitePostProcess

    /// The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
    type [<AllowNullLiteral>] BloomEffect =
        inherit PostProcessRenderEffect
        abstract bloomScale: obj with get, set
        /// Internal
        abstract _effects: Array<PostProcess> with get, set
        /// Internal
        abstract _downscale: ExtractHighlightsPostProcess with get, set
        abstract _blurX: obj with get, set
        abstract _blurY: obj with get, set
        abstract _merge: obj with get, set
        /// The luminance threshold to find bright areas of the image to bloom.
        abstract threshold: float with get, set
        /// The strength of the bloom.
        abstract weight: float with get, set
        /// Specifies the size of the bloom blur kernel, relative to the final output size
        abstract kernel: float with get, set
        /// <summary>Disposes each of the internal effects for a given camera.</summary>
        /// <param name="camera">The camera to dispose the effect on.</param>
        abstract disposeEffects: camera: Camera -> unit
        /// Internal
        abstract _updateEffects: unit -> unit
        /// Internal
        abstract _isReady: unit -> bool

    /// The bloom effect spreads bright areas of an image to simulate artifacts seen in cameras
    type [<AllowNullLiteral>] BloomEffectStatic =
        /// <summary>Creates a new instance of @see BloomEffect</summary>
        /// <param name="scene">The scene the effect belongs to.</param>
        /// <param name="bloomScale">The ratio of the blur texture to the input texture that should be used to compute the bloom.</param>
        /// <param name="bloomWeight">The the strength of bloom.</param>
        /// <param name="bloomKernel">The size of the kernel to be used when applying the blur.</param>
        /// <param name="pipelineTextureType">The type of texture to be used when performing the post processing.</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * bloomScale: float * bloomWeight: float * bloomKernel: float * ?pipelineTextureType: float * ?blockCompilation: bool -> BloomEffect

    /// The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] BloomMergePostProcess =
        inherit PostProcess
        /// Weight of the bloom to be added to the original input. 
        abstract weight: float with get, set

    /// The BloomMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] BloomMergePostProcessStatic =
        /// <summary>Creates a new instance of @see BloomMergePostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="originalFromInput">Post process which's input will be used for the merge.</param>
        /// <param name="blurred">Blurred highlights post process which's output will be used.</param>
        /// <param name="weight">Weight of the bloom to be added to the original input.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * originalFromInput: PostProcess * blurred: PostProcess * weight: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> BloomMergePostProcess

    /// The Blur Post Process which blurs an image based on a kernel and direction.
    /// Can be used twice in x and y directions to perform a guassian blur in two passes.
    type [<AllowNullLiteral>] BlurPostProcess =
        inherit PostProcess
        /// The direction in which to blur the image. 
        abstract direction: Vector2 with get, set
        abstract blockCompilation: obj with get, set
        abstract _kernel: float with get, set
        abstract _idealKernel: float with get, set
        abstract _packedFloat: bool with get, set
        abstract _staticDefines: obj with get, set
        /// Gets the length in pixels of the blur sample region
        /// Sets the length in pixels of the blur sample region
        abstract kernel: float with get, set
        /// Gets wether or not the blur is unpacking/repacking floats
        /// Sets wether or not the blur needs to unpack/repack floats
        abstract packedFloat: bool with get, set
        /// <summary>Updates the effect with the current post process compile time values and recompiles the shader.</summary>
        /// <param name="defines">Define statements that should be added at the beginning of the shader. (default: null)</param>
        /// <param name="uniforms">Set of uniform variables that will be passed to the shader. (default: null)</param>
        /// <param name="samplers">Set of Texture2D variables that will be passed to the shader. (default: null)</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="onCompiled">Called when the shader has been compiled.</param>
        /// <param name="onError">Called if there is an error when compiling a shader.</param>
        abstract updateEffect: ?defines: Nullable<string> * ?uniforms: Nullable<ResizeArray<string>> * ?samplers: Nullable<ResizeArray<string>> * ?indexParameters: obj option * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit
        abstract _updateParameters: ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit
        /// <summary>Best kernels are odd numbers that when divided by 2, their integer part is even, so 5, 9 or 13.
        /// Other odd kernels optimize correctly but require proportionally more samples, even kernels are
        /// possible but will produce minor visual artifacts. Since each new kernel requires a new shader we
        /// want to minimize kernel changes, having gaps between physical kernels is helpful in that regard.
        /// The gaps between physical kernels are compensated for in the weighting of the samples</summary>
        /// <param name="idealKernel">Ideal blur kernel.</param>
        abstract _nearestBestKernel: idealKernel: float -> float
        /// <summary>Calculates the value of a Gaussian distribution with sigma 3 at a given point.</summary>
        /// <param name="x">The point on the Gaussian distribution to sample.</param>
        abstract _gaussianWeight: x: float -> float
        /// <summary>Generates a string that can be used as a floating point number in GLSL.</summary>
        /// <param name="x">Value to print.</param>
        /// <param name="decimalFigures">Number of decimal places to print the number to (excluding trailing 0s).</param>
        abstract _glslFloat: x: float * ?decimalFigures: float -> string

    /// The Blur Post Process which blurs an image based on a kernel and direction.
    /// Can be used twice in x and y directions to perform a guassian blur in two passes.
    type [<AllowNullLiteral>] BlurPostProcessStatic =
        /// <summary>Creates a new instance BlurPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="direction">The direction in which to blur the image.</param>
        /// <param name="kernel">The size of the kernel to be used when computing the blur. eg. Size of 3 will blur the center pixel by 2 pixels surrounding it.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * direction: Vector2 * kernel: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?defines: string * ?blockCompilation: bool -> BlurPostProcess

    /// The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
    type [<AllowNullLiteral>] ChromaticAberrationPostProcess =
        inherit PostProcess
        /// The amount of seperation of rgb channels (default: 30)
        abstract aberrationAmount: float with get, set
        /// The amount the effect will increase for pixels closer to the edge of the screen. (default: 0)
        abstract radialIntensity: float with get, set
        /// The normilized direction in which the rgb channels should be seperated. If set to 0,0 radial direction will be used. (default: Vector2(0.707,0.707))
        abstract direction: Vector2 with get, set
        /// The center position where the radialIntensity should be around. [0.5,0.5 is center of screen, 1,1 is top right corder] (default: Vector2(0.5 ,0.5))
        abstract centerPosition: Vector2 with get, set

    /// The ChromaticAberrationPostProcess separates the rgb channels in an image to produce chromatic distortion around the edges of the screen
    type [<AllowNullLiteral>] ChromaticAberrationPostProcessStatic =
        /// <summary>Creates a new instance ChromaticAberrationPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="screenWidth">The width of the screen to apply the effect on.</param>
        /// <param name="screenHeight">The height of the screen to apply the effect on.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * screenWidth: float * screenHeight: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> ChromaticAberrationPostProcess

    /// The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
    type [<AllowNullLiteral>] CircleOfConfusionPostProcess =
        inherit PostProcess
        /// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
        abstract lensSize: float with get, set
        /// F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
        abstract fStop: float with get, set
        /// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
        abstract focusDistance: float with get, set
        /// Focal length of the effect's camera in scene units/1000 (eg. millimeter). (default: 50)
        abstract focalLength: float with get, set
        abstract _depthTexture: obj with get, set
        /// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
        abstract depthTexture: RenderTargetTexture with get, set

    /// The CircleOfConfusionPostProcess computes the circle of confusion value for each pixel given required lens parameters. See https://en.wikipedia.org/wiki/Circle_of_confusion
    type [<AllowNullLiteral>] CircleOfConfusionPostProcessStatic =
        /// <summary>Creates a new instance CircleOfConfusionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="depthTexture">The depth texture of the scene to compute the circle of confusion. This must be set in order for this to function but may be set after initialization if needed.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * depthTexture: Nullable<RenderTargetTexture> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> CircleOfConfusionPostProcess

    type [<AllowNullLiteral>] ColorCorrectionPostProcess =
        inherit PostProcess
        abstract _colorTableTexture: obj with get, set

    type [<AllowNullLiteral>] ColorCorrectionPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * colorTableUrl: string * options: U2<float, PostProcessOptions> * camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> ColorCorrectionPostProcess

    /// The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
    /// input texture to perform effects such as edge detection or sharpening
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] ConvolutionPostProcess =
        inherit PostProcess
        /// Array of 9 values corrisponding to the 3x3 kernel to be applied 
        abstract kernel: ResizeArray<float> with get, set
        /// Edge detection 0 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EdgeDetect0Kernel: ResizeArray<float> with get, set
        /// Edge detection 1 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EdgeDetect1Kernel: ResizeArray<float> with get, set
        /// Edge detection 2 see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EdgeDetect2Kernel: ResizeArray<float> with get, set
        /// Kernel to sharpen an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract SharpenKernel: ResizeArray<float> with get, set
        /// Kernel to emboss an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract EmbossKernel: ResizeArray<float> with get, set
        /// Kernel to blur an image see https://en.wikipedia.org/wiki/Kernel_(image_processing)
        abstract GaussianKernel: ResizeArray<float> with get, set

    /// The ConvolutionPostProcess applies a 3x3 kernel to every pixel of the
    /// input texture to perform effects such as edge detection or sharpening
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] ConvolutionPostProcessStatic =
        /// <summary>Creates a new instance ConvolutionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="kernel">Array of 9 values corrisponding to the 3x3 kernel to be applied</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * kernel: ResizeArray<float> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float -> ConvolutionPostProcess

    /// The DepthOfFieldBlurPostProcess applied a blur in a give direction.
    /// This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
    /// based on samples that have a large difference in distance than the center pixel.
    /// See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
    type [<AllowNullLiteral>] DepthOfFieldBlurPostProcess =
        inherit BlurPostProcess
        abstract direction: Vector2 with get, set

    /// The DepthOfFieldBlurPostProcess applied a blur in a give direction.
    /// This blur differs from the standard BlurPostProcess as it attempts to avoid blurring pixels
    /// based on samples that have a large difference in distance than the center pixel.
    /// See section 2.6.2 http://fileadmin.cs.lth.se/cs/education/edan35/lectures/12dof.pdf
    type [<AllowNullLiteral>] DepthOfFieldBlurPostProcessStatic =
        /// <summary>Creates a new instance CircleOfConfusionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="scene">The scene the effect belongs to.</param>
        /// <param name="direction">The direction the blur should be applied.</param>
        /// <param name="kernel">The size of the kernel used to blur.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="circleOfConfusion">The circle of confusion + depth map to be used to avoid blurring accross edges</param>
        /// <param name="imageToBlur">The image to apply the blur to (default: Current rendered frame)</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * direction: Vector2 * kernel: float * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * circleOfConfusion: PostProcess * ?imageToBlur: Nullable<PostProcess> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> DepthOfFieldBlurPostProcess

    type [<RequireQualifiedAccess>] DepthOfFieldEffectBlurLevel =
        | Low = 0
        | Medium = 1
        | High = 2

    /// The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
    type [<AllowNullLiteral>] DepthOfFieldEffect =
        inherit PostProcessRenderEffect
        abstract _circleOfConfusion: obj with get, set
        /// Internal, blurs from high to low
        abstract _depthOfFieldBlurX: Array<DepthOfFieldBlurPostProcess> with get, set
        abstract _depthOfFieldBlurY: obj with get, set
        abstract _dofMerge: obj with get, set
        /// Internal post processes in depth of field effect
        abstract _effects: Array<PostProcess> with get, set
        /// The focal the length of the camera used in the effect in scene units/1000 (eg. millimeter)
        abstract focalLength: float with get, set
        /// F-Stop of the effect's camera. The diamater of the resulting aperture can be computed by lensSize/fStop. (default: 1.4)
        abstract fStop: float with get, set
        /// Distance away from the camera to focus on in scene units/1000 (eg. millimeter). (default: 2000)
        abstract focusDistance: float with get, set
        /// Max lens size in scene units/1000 (eg. millimeter). Standard cameras are 50mm. (default: 50) The diamater of the resulting aperture can be computed by lensSize/fStop.
        abstract lensSize: float with get, set
        /// Depth texture to be used to compute the circle of confusion. This must be set here or in the constructor in order for the post process to function.
        abstract depthTexture: RenderTargetTexture with get, set
        /// <summary>Disposes each of the internal effects for a given camera.</summary>
        /// <param name="camera">The camera to dispose the effect on.</param>
        abstract disposeEffects: camera: Camera -> unit
        /// Internal
        abstract _updateEffects: unit -> unit
        /// Internal
        abstract _isReady: unit -> bool

    /// The depth of field effect applies a blur to objects that are closer or further from where the camera is focusing.
    type [<AllowNullLiteral>] DepthOfFieldEffectStatic =
        /// <summary>Creates a new instance DepthOfFieldEffect</summary>
        /// <param name="scene">The scene the effect belongs to.</param>
        /// <param name="depthTexture">The depth texture of the scene to compute the circle of confusion.This must be set in order for this to function but may be set after initialization if needed.</param>
        /// <param name="pipelineTextureType">The type of texture to be used when performing the post processing.</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * depthTexture: Nullable<RenderTargetTexture> * ?blurLevel: DepthOfFieldEffectBlurLevel * ?pipelineTextureType: float * ?blockCompilation: bool -> DepthOfFieldEffect

    /// Options to be set when merging outputs from the default pipeline.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcessOptions =
        /// The original image to merge on top of
        abstract originalFromInput: PostProcess with get, set
        /// Parameters to perform the merge of the depth of field effect
        abstract depthOfField: obj option with get, set
        /// Parameters to perform the merge of bloom effect
        abstract bloom: obj option with get, set

    /// Options to be set when merging outputs from the default pipeline.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcessOptionsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DepthOfFieldMergePostProcessOptions

    /// The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcess =
        inherit PostProcess
        abstract blurSteps: obj with get, set
        /// <summary>Updates the effect with the current post process compile time values and recompiles the shader.</summary>
        /// <param name="defines">Define statements that should be added at the beginning of the shader. (default: null)</param>
        /// <param name="uniforms">Set of uniform variables that will be passed to the shader. (default: null)</param>
        /// <param name="samplers">Set of Texture2D variables that will be passed to the shader. (default: null)</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="onCompiled">Called when the shader has been compiled.</param>
        /// <param name="onError">Called if there is an error when compiling a shader.</param>
        abstract updateEffect: ?defines: Nullable<string> * ?uniforms: Nullable<ResizeArray<string>> * ?samplers: Nullable<ResizeArray<string>> * ?indexParameters: obj option * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit

    /// The DepthOfFieldMergePostProcess merges blurred images with the original based on the values of the circle of confusion.
    type [<AllowNullLiteral>] DepthOfFieldMergePostProcessStatic =
        /// <summary>Creates a new instance of DepthOfFieldMergePostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="originalFromInput">Post process which's input will be used for the merge.</param>
        /// <param name="circleOfConfusion">Circle of confusion post process which's output will be used to blur each pixel.</param>
        /// <param name="blurSteps">Blur post processes from low to high which will be mixed with the original image.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * originalFromInput: PostProcess * circleOfConfusion: PostProcess * blurSteps: Array<PostProcess> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> DepthOfFieldMergePostProcess

    type [<AllowNullLiteral>] DisplayPassPostProcess =
        inherit PostProcess

    type [<AllowNullLiteral>] DisplayPassPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> DisplayPassPostProcess

    /// The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
    type [<AllowNullLiteral>] ExtractHighlightsPostProcess =
        inherit PostProcess
        /// The luminance threshold, pixels below this value will be set to black.
        abstract threshold: float with get, set
        /// Internal
        abstract _exposure: float with get, set
        /// Post process which has the input texture to be used when performing highlight extraction
        abstract _inputPostProcess: Nullable<PostProcess> with get, set

    /// The extract highlights post process sets all pixels to black except pixels above the specified luminance threshold. Used as the first step for a bloom effect.
    type [<AllowNullLiteral>] ExtractHighlightsPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> ExtractHighlightsPostProcess

    type [<AllowNullLiteral>] FilterPostProcess =
        inherit PostProcess
        abstract kernelMatrix: Matrix with get, set

    type [<AllowNullLiteral>] FilterPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * kernelMatrix: Matrix * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> FilterPostProcess

    type [<AllowNullLiteral>] FxaaPostProcess =
        inherit PostProcess
        abstract texelWidth: float with get, set
        abstract texelHeight: float with get, set

    type [<AllowNullLiteral>] FxaaPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * ?camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float -> FxaaPostProcess

    /// The GrainPostProcess adds noise to the image at mid luminance levels
    type [<AllowNullLiteral>] GrainPostProcess =
        inherit PostProcess
        /// The intensity of the grain added (default: 30)
        abstract intensity: float with get, set
        /// If the grain should be randomized on every frame
        abstract animated: bool with get, set

    /// The GrainPostProcess adds noise to the image at mid luminance levels
    type [<AllowNullLiteral>] GrainPostProcessStatic =
        /// <summary>Creates a new instance of @see GrainPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> GrainPostProcess

    type [<AllowNullLiteral>] HighlightsPostProcess =
        inherit PostProcess

    type [<AllowNullLiteral>] HighlightsPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float -> HighlightsPostProcess

    type [<AllowNullLiteral>] ImageProcessingPostProcess =
        inherit PostProcess
        /// Default configuration related to image processing available in the PBR Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Keep track of the image processing observer to allow dispose and replace.
        abstract _imageProcessingObserver: obj with get, set
        /// <summary>Attaches a new image processing configuration to the PBR Material.</summary>
        /// <param name="configuration"></param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> * ?doNotBuild: bool -> unit
        /// Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .
        /// Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .
        abstract colorCurves: Nullable<ColorCurves> with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract colorCurvesEnabled: bool with get, set
        /// Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
        /// Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.
        abstract colorGradingTexture: Nullable<BaseTexture> with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract colorGradingEnabled: bool with get, set
        /// Gets exposure used in the effect.
        /// Sets exposure used in the effect.
        abstract exposure: float with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract toneMappingEnabled: bool with get, set
        /// Gets contrast used in the effect.
        /// Sets contrast used in the effect.
        abstract contrast: float with get, set
        /// Gets Vignette stretch size.
        /// Sets Vignette stretch size.
        abstract vignetteStretch: float with get, set
        /// Gets Vignette centre X Offset.
        /// Sets Vignette centre X Offset.
        abstract vignetteCentreX: float with get, set
        /// Gets Vignette centre Y Offset.
        /// Sets Vignette centre Y Offset.
        abstract vignetteCentreY: float with get, set
        /// Gets Vignette weight or intensity of the vignette effect.
        /// Sets Vignette weight or intensity of the vignette effect.
        abstract vignetteWeight: float with get, set
        /// Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
        /// if vignetteEnabled is set to true.
        /// Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)
        /// if vignetteEnabled is set to true.
        abstract vignetteColor: Color4 with get, set
        /// Gets Camera field of view used by the Vignette effect.
        /// Sets Camera field of view used by the Vignette effect.
        abstract vignetteCameraFov: float with get, set
        /// Gets the vignette blend mode allowing different kind of effect.
        /// Sets the vignette blend mode allowing different kind of effect.
        abstract vignetteBlendMode: float with get, set
        /// Gets wether the vignette effect is enabled.
        /// Sets wether the vignette effect is enabled.
        abstract vignetteEnabled: bool with get, set
        abstract _fromLinearSpace: obj with get, set
        /// Gets wether the input of the processing is in Gamma or Linear Space.
        /// Sets wether the input of the processing is in Gamma or Linear Space.
        abstract fromLinearSpace: bool with get, set
        /// Defines cache preventing GC.
        abstract _defines: obj with get, set
        abstract getClassName: unit -> string
        abstract _updateParameters: unit -> unit
        abstract dispose: ?camera: Camera -> unit

    type [<AllowNullLiteral>] ImageProcessingPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * ?camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?imageProcessingConfiguration: ImageProcessingConfiguration -> ImageProcessingPostProcess

    type [<AllowNullLiteral>] PassPostProcess =
        inherit PostProcess

    type [<AllowNullLiteral>] PassPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * ?camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> PassPostProcess

    type [<AllowNullLiteral>] PostProcessOptions =
        abstract width: float with get, set
        abstract height: float with get, set

    /// PostProcess can be used to apply a shader to a texture after it has been rendered
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcess =
        /// Name of the PostProcess. 
        abstract name: string with get, set
        /// Width of the texture to apply the post process on
        abstract width: float with get, set
        /// Height of the texture to apply the post process on
        abstract height: float with get, set
        /// Internal, reference to the location where this postprocess was output to. (Typically the texture on the next postprocess in the chain)
        abstract _outputTexture: Nullable<InternalTexture> with get, set
        /// Sampling mode used by the shader
        /// See https://doc.babylonjs.com/classes/3.1/texture
        abstract renderTargetSamplingMode: float with get, set
        /// Clear color to use when screen clearing
        abstract clearColor: Color4 with get, set
        /// If the buffer needs to be cleared before applying the post process. (default: true)
        /// Should be set to false if shader will overwrite all previous pixels.
        abstract autoClear: bool with get, set
        /// Type of alpha mode to use when performing the post process (default: Engine.ALPHA_DISABLE)
        abstract alphaMode: float with get, set
        /// Sets the setAlphaBlendConstants of the babylon engine
        abstract alphaConstants: Color4 with get, set
        /// Animations to be used for the post processing
        abstract animations: ResizeArray<Animation> with get, set
        /// Enable Pixel Perfect mode where texture is not scaled to be power of 2.
        /// Can only be used on a single postprocess or on the last one of a chain. (default: false)
        abstract enablePixelPerfectMode: bool with get, set
        /// Scale mode for the post process (default: Engine.SCALEMODE_FLOOR)
        abstract scaleMode: float with get, set
        /// Force textures to be a power of two (default: false)
        abstract alwaysForcePOT: bool with get, set
        /// Number of sample textures (default: 1)
        abstract samples: float with get, set
        /// Modify the scale of the post process to be the same as the viewport (default: false)
        abstract adaptScaleToCurrentViewport: bool with get, set
        abstract _camera: obj with get, set
        abstract _scene: obj with get, set
        abstract _engine: obj with get, set
        abstract _options: obj with get, set
        abstract _reusable: obj with get, set
        abstract _textureType: obj with get, set
        /// Smart array of input and output textures for the post process.
        abstract _textures: SmartArray<InternalTexture> with get, set
        /// The index in _textures that corresponds to the output texture.
        abstract _currentRenderTextureInd: float with get, set
        abstract _effect: obj with get, set
        abstract _samplers: obj with get, set
        abstract _fragmentUrl: obj with get, set
        abstract _vertexUrl: obj with get, set
        abstract _parameters: obj with get, set
        abstract _scaleRatio: obj with get, set
        abstract _indexParameters: obj option with get, set
        abstract _shareOutputWithPostProcess: obj with get, set
        abstract _texelSize: obj with get, set
        abstract _forcedOutputTexture: obj with get, set
        /// An event triggered when the postprocess is activated.
        abstract onActivateObservable: Observable<Camera> with get, set
        abstract _onActivateObserver: obj with get, set
        /// A function that is added to the onActivateObservable
        abstract onActivate: Nullable<(Camera -> unit)> with get, set
        /// An event triggered when the postprocess changes its size.
        abstract onSizeChangedObservable: Observable<PostProcess> with get, set
        abstract _onSizeChangedObserver: obj with get, set
        /// A function that is added to the onSizeChangedObservable
        abstract onSizeChanged: (PostProcess -> unit) with get, set
        /// An event triggered when the postprocess applies its effect.
        abstract onApplyObservable: Observable<Effect> with get, set
        abstract _onApplyObserver: obj with get, set
        /// A function that is added to the onApplyObservable
        abstract onApply: (Effect -> unit) with get, set
        /// An event triggered before rendering the postprocess
        abstract onBeforeRenderObservable: Observable<Effect> with get, set
        abstract _onBeforeRenderObserver: obj with get, set
        /// A function that is added to the onBeforeRenderObservable
        abstract onBeforeRender: (Effect -> unit) with get, set
        /// An event triggered after rendering the postprocess
        abstract onAfterRenderObservable: Observable<Effect> with get, set
        abstract _onAfterRenderObserver: obj with get, set
        /// A function that is added to the onAfterRenderObservable
        abstract onAfterRender: (Effect -> unit) with get, set
        /// The input texture for this post process and the output texture of the previous post process. When added to a pipeline the previous post process will
        /// render it's output into this texture and this texture will be used as textureSampler in the fragment shader of this post process.
        abstract inputTexture: InternalTexture with get, set
        /// Gets the camera which post process is applied to.
        abstract getCamera: unit -> Camera
        /// Gets the texel size of the postprocess.
        /// See https://en.wikipedia.org/wiki/Texel_(graphics)
        abstract texelSize: Vector2
        /// Gets the engine which this post process belongs to.
        abstract getEngine: unit -> Engine
        /// The effect that is created when initializing the post process.
        abstract getEffect: unit -> Effect
        /// <summary>To avoid multiple redundant textures for multiple post process, the output the output texture for this post process can be shared with another.</summary>
        /// <param name="postProcess">The post process to share the output with.</param>
        abstract shareOutputWith: postProcess: PostProcess -> PostProcess
        /// Reverses the effect of calling shareOutputWith and returns the post process back to its original state.
        /// This should be called if the post process that shares output with this post process is disabled/disposed.
        abstract useOwnOutput: unit -> unit
        /// <summary>Updates the effect with the current post process compile time values and recompiles the shader.</summary>
        /// <param name="defines">Define statements that should be added at the beginning of the shader. (default: null)</param>
        /// <param name="uniforms">Set of uniform variables that will be passed to the shader. (default: null)</param>
        /// <param name="samplers">Set of Texture2D variables that will be passed to the shader. (default: null)</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="onCompiled">Called when the shader has been compiled.</param>
        /// <param name="onError">Called if there is an error when compiling a shader.</param>
        abstract updateEffect: ?defines: Nullable<string> * ?uniforms: Nullable<ResizeArray<string>> * ?samplers: Nullable<ResizeArray<string>> * ?indexParameters: obj option * ?onCompiled: (Effect -> unit) * ?onError: (Effect -> string -> unit) -> unit
        /// The post process is reusable if it can be used multiple times within one frame.
        abstract isReusable: unit -> bool
        /// invalidate frameBuffer to hint the postprocess to create a depth buffer 
        abstract markTextureDirty: unit -> unit
        /// <summary>Activates the post process by intializing the textures to be used when executed. Notifies onActivateObservable.
        /// When this post process is used in a pipeline, this is call will bind the input texture of this post process to the output of the previous.</summary>
        /// <param name="camera">The camera that will be used in the post process. This camera will be used when calling onActivateObservable.</param>
        /// <param name="sourceTexture">The source texture to be inspected to get the width and height if not specified in the post process constructor. (default: null)</param>
        /// <param name="forceDepthStencil">If true, a depth and stencil buffer will be generated. (default: false)</param>
        abstract activate: camera: Nullable<Camera> * ?sourceTexture: Nullable<InternalTexture> * ?forceDepthStencil: bool -> InternalTexture
        /// If the post process is supported.
        abstract isSupported: bool
        /// The aspect ratio of the output texture.
        abstract aspectRatio: float
        /// Get a value indicating if the post-process is ready to be used
        abstract isReady: unit -> bool
        /// Binds all textures and uniforms to the shader, this will be run on every pass.
        abstract apply: unit -> Nullable<Effect>
        abstract _disposeTextures: unit -> unit
        /// <summary>Disposes the post process.</summary>
        /// <param name="camera">The camera to dispose the post process on.</param>
        abstract dispose: ?camera: Camera -> unit

    /// PostProcess can be used to apply a shader to a texture after it has been rendered
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcessStatic =
        /// <summary>Creates a new instance PostProcess</summary>
        /// <param name="name">The name of the PostProcess.</param>
        /// <param name="fragmentUrl">The url of the fragment shader to be used.</param>
        /// <param name="parameters">Array of the names of uniform non-sampler2D variables that will be passed to the shader.</param>
        /// <param name="samplers">Array of the names of uniform sampler2D variables that will be passed to the shader.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass. (Use 1.0 for full size)</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="defines">String of defines that will be set when running the fragment shader. (default: null)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="vertexUrl">The url of the vertex shader to be used. (default: "postprocess")</param>
        /// <param name="indexParameters">The index parameters to be used for babylons include syntax "#include<kernelBlurVaryingDeclaration>[0..varyingCount]". (default: undefined) See usage in babylon.blurPostProcess.ts and kernelBlur.vertex.fx</param>
        /// <param name="blockCompilation">If the shader should not be compiled imediatly. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * fragmentUrl: string * parameters: Nullable<ResizeArray<string>> * samplers: Nullable<ResizeArray<string>> * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?defines: Nullable<string> * ?textureType: float * ?vertexUrl: string * ?indexParameters: obj option * ?blockCompilation: bool -> PostProcess

    /// PostProcessManager is used to manage one or more post processes or post process pipelines
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcessManager =
        abstract _scene: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _prepareBuffers: unit -> unit
        abstract _buildIndexBuffer: unit -> unit
        /// Rebuilds the vertex buffers of the manager.
        abstract _rebuild: unit -> unit
        /// <summary>Prepares a frame to be run through a post process.</summary>
        /// <param name="sourceTexture">The input texture to the post procesess. (default: null)</param>
        /// <param name="postProcesses">An array of post processes to be run. (default: null)</param>
        abstract _prepareFrame: ?sourceTexture: Nullable<InternalTexture> * ?postProcesses: Nullable<ResizeArray<PostProcess>> -> bool
        /// <summary>Manually render a set of post processes to a texture.</summary>
        /// <param name="postProcesses">An array of post processes to be run.</param>
        /// <param name="targetTexture">The target texture to render to.</param>
        /// <param name="forceFullscreenViewport">force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight</param>
        abstract directRender: postProcesses: ResizeArray<PostProcess> * ?targetTexture: Nullable<InternalTexture> * ?forceFullscreenViewport: bool -> unit
        /// <summary>Finalize the result of the output of the postprocesses.</summary>
        /// <param name="doNotPresent">If true the result will not be displayed to the screen.</param>
        /// <param name="targetTexture">The target texture to render to.</param>
        /// <param name="faceIndex">The index of the face to bind the target texture to.</param>
        /// <param name="postProcesses">The array of post processes to render.</param>
        /// <param name="forceFullscreenViewport">force gl.viewport to be full screen eg. 0,0,textureWidth,textureHeight (default: false)</param>
        abstract _finalizeFrame: ?doNotPresent: bool * ?targetTexture: InternalTexture * ?faceIndex: float * ?postProcesses: Array<PostProcess> * ?forceFullscreenViewport: bool -> unit
        /// Disposes of the post process manager.
        abstract dispose: unit -> unit

    /// PostProcessManager is used to manage one or more post processes or post process pipelines
    /// See https://doc.babylonjs.com/how_to/how_to_use_postprocesses
    type [<AllowNullLiteral>] PostProcessManagerStatic =
        /// <summary>Creates a new instance PostProcess</summary>
        /// <param name="scene">The scene that the post process is associated with.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> PostProcessManager

    type [<AllowNullLiteral>] RefractionPostProcess =
        inherit PostProcess
        abstract color: Color3 with get, set
        abstract depth: float with get, set
        abstract colorLevel: float with get, set
        abstract _refTexture: obj with get, set
        abstract _ownRefractionTexture: obj with get, set
        /// Gets or sets the refraction texture
        /// Please note that you are responsible for disposing the texture if you set it manually
        abstract refractionTexture: Texture with get, set
        abstract dispose: camera: Camera -> unit

    type [<AllowNullLiteral>] RefractionPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * refractionTextureUrl: string * color: Color3 * depth: float * colorLevel: float * options: U2<float, PostProcessOptions> * camera: Camera * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> RefractionPostProcess

    /// The SharpenPostProcess applies a sharpen kernel to every pixel
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] SharpenPostProcess =
        inherit PostProcess
        /// How much of the original color should be applied. Setting this to 0 will display edge detection. (default: 1)
        abstract colorAmount: float with get, set
        /// How much sharpness should be applied (default: 0.3)
        abstract edgeAmount: float with get, set

    /// The SharpenPostProcess applies a sharpen kernel to every pixel
    /// See http://en.wikipedia.org/wiki/Kernel_(image_processing)
    type [<AllowNullLiteral>] SharpenPostProcessStatic =
        /// <summary>Creates a new instance ConvolutionPostProcess</summary>
        /// <param name="name">The name of the effect.</param>
        /// <param name="options">The required width/height ratio to downsize to before computing the render pass.</param>
        /// <param name="camera">The camera to apply the render pass to.</param>
        /// <param name="samplingMode">The sampling mode to be used when computing the pass. (default: 0)</param>
        /// <param name="engine">The engine which the post process will be applied. (default: current engine)</param>
        /// <param name="reusable">If the post process can be reused on the same frame. (default: false)</param>
        /// <param name="textureType">Type of textures used when performing the post process. (default: 0)</param>
        /// <param name="blockCompilation">If compilation of the shader should not be done in the constructor. The updateEffect method can be used to compile the shader at a later time. (default: false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: U2<float, PostProcessOptions> * camera: Nullable<Camera> * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?textureType: float * ?blockCompilation: bool -> SharpenPostProcess

    type [<AllowNullLiteral>] StereoscopicInterlacePostProcess =
        inherit PostProcess
        abstract _stepSize: obj with get, set
        abstract _passedProcess: obj with get, set

    type [<AllowNullLiteral>] StereoscopicInterlacePostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * rigCameras: ResizeArray<Camera> * isStereoscopicHoriz: bool * ?samplingMode: float * ?engine: Engine * ?reusable: bool -> StereoscopicInterlacePostProcess

    type [<RequireQualifiedAccess>] TonemappingOperator =
        | Hable = 0
        | Reinhard = 1
        | HejiDawson = 2
        | Photographic = 3

    type [<AllowNullLiteral>] TonemapPostProcess =
        inherit PostProcess
        abstract _operator: obj with get, set
        abstract exposureAdjustment: float with get, set

    type [<AllowNullLiteral>] TonemapPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * _operator: TonemappingOperator * exposureAdjustment: float * camera: Camera * ?samplingMode: float * ?engine: Engine * ?textureFormat: float -> TonemapPostProcess

    type [<AllowNullLiteral>] VolumetricLightScatteringPostProcess =
        inherit PostProcess
        abstract _volumetricLightScatteringPass: obj with get, set
        abstract _volumetricLightScatteringRTT: obj with get, set
        abstract _viewPort: obj with get, set
        abstract _screenCoordinates: obj with get, set
        abstract _cachedDefines: obj with get, set
        /// If not undefined, the mesh position is computed from the attached node position
        abstract attachedNode: obj with get, set
        /// Custom position of the mesh. Used if "useCustomMeshPosition" is set to "true"
        abstract customMeshPosition: Vector3 with get, set
        /// Set if the post-process should use a custom position for the light source (true) or the internal mesh position (false)
        abstract useCustomMeshPosition: bool with get, set
        /// If the post-process should inverse the light scattering direction
        abstract invert: bool with get, set
        /// The internal mesh used by the post-process
        abstract mesh: Mesh with get, set
        abstract useDiffuseColor: bool with get, set
        /// Array containing the excluded meshes not rendered in the internal pass
        abstract excludedMeshes: ResizeArray<AbstractMesh> with get, set
        /// Controls the overall intensity of the post-process
        abstract exposure: float with get, set
        /// Dissipates each sample's contribution in range [0, 1]
        abstract decay: float with get, set
        /// Controls the overall intensity of each sample
        abstract weight: float with get, set
        /// Controls the density of each sample
        abstract density: float with get, set
        abstract getClassName: unit -> string
        abstract _isReady: subMesh: obj * useInstances: obj -> unit
        /// Sets the new light position for light scattering effect
        abstract setCustomMeshPosition: position: Vector3 -> unit
        /// Returns the light position for light scattering effect
        abstract getCustomMeshPosition: unit -> Vector3
        /// Disposes the internal assets and detaches the post-process from the camera
        abstract dispose: camera: Camera -> unit
        /// Returns the render target texture used by the post-process
        abstract getPass: unit -> RenderTargetTexture
        abstract _meshExcluded: mesh: obj -> unit
        abstract _createPass: scene: obj * ratio: obj -> unit
        abstract _updateMeshScreenCoordinates: scene: obj -> unit

    type [<AllowNullLiteral>] VolumetricLightScatteringPostProcessStatic =
        /// <param name="name">- The post-process name</param>
        /// <param name="ratio">- The size of the post-process and/or internal pass (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)</param>
        /// <param name="camera">- The camera that the post-process will be attached to</param>
        /// <param name="mesh">- The mesh used to create the light scattering</param>
        /// <param name="samples">- The post-process quality, default 100</param>
        /// <param name="samplingMode">- The post-process filtering mode</param>
        /// <param name="engine">- The babylon engine</param>
        /// <param name="reusable">- If the post-process is reusable</param>
        /// <param name="scene">- The constructor needs a scene reference to initialize internal components. If "camera" is null (RenderPipeline, "scene" must be provided</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * ratio: obj option * camera: Camera * ?mesh: Mesh * ?samples: float * ?samplingMode: float * ?engine: Engine * ?reusable: bool * ?scene: Scene -> VolumetricLightScatteringPostProcess
        /// Creates a default mesh for the Volumeric Light Scattering post-process
        abstract CreateDefaultMesh: name: string * scene: Scene -> Mesh

    type [<AllowNullLiteral>] VRDistortionCorrectionPostProcess =
        inherit PostProcess
        abstract _isRightEye: obj with get, set
        abstract _distortionFactors: obj with get, set
        abstract _postProcessScaleFactor: obj with get, set
        abstract _lensCenterOffset: obj with get, set
        abstract _scaleIn: obj with get, set
        abstract _scaleFactor: obj with get, set
        abstract _lensCenter: obj with get, set

    type [<AllowNullLiteral>] VRDistortionCorrectionPostProcessStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * camera: Camera * isRightEye: bool * vrMetrics: VRCameraMetrics -> VRDistortionCorrectionPostProcess

    type [<AllowNullLiteral>] AndOrNotEvaluator =
        interface end

    type [<AllowNullLiteral>] AndOrNotEvaluatorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AndOrNotEvaluator
        abstract Eval: query: string * evaluateCallback: (obj option -> bool) -> bool
        abstract _HandleParenthesisContent: parenthesisContent: obj * evaluateCallback: obj -> unit
        abstract _SimplifyNegation: booleanString: obj -> unit

    type [<RequireQualifiedAccess>] AssetTaskState =
        | INIT = 0
        | RUNNING = 1
        | DONE = 2
        | ERROR = 3

    /// Define an abstract asset task used with a {BABYLON.AssetsManager} class to load assets into a scene
    type [<AllowNullLiteral>] AbstractAssetTask =
        /// Task name
        abstract name: string with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (obj option -> unit) with get, set
        /// Callback called when the task is not successful
        abstract onError: (obj option -> string -> obj option -> unit) with get, set
        abstract _isCompleted: obj with get, set
        abstract _taskState: obj with get, set
        abstract _errorObject: obj with get, set
        /// Get if the task is completed
        abstract isCompleted: bool
        /// Gets the current state of the task
        abstract taskState: AssetTaskState
        /// Gets the current error object (if task is in error)
        abstract errorObject: obj
        /// Internal only
        abstract _setErrorObject: ?message: string * ?``exception``: obj option -> unit
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract run: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit
        abstract onErrorCallback: onError: obj * ?message: obj * ?``exception``: obj -> unit
        abstract onDoneCallback: onSuccess: obj * onError: obj -> unit

    /// Define an abstract asset task used with a {BABYLON.AssetsManager} class to load assets into a scene
    type [<AllowNullLiteral>] AbstractAssetTaskStatic =
        /// <summary>Creates a new {BABYLON.AssetsManager}</summary>
        /// <param name="name">defines the name of the task</param>
        [<Emit "new $0($1...)">] abstract Create: name: string -> AbstractAssetTask

    /// Define the interface used by progress events raised during assets loading
    type [<AllowNullLiteral>] IAssetsProgressEvent =
        /// Defines the number of remaining tasks to process
        abstract remainingCount: float with get, set
        /// Defines the total number of tasks
        abstract totalCount: float with get, set
        /// Defines the task that was just processed
        abstract task: AbstractAssetTask with get, set

    /// Class used to share progress information about assets loading
    type [<AllowNullLiteral>] AssetsProgressEvent =
        inherit IAssetsProgressEvent
        /// Defines the number of remaining tasks to process
        abstract remainingCount: float with get, set
        /// Defines the total number of tasks
        abstract totalCount: float with get, set
        /// Defines the task that was just processed
        abstract task: AbstractAssetTask with get, set

    /// Class used to share progress information about assets loading
    type [<AllowNullLiteral>] AssetsProgressEventStatic =
        /// <summary>Creates a {BABYLON.AssetsProgressEvent}</summary>
        /// <param name="remainingCount">defines the number of remaining tasks to process</param>
        /// <param name="totalCount">defines the total number of tasks</param>
        /// <param name="task">defines the task that was just processed</param>
        [<Emit "new $0($1...)">] abstract Create: remainingCount: float * totalCount: float * task: AbstractAssetTask -> AssetsProgressEvent

    /// Define a task used by {BABYLON.AssetsManager} to load meshes
    type [<AllowNullLiteral>] MeshAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the list of mesh's names you want to load
        abstract meshesNames: obj option with get, set
        /// Defines the root url to use as a base to load your meshes and associated resources
        abstract rootUrl: string with get, set
        /// Defines the filename of the scene to load from
        abstract sceneFilename: string with get, set
        /// Gets the list of loaded meshes
        abstract loadedMeshes: Array<AbstractMesh> with get, set
        /// Gets the list of loaded particle systems
        abstract loadedParticleSystems: Array<ParticleSystem> with get, set
        /// Gets the list of loaded skeletons
        abstract loadedSkeletons: Array<Skeleton> with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (MeshAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (MeshAssetTask -> string -> obj option -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit

    /// Define a task used by {BABYLON.AssetsManager} to load meshes
    type [<AllowNullLiteral>] MeshAssetTaskStatic =
        /// <summary>Creates a new {BABYLON.MeshAssetTask}</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="meshesNames">defines the list of mesh's names you want to load</param>
        /// <param name="rootUrl">defines the root url to use as a base to load your meshes and associated resources</param>
        /// <param name="sceneFilename">defines the filename of the scene to load from</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * meshesNames: obj option * rootUrl: string * sceneFilename: string -> MeshAssetTask

    /// Define a task used by {BABYLON.AssetsManager} to load text content
    type [<AllowNullLiteral>] TextFileAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Gets the loaded text string
        abstract text: string with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (TextFileAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (TextFileAssetTask -> string -> obj option -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit

    /// Define a task used by {BABYLON.AssetsManager} to load text content
    type [<AllowNullLiteral>] TextFileAssetTaskStatic =
        /// <summary>Creates a new TextFileAssetTask object</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the file to load</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string -> TextFileAssetTask

    /// Define a task used by {BABYLON.AssetsManager} to load binary data
    type [<AllowNullLiteral>] BinaryFileAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Gets the lodaded data (as an array buffer)
        abstract data: ArrayBuffer with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (BinaryFileAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (BinaryFileAssetTask -> string -> obj option -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit

    /// Define a task used by {BABYLON.AssetsManager} to load binary data
    type [<AllowNullLiteral>] BinaryFileAssetTaskStatic =
        /// <summary>Creates a new BinaryFileAssetTask object</summary>
        /// <param name="name">defines the name of the new task</param>
        /// <param name="url">defines the location of the file to load</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string -> BinaryFileAssetTask

    /// Define a task used by {BABYLON.AssetsManager} to load images
    type [<AllowNullLiteral>] ImageAssetTask =
        inherit AbstractAssetTask
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the image to load
        abstract url: string with get, set
        /// Gets the loaded images
        abstract image: HTMLImageElement with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (ImageAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (ImageAssetTask -> string -> obj option -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit

    /// Define a task used by {BABYLON.AssetsManager} to load images
    type [<AllowNullLiteral>] ImageAssetTaskStatic =
        /// <summary>Creates a new ImageAssetTask</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the image to load</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string -> ImageAssetTask

    /// Defines the interface used by texture loading tasks
    type [<AllowNullLiteral>] ITextureAssetTask<'TEX> =
        /// Gets the loaded texture
        abstract texture: 'TEX with get, set

    /// Define a task used by {BABYLON.AssetsManager} to load 2D textures
    type [<AllowNullLiteral>] TextureAssetTask =
        inherit AbstractAssetTask
        inherit ITextureAssetTask<Texture>
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Defines if mipmap should not be generated (default is false)
        abstract noMipmap: bool option with get, set
        /// Defines if texture must be inverted on Y axis (default is false)
        abstract invertY: bool option with get, set
        /// Defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)
        abstract samplingMode: float with get, set
        /// Gets the loaded texture
        abstract texture: Texture with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (TextureAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (TextureAssetTask -> string -> obj option -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit

    /// Define a task used by {BABYLON.AssetsManager} to load 2D textures
    type [<AllowNullLiteral>] TextureAssetTaskStatic =
        /// <summary>Creates a new TextureAssetTask object</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the file to load</param>
        /// <param name="noMipmap">defines if mipmap should not be generated (default is false)</param>
        /// <param name="invertY">defines if texture must be inverted on Y axis (default is false)</param>
        /// <param name="samplingMode">defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string * ?noMipmap: bool option * ?invertY: bool option * ?samplingMode: float -> TextureAssetTask

    /// Define a task used by {BABYLON.AssetsManager} to load cube textures
    type [<AllowNullLiteral>] CubeTextureAssetTask =
        inherit AbstractAssetTask
        inherit ITextureAssetTask<CubeTexture>
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)
        abstract url: string with get, set
        /// Defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)
        abstract extensions: ResizeArray<string> option with get, set
        /// Defines if mipmaps should not be generated (default is false)
        abstract noMipmap: bool option with get, set
        /// Defines the explicit list of files (undefined by default)
        abstract files: ResizeArray<string> option with get, set
        /// Gets the loaded texture
        abstract texture: CubeTexture with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (CubeTextureAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (CubeTextureAssetTask -> string -> obj option -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract runTask: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit

    /// Define a task used by {BABYLON.AssetsManager} to load cube textures
    type [<AllowNullLiteral>] CubeTextureAssetTaskStatic =
        /// <summary>Creates a new CubeTextureAssetTask</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the files to load (You have to specify the folder where the files are + filename with no extension)</param>
        /// <param name="extensions">defines the extensions to use to load files (["_px", "_py", "_pz", "_nx", "_ny", "_nz"] by default)</param>
        /// <param name="noMipmap">defines if mipmaps should not be generated (default is false)</param>
        /// <param name="files">defines the explicit list of files (undefined by default)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string * ?extensions: ResizeArray<string> option * ?noMipmap: bool option * ?files: ResizeArray<string> option -> CubeTextureAssetTask

    /// Define a task used by {BABYLON.AssetsManager} to load HDR cube textures
    type [<AllowNullLiteral>] HDRCubeTextureAssetTask =
        inherit AbstractAssetTask
        inherit ITextureAssetTask<HDRCubeTexture>
        /// Defines the name of the task
        abstract name: string with get, set
        /// Defines the location of the file to load
        abstract url: string with get, set
        /// Defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.
        abstract size: float option with get, set
        /// Defines if mipmaps should not be generated (default is false)
        abstract noMipmap: bool with get, set
        /// Specifies whether you want to extract the polynomial harmonics during the generation process (default is true)
        abstract generateHarmonics: bool with get, set
        /// Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)
        abstract useInGammaSpace: bool with get, set
        /// Specifies whether or not to generate the CubeMap through CubeMapGen to avoid seams issue at run time (default is false)
        abstract usePMREMGenerator: bool with get, set
        /// Gets the loaded texture
        abstract texture: HDRCubeTexture with get, set
        /// Callback called when the task is successful
        abstract onSuccess: (HDRCubeTextureAssetTask -> unit) with get, set
        /// Callback called when the task is successful
        abstract onError: (HDRCubeTextureAssetTask -> string -> obj option -> unit) with get, set
        /// <summary>Execute the current task</summary>
        /// <param name="scene">defines the scene where you want your assets to be loaded</param>
        /// <param name="onSuccess">is a callback called when the task is successfully executed</param>
        /// <param name="onError">is a callback called if an error occurs</param>
        abstract run: scene: Scene * onSuccess: (unit -> unit) * onError: (string -> obj option -> unit) -> unit

    /// Define a task used by {BABYLON.AssetsManager} to load HDR cube textures
    type [<AllowNullLiteral>] HDRCubeTextureAssetTaskStatic =
        /// <summary>Creates a new HDRCubeTextureAssetTask object</summary>
        /// <param name="name">defines the name of the task</param>
        /// <param name="url">defines the location of the file to load</param>
        /// <param name="size">defines the desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.</param>
        /// <param name="noMipmap">defines if mipmaps should not be generated (default is false)</param>
        /// <param name="generateHarmonics">specifies whether you want to extract the polynomial harmonics during the generation process (default is true)</param>
        /// <param name="useInGammaSpace">specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space) (default is false)</param>
        /// <param name="usePMREMGenerator">specifies whether or not to generate the CubeMap through CubeMapGen to avoid seams issue at run time (default is false)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * url: string * ?size: float option * ?noMipmap: bool * ?generateHarmonics: bool * ?useInGammaSpace: bool * ?usePMREMGenerator: bool -> HDRCubeTextureAssetTask

    /// This class can be used to easily import assets into a scene
    type [<AllowNullLiteral>] AssetsManager =
        abstract _scene: obj with get, set
        abstract _isLoading: obj with get, set
        abstract _tasks: ResizeArray<AbstractAssetTask> with get, set
        abstract _waitingTasksCount: float with get, set
        abstract _totalTasksCount: float with get, set
        /// Callback called when all tasks are processed
        abstract onFinish: (ResizeArray<AbstractAssetTask> -> unit) with get, set
        /// Callback called when a task is successful
        abstract onTaskSuccess: (AbstractAssetTask -> unit) with get, set
        /// Callback called when a task had an error
        abstract onTaskError: (AbstractAssetTask -> unit) with get, set
        /// Callback called when a task is done (whatever the result is)
        abstract onProgress: (float -> float -> AbstractAssetTask -> unit) with get, set
        /// Observable called when all tasks are processed
        abstract onTaskSuccessObservable: Observable<AbstractAssetTask> with get, set
        /// Observable called when a task had an error
        abstract onTaskErrorObservable: Observable<AbstractAssetTask> with get, set
        /// Observable called when a task is successful
        abstract onTasksDoneObservable: Observable<ResizeArray<AbstractAssetTask>> with get, set
        /// Observable called when a task is done (whatever the result is)
        abstract onProgressObservable: Observable<IAssetsProgressEvent> with get, set
        /// Gets or sets a boolean defining if the {BABYLON.AssetsManager} should use the default loading screen
        abstract useDefaultLoadingScreen: bool with get, set
        /// <summary>Add a {BABYLON.MeshAssetTask} to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="meshesNames">defines the name of meshes to load</param>
        /// <param name="rootUrl">defines the root url to use to locate files</param>
        /// <param name="sceneFilename">defines the filename of the scene file</param>
        abstract addMeshTask: taskName: string * meshesNames: obj option * rootUrl: string * sceneFilename: string -> MeshAssetTask
        /// <summary>Add a {BABYLON.TextFileAssetTask} to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        abstract addTextFileTask: taskName: string * url: string -> TextFileAssetTask
        /// <summary>Add a {BABYLON.BinaryFileAssetTask} to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        abstract addBinaryFileTask: taskName: string * url: string -> BinaryFileAssetTask
        /// <summary>Add a {BABYLON.ImageAssetTask} to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        abstract addImageTask: taskName: string * url: string -> ImageAssetTask
        /// <summary>Add a {BABYLON.TextureAssetTask} to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        /// <param name="noMipmap">defines if the texture must not receive mipmaps (false by default)</param>
        /// <param name="invertY">defines if you want to invert Y axis of the loaded texture (false by default)</param>
        /// <param name="samplingMode">defines the sampling mode to use (BABYLON.Texture.TRILINEAR_SAMPLINGMODE by default)</param>
        abstract addTextureTask: taskName: string * url: string * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float -> TextureAssetTask
        /// <summary>Add a {BABYLON.CubeTextureAssetTask} to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        /// <param name="extensions">defines the extension to use to load the cube map (can be null)</param>
        /// <param name="noMipmap">defines if the texture must not receive mipmaps (false by default)</param>
        /// <param name="files">defines the list of files to load (can be null)</param>
        abstract addCubeTextureTask: taskName: string * url: string * ?extensions: ResizeArray<string> * ?noMipmap: bool * ?files: ResizeArray<string> -> CubeTextureAssetTask
        /// <summary>Add a {BABYLON.HDRCubeTextureAssetTask} to the list of active tasks</summary>
        /// <param name="taskName">defines the name of the new task</param>
        /// <param name="url">defines the url of the file to load</param>
        /// <param name="size">defines the size you want for the cubemap (can be null)</param>
        /// <param name="noMipmap">defines if the texture must not receive mipmaps (false by default)</param>
        /// <param name="generateHarmonics">defines if you want to automatically generate (true by default)</param>
        /// <param name="useInGammaSpace">defines if the texture must be considered in gamma space (false by default)</param>
        /// <param name="usePMREMGenerator">is a reserved parameter and must be set to false or ignored</param>
        abstract addHDRCubeTextureTask: taskName: string * url: string * ?size: float * ?noMipmap: bool * ?generateHarmonics: bool * ?useInGammaSpace: bool * ?usePMREMGenerator: bool -> HDRCubeTextureAssetTask
        abstract _decreaseWaitingTasksCount: task: obj -> unit
        abstract _runTask: task: obj -> unit
        /// Reset the {BABYLON.AssetsManager} and remove all tasks
        abstract reset: unit -> AssetsManager
        /// Start the loading process
        abstract load: unit -> AssetsManager

    /// This class can be used to easily import assets into a scene
    type [<AllowNullLiteral>] AssetsManagerStatic =
        /// <summary>Creates a new AssetsManager</summary>
        /// <param name="scene">defines the scene to work on</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene -> AssetsManager

    type [<AllowNullLiteral>] Database =
        abstract callbackManifestChecked: obj with get, set
        abstract currentSceneUrl: obj with get, set
        abstract db: obj with get, set
        abstract _enableSceneOffline: obj with get, set
        abstract _enableTexturesOffline: obj with get, set
        abstract manifestVersionFound: obj with get, set
        abstract mustUpdateRessources: obj with get, set
        abstract hasReachedQuota: obj with get, set
        abstract isSupported: obj with get, set
        abstract idbFactory: obj with get, set
        abstract IsUASupportingBlobStorage: bool with get, set
        abstract IDBStorageEnabled: bool with get, set
        abstract enableSceneOffline: bool
        abstract enableTexturesOffline: bool
        abstract parseURL: (string -> string) with get, set
        abstract ReturnFullUrlLocation: (string -> string) with get, set
        abstract checkManifestFile: unit -> unit
        abstract openAsync: successCallback: (unit -> unit) * errorCallback: (unit -> unit) -> unit
        abstract loadImageFromDB: url: string * image: HTMLImageElement -> unit
        abstract _loadImageFromDBAsync: url: obj * image: obj * notInDBCallback: obj -> unit
        abstract _saveImageIntoDBAsync: url: obj * image: obj -> unit
        abstract _checkVersionFromDB: url: obj * versionLoaded: obj -> unit
        abstract _loadVersionFromDBAsync: url: obj * callback: obj * updateInDBCallback: obj -> unit
        abstract _saveVersionIntoDBAsync: url: obj * callback: obj -> unit
        abstract loadFileFromDB: url: string * sceneLoaded: (obj option -> unit) * ?progressCallBack: (obj option -> unit) * ?errorCallback: (unit -> unit) * ?useArrayBuffer: bool -> unit
        abstract _loadFileFromDBAsync: url: obj * callback: obj * notInDBCallback: obj * ?useArrayBuffer: obj -> unit
        abstract _saveFileIntoDBAsync: url: obj * callback: obj * ?progressCallback: obj * ?useArrayBuffer: obj -> unit

    type [<AllowNullLiteral>] DatabaseStatic =
        [<Emit "new $0($1...)">] abstract Create: urlToScene: string * callbackManifestChecked: (bool -> obj option) -> Database

    type [<AllowNullLiteral>] DDSInfo =
        abstract width: float with get, set
        abstract height: float with get, set
        abstract mipmapCount: float with get, set
        abstract isFourCC: bool with get, set
        abstract isRGB: bool with get, set
        abstract isLuminance: bool with get, set
        abstract isCube: bool with get, set
        abstract isCompressed: bool with get, set
        abstract dxgiFormat: float with get, set
        abstract textureType: float with get, set

    type [<AllowNullLiteral>] DDSTools =
        abstract StoreLODInAlphaChannel: bool with get, set
        abstract _FloatView: obj with get, set
        abstract _Int32View: obj with get, set

    type [<AllowNullLiteral>] DDSToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DDSTools
        abstract GetDDSInfo: arrayBuffer: obj option -> DDSInfo
        abstract _ToHalfFloat: value: obj -> unit
        abstract _FromHalfFloat: value: obj -> unit
        abstract _GetHalfFloatAsFloatRGBAArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj * lod: obj -> unit
        abstract _GetHalfFloatRGBAArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj * lod: obj -> unit
        abstract _GetFloatRGBAArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj * lod: obj -> unit
        abstract _GetFloatAsUIntRGBAArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj * lod: obj -> unit
        abstract _GetHalfFloatAsUIntRGBAArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj * lod: obj -> unit
        abstract _GetRGBAArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj * rOffset: obj * gOffset: obj * bOffset: obj * aOffset: obj -> unit
        abstract _ExtractLongWordOrder: value: obj -> unit
        abstract _GetRGBArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj * rOffset: obj * gOffset: obj * bOffset: obj -> unit
        abstract _GetLuminanceArrayBuffer: width: obj * height: obj * dataOffset: obj * dataLength: obj * arrayBuffer: obj -> unit
        abstract UploadDDSLevels: engine: Engine * gl: WebGLRenderingContext * arrayBuffer: obj option * info: DDSInfo * loadMipmaps: bool * faces: float * ?lodIndex: float * ?currentFace: float -> unit

    type [<AllowNullLiteral>] SerializationHelper =
        interface end

    type [<AllowNullLiteral>] SerializationHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SerializationHelper
        abstract Serialize: entity: 'T * ?serializationObject: obj option -> obj option
        abstract Parse: creationFunction: (unit -> 'T) * source: obj option * scene: Nullable<Scene> * ?rootUrl: Nullable<string> -> 'T
        abstract Clone: creationFunction: (unit -> 'T) * source: 'T -> 'T
        abstract Instanciate: creationFunction: (unit -> 'T) * source: 'T -> 'T

    /// Wrapper class for promise with external resolve and reject.
    type [<AllowNullLiteral>] Deferred<'T> =
        /// The promise associated with this deferred object.
        abstract promise: Promise<'T>
        abstract _resolve: obj with get, set
        abstract _reject: obj with get, set
        /// The resolve method of the promise associated with this deferred object.
        abstract resolve: (U2<'T, PromiseLike<'T>> option -> unit)
        /// The reject method of the promise associated with this deferred object.
        abstract reject: (obj option -> unit)

    /// Wrapper class for promise with external resolve and reject.
    type [<AllowNullLiteral>] DeferredStatic =
        /// Constructor for this deferred object.
        [<Emit "new $0($1...)">] abstract Create: unit -> Deferred<'T>

    type [<AllowNullLiteral>] FilesInput =
        abstract FilesToLoad: obj with get, set
        abstract onProcessFileCallback: (File -> string -> string -> obj) with get, set
        abstract _engine: obj with get, set
        abstract _currentScene: obj with get, set
        abstract _sceneLoadedCallback: obj with get, set
        abstract _progressCallback: obj with get, set
        abstract _additionalRenderLoopLogicCallback: obj with get, set
        abstract _textureLoadingCallback: obj with get, set
        abstract _startingProcessingFilesCallback: obj with get, set
        abstract _onReloadCallback: obj with get, set
        abstract _errorCallback: obj with get, set
        abstract _elementToMonitor: obj with get, set
        abstract _sceneFileToLoad: obj with get, set
        abstract _filesToLoad: obj with get, set
        abstract _dragEnterHandler: obj with get, set
        abstract _dragOverHandler: obj with get, set
        abstract _dropHandler: obj with get, set
        abstract monitorElementForDragNDrop: elementToMonitor: HTMLElement -> unit
        abstract dispose: unit -> unit
        abstract renderFunction: unit -> unit
        abstract drag: e: obj -> unit
        abstract drop: eventDrop: obj -> unit
        abstract _traverseFolder: folder: obj * files: obj * remaining: obj * callback: obj -> unit
        abstract _processFiles: files: obj -> unit
        abstract loadFiles: ``event``: obj option -> unit
        abstract _processReload: unit -> unit
        abstract reload: unit -> unit

    type [<AllowNullLiteral>] FilesInputStatic =
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * scene: Scene * sceneLoadedCallback: (File -> Scene -> unit) * progressCallback: (SceneLoaderProgressEvent -> unit) * additionalRenderLoopLogicCallback: (unit -> unit) * textureLoadingCallback: (float -> unit) * startingProcessingFilesCallback: (unit -> unit) * onReloadCallback: (File -> unit) * errorCallback: (File -> Scene -> string -> unit) -> FilesInput

    /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
    /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
    type [<AllowNullLiteral>] KhronosTextureContainer =
        abstract arrayBuffer: obj option with get, set
        abstract HEADER_LEN: float with get, set
        abstract COMPRESSED_2D: float with get, set
        abstract COMPRESSED_3D: float with get, set
        abstract TEX_2D: float with get, set
        abstract TEX_3D: float with get, set
        abstract glType: float with get, set
        abstract glTypeSize: float with get, set
        abstract glFormat: float with get, set
        abstract glInternalFormat: float with get, set
        abstract glBaseInternalFormat: float with get, set
        abstract pixelWidth: float with get, set
        abstract pixelHeight: float with get, set
        abstract pixelDepth: float with get, set
        abstract numberOfArrayElements: float with get, set
        abstract numberOfFaces: float with get, set
        abstract numberOfMipmapLevels: float with get, set
        abstract bytesOfKeyValueData: float with get, set
        abstract loadType: float with get, set
        abstract switchEndainness: ``val``: float -> float
        /// It is assumed that the texture has already been created & is currently bound
        abstract uploadLevels: gl: WebGLRenderingContext * loadMipmaps: bool -> unit
        abstract _upload2DCompressedLevels: gl: obj * loadMipmaps: obj -> unit

    /// for description see https://www.khronos.org/opengles/sdk/tools/KTX/
    /// for file layout see https://www.khronos.org/opengles/sdk/tools/KTX/file_format_spec/
    type [<AllowNullLiteral>] KhronosTextureContainerStatic =
        /// <param name="arrayBuffer">- contents of the KTX container file</param>
        /// <param name="facesExpected">- should be either 1 or 6, based whether a cube texture or or</param>
        /// <param name="threeDExpected">- provision for indicating that data should be a 3D texture, not implemented</param>
        /// <param name="textureArrayExpected">- provision for indicating that data should be a texture array, not implemented</param>
        [<Emit "new $0($1...)">] abstract Create: arrayBuffer: obj option * facesExpected: float * ?threeDExpected: bool * ?textureArrayExpected: bool -> KhronosTextureContainer

    /// A class serves as a medium between the observable and its observers
    type [<AllowNullLiteral>] EventState =
        /// <summary>Initialize the current event state</summary>
        /// <param name="mask">defines the mask associated with this state</param>
        /// <param name="skipNextObservers">defines a flag which will instruct the observable to skip following observers when set to true</param>
        /// <param name="target">defines the original target of the state</param>
        /// <param name="currentTarget">defines the current target of the state</param>
        abstract initalize: mask: float * ?skipNextObservers: bool * ?target: obj option * ?currentTarget: obj option -> EventState
        /// An Observer can set this property to true to prevent subsequent observers of being notified
        abstract skipNextObservers: bool with get, set
        /// Get the mask value that were used to trigger the event corresponding to this EventState object
        abstract mask: float with get, set
        /// The object that originally notified the event
        abstract target: obj option with get, set
        /// The current object in the bubbling phase
        abstract currentTarget: obj option with get, set
        /// This will be populated with the return value of the last function that was executed.
        /// If it is the first function in the callback chain it will be the event data.
        abstract lastReturnValue: obj option with get, set

    /// A class serves as a medium between the observable and its observers
    type [<AllowNullLiteral>] EventStateStatic =
        /// <summary>Create a new EventState</summary>
        /// <param name="mask">defines the mask associated with this state</param>
        /// <param name="skipNextObservers">defines a flag which will instruct the observable to skip following observers when set to true</param>
        /// <param name="target">defines the original target of the state</param>
        /// <param name="currentTarget">defines the current target of the state</param>
        [<Emit "new $0($1...)">] abstract Create: mask: float * ?skipNextObservers: bool * ?target: obj option * ?currentTarget: obj option -> EventState

    /// Represent an Observer registered to a given Observable object.
    type [<AllowNullLiteral>] Observer<'T> =
        /// Defines the callback to call when the observer is notified
        abstract callback: ('T -> EventState -> unit) with get, set
        /// Defines the mask of the observer (used to filter notifications)
        abstract mask: float with get, set
        /// Defines the current scope used to restore the JS context
        abstract scope: obj option with get, set
        abstract _willBeUnregistered: bool with get, set
        /// Gets or sets a property defining that the observer as to be unregistered after the next notification
        abstract unregisterOnNextCall: bool with get, set

    /// Represent an Observer registered to a given Observable object.
    type [<AllowNullLiteral>] ObserverStatic =
        /// <summary>Creates a new observer</summary>
        /// <param name="callback">defines the callback to call when the observer is notified</param>
        /// <param name="mask">defines the mask of the observer (used to filter notifications)</param>
        /// <param name="scope">defines the current scope used to restore the JS context</param>
        [<Emit "new $0($1...)">] abstract Create: callback: ('T -> EventState -> unit) * mask: float * ?scope: obj option -> Observer<'T>

    /// Represent a list of observers registered to multiple Observables object.
    type [<AllowNullLiteral>] MultiObserver<'T> =
        abstract _observers: obj with get, set
        abstract _observables: obj with get, set
        /// Release associated resources
        abstract dispose: unit -> unit

    /// Represent a list of observers registered to multiple Observables object.
    type [<AllowNullLiteral>] MultiObserverStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MultiObserver<'T>
        /// <summary>Raise a callback when one of the observable will notify</summary>
        /// <param name="observables">defines a list of observables to watch</param>
        /// <param name="callback">defines the callback to call on notification</param>
        /// <param name="mask">defines the mask used to filter notifications</param>
        /// <param name="scope">defines the current scope used to restore the JS context</param>
        abstract Watch: observables: ResizeArray<Observable<'T>> * callback: ('T -> EventState -> unit) * ?mask: float * ?scope: obj option -> MultiObserver<'T>

    /// The Observable class is a simple implementation of the Observable pattern.
    /// 
    /// There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
    /// This enable a more fine grained execution without having to rely on multiple different Observable objects.
    /// For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
    /// A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
    type [<AllowNullLiteral>] Observable<'T> =
        abstract _observers: obj with get, set
        abstract _eventState: obj with get, set
        abstract _onObserverAdded: obj with get, set
        /// <summary>Create a new Observer with the specified callback</summary>
        /// <param name="callback">the callback that will be executed for that Observer</param>
        /// <param name="mask">the mask used to filter observers</param>
        /// <param name="insertFirst">if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.</param>
        /// <param name="scope">optional scope for the callback to be called from</param>
        /// <param name="unregisterOnFirstCall">defines if the observer as to be unregistered after the next notification</param>
        abstract add: callback: ('T -> EventState -> unit) * ?mask: float * ?insertFirst: bool * ?scope: obj option * ?unregisterOnFirstCall: bool -> Nullable<Observer<'T>>
        /// <summary>Remove an Observer from the Observable object</summary>
        /// <param name="observer">the instance of the Observer to remove</param>
        abstract remove: observer: Nullable<Observer<'T>> -> bool
        /// <summary>Remove a callback from the Observable object</summary>
        /// <param name="callback">the callback to remove</param>
        /// <param name="scope">optional scope. If used only the callbacks with this scope will be removed</param>
        abstract removeCallback: callback: ('T -> EventState -> unit) * ?scope: obj option -> bool
        abstract _deferUnregister: observer: obj -> unit
        /// <summary>Notify all Observers by calling their respective callback with the given data
        /// Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute</summary>
        /// <param name="eventData">defines the data to send to all observers</param>
        /// <param name="mask">defines the mask of the current notification (observers with incompatible mask (ie mask & observer.mask === 0) will not be notified)</param>
        /// <param name="target">defines the original target of the state</param>
        /// <param name="currentTarget">defines the current target of the state</param>
        abstract notifyObservers: eventData: 'T * ?mask: float * ?target: obj option * ?currentTarget: obj option -> bool
        /// <summary>Calling this will execute each callback, expecting it to be a promise or return a value.
        /// If at any point in the chain one function fails, the promise will fail and the execution will not continue.
        /// This is useful when a chain of events (sometimes async events) is needed to initialize a certain object
        /// and it is crucial that all callbacks will be executed.
        /// The order of the callbacks is kept, callbacks are not executed parallel.</summary>
        /// <param name="eventData">The data to be sent to each callback</param>
        /// <param name="mask">is used to filter observers defaults to -1</param>
        /// <param name="target">defines the callback target (see EventState)</param>
        /// <param name="currentTarget">defines he current object in the bubbling phase</param>
        abstract notifyObserversWithPromise: eventData: 'T * ?mask: float * ?target: obj option * ?currentTarget: obj option -> Promise<'T>
        /// <summary>Notify a specific observer</summary>
        /// <param name="observer">defines the observer to notify</param>
        /// <param name="eventData">defines the data to be sent to each callback</param>
        /// <param name="mask">is used to filter observers defaults to -1</param>
        abstract notifyObserver: observer: Observer<'T> * eventData: 'T * ?mask: float -> unit
        /// Gets a boolean indicating if the observable has at least one observer
        abstract hasObservers: unit -> bool
        /// Clear the list of observers
        abstract clear: unit -> unit
        /// Clone the current observable
        abstract clone: unit -> Observable<'T>
        /// <summary>Does this observable handles observer registered with a given mask</summary>
        /// <param name="mask">defines the mask to be tested</param>
        abstract hasSpecificMask: ?mask: float -> bool

    /// The Observable class is a simple implementation of the Observable pattern.
    /// 
    /// There's one slight particularity though: a given Observable can notify its observer using a particular mask value, only the Observers registered with this mask value will be notified.
    /// This enable a more fine grained execution without having to rely on multiple different Observable objects.
    /// For instance you may have a given Observable that have four different types of notifications: Move (mask = 0x01), Stop (mask = 0x02), Turn Right (mask = 0X04), Turn Left (mask = 0X08).
    /// A given observer can register itself with only Move and Stop (mask = 0x03), then it will only be notified when one of these two occurs and will never be for Turn Left/Right.
    type [<AllowNullLiteral>] ObservableStatic =
        /// <summary>Creates a new observable</summary>
        /// <param name="onObserverAdded">defines a callback to call when a new observer is added</param>
        [<Emit "new $0($1...)">] abstract Create: ?onObserverAdded: (Observer<'T> -> unit) -> Observable<'T>

    /// Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
    type [<AllowNullLiteral>] PerformanceMonitor =
        abstract _enabled: obj with get, set
        abstract _rollingFrameTime: obj with get, set
        abstract _lastFrameTimeMs: obj with get, set
        /// <summary>Samples current frame</summary>
        /// <param name="timeMs">A timestamp in milliseconds of the current frame to compare with other frames</param>
        abstract sampleFrame: ?timeMs: float -> unit
        /// Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
        abstract averageFrameTime: float
        /// Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
        abstract averageFrameTimeVariance: float
        /// Returns the frame time of the most recent frame
        abstract instantaneousFrameTime: float
        /// Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
        abstract averageFPS: float
        /// Returns the average framerate in frames per second using the most recent frame time
        abstract instantaneousFPS: float
        /// Returns true if enough samples have been taken to completely fill the sliding window
        abstract isSaturated: bool
        /// Enables contributions to the sliding window sample set
        abstract enable: unit -> unit
        /// Disables contributions to the sliding window sample set
        /// Samples will not be interpolated over the disabled period
        abstract disable: unit -> unit
        /// Returns true if sampling is enabled
        abstract isEnabled: bool
        /// Resets performance monitor
        abstract reset: unit -> unit

    /// Performance monitor tracks rolling average frame-time and frame-time variance over a user defined sliding-window
    type [<AllowNullLiteral>] PerformanceMonitorStatic =
        /// <summary>constructor</summary>
        /// <param name="frameSampleSize">The number of samples required to saturate the sliding window</param>
        [<Emit "new $0($1...)">] abstract Create: ?frameSampleSize: float -> PerformanceMonitor

    /// RollingAverage
    /// 
    /// Utility to efficiently compute the rolling average and variance over a sliding window of samples
    type [<AllowNullLiteral>] RollingAverage =
        /// Current average
        abstract average: float with get, set
        /// Current variance
        abstract variance: float with get, set
        abstract _samples: Array<float> with get, set
        abstract _sampleCount: float with get, set
        abstract _pos: float with get, set
        abstract _m2: float with get, set
        /// <summary>Adds a sample to the sample set</summary>
        /// <param name="v">The sample value</param>
        abstract add: v: float -> unit
        /// <summary>Returns previously added values or null if outside of history or outside the sliding window domain</summary>
        /// <param name="i">Index in history. For example, pass 0 for the most recent value and 1 for the value before that</param>
        abstract history: i: float -> float
        /// Returns true if enough samples have been taken to completely fill the sliding window
        abstract isSaturated: unit -> bool
        /// Resets the rolling average (equivalent to 0 samples taken so far)
        abstract reset: unit -> unit
        /// <summary>Wraps a value around the sample range boundaries</summary>
        /// <param name="i">Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.</param>
        abstract _wrapPosition: i: float -> float

    /// RollingAverage
    /// 
    /// Utility to efficiently compute the rolling average and variance over a sliding window of samples
    type [<AllowNullLiteral>] RollingAverageStatic =
        /// <summary>constructor</summary>
        /// <param name="length">The number of samples required to saturate the sliding window</param>
        [<Emit "new $0($1...)">] abstract Create: length: float -> RollingAverage

    /// Helper class that provides a small promise polyfill
    type [<AllowNullLiteral>] PromisePolyfill =
        interface end

    /// Helper class that provides a small promise polyfill
    type [<AllowNullLiteral>] PromisePolyfillStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PromisePolyfill
        /// <summary>Static function used to check if the polyfill is required
        /// If this is the case then the function will inject the polyfill to window.Promise</summary>
        /// <param name="force">defines a boolean used to force the injection (mostly for testing purposes)</param>
        abstract Apply: ?force: bool -> unit

    /// Defines the root class used to create scene optimization to use with SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimization =
        /// Defines the priority of this optimization (0 by default which means first in the list)
        abstract priority: float with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines the root class used to create scene optimization to use with SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimizationStatic =
        /// <summary>Creates the SceneOptimization object</summary>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        [<Emit "new $0($1...)">] abstract Create: ?priority: float -> SceneOptimization

    /// Defines an optimization used to reduce the size of render target textures
    type [<AllowNullLiteral>] TextureOptimization =
        inherit SceneOptimization
        /// Defines the priority of this optimization (0 by default which means first in the list)
        abstract priority: float with get, set
        /// Defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter
        abstract maximumSize: float with get, set
        /// Defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.
        abstract step: float with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to reduce the size of render target textures
    type [<AllowNullLiteral>] TextureOptimizationStatic =
        /// <summary>Creates the TextureOptimization object</summary>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        /// <param name="maximumSize">defines the maximum sized allowed for textures (1024 is the default value). If a texture is bigger, it will be scaled down using a factor defined by the step parameter</param>
        /// <param name="step">defines the factor (0.5 by default) used to scale down textures bigger than maximum sized allowed.</param>
        [<Emit "new $0($1...)">] abstract Create: ?priority: float * ?maximumSize: float * ?step: float -> TextureOptimization

    /// Defines an optimization used to increase or decrease the rendering resolution
    type [<AllowNullLiteral>] HardwareScalingOptimization =
        inherit SceneOptimization
        /// Defines the priority of this optimization (0 by default which means first in the list)
        abstract priority: float with get, set
        /// Defines the maximum scale to use (2 by default)
        abstract maximumScale: float with get, set
        /// Defines the step to use between two passes (0.5 by default)
        abstract step: float with get, set
        abstract _currentScale: obj with get, set
        abstract _directionOffset: obj with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to increase or decrease the rendering resolution
    type [<AllowNullLiteral>] HardwareScalingOptimizationStatic =
        /// <summary>Creates the HardwareScalingOptimization object</summary>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        /// <param name="maximumScale">defines the maximum scale to use (2 by default)</param>
        /// <param name="step">defines the step to use between two passes (0.5 by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?priority: float * ?maximumScale: float * ?step: float -> HardwareScalingOptimization

    /// Defines an optimization used to remove shadows
    type [<AllowNullLiteral>] ShadowsOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to remove shadows
    type [<AllowNullLiteral>] ShadowsOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ShadowsOptimization

    /// Defines an optimization used to turn post-processes off
    type [<AllowNullLiteral>] PostProcessesOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn post-processes off
    type [<AllowNullLiteral>] PostProcessesOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PostProcessesOptimization

    /// Defines an optimization used to turn lens flares off
    type [<AllowNullLiteral>] LensFlaresOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn lens flares off
    type [<AllowNullLiteral>] LensFlaresOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> LensFlaresOptimization

    /// Defines an optimization based on user defined callback.
    type [<AllowNullLiteral>] CustomOptimization =
        inherit SceneOptimization
        /// Callback called to apply the custom optimization.
        abstract onApply: (Scene -> SceneOptimizer -> bool) with get, set
        /// Callback called to get custom description
        abstract onGetDescription: (unit -> string) with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization based on user defined callback.
    type [<AllowNullLiteral>] CustomOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CustomOptimization

    /// Defines an optimization used to turn particles off
    type [<AllowNullLiteral>] ParticlesOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn particles off
    type [<AllowNullLiteral>] ParticlesOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ParticlesOptimization

    /// Defines an optimization used to turn render targets off
    type [<AllowNullLiteral>] RenderTargetsOptimization =
        inherit SceneOptimization
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer -> bool

    /// Defines an optimization used to turn render targets off
    type [<AllowNullLiteral>] RenderTargetsOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RenderTargetsOptimization

    /// Defines an optimization used to merge meshes with compatible materials
    type [<AllowNullLiteral>] MergeMeshesOptimization =
        inherit SceneOptimization
        abstract _UpdateSelectionTree: obj with get, set
        /// Gets or sets a boolean which defines if optimization octree has to be updated
        /// Gets or sets a boolean which defines if optimization octree has to be updated
        abstract UpdateSelectionTree: bool with get, set
        /// Gets a string describing the action executed by the current optimization
        abstract getDescription: unit -> string
        abstract _canBeMerged: obj with get, set
        /// <summary>This function will be called by the SceneOptimizer when its priority is reached in order to apply the change required by the current optimization</summary>
        /// <param name="scene">defines the current scene where to apply this optimization</param>
        /// <param name="optimizer">defines the current optimizer</param>
        /// <param name="updateSelectionTree">defines that the selection octree has to be updated (false by default)</param>
        abstract apply: scene: Scene * optimizer: SceneOptimizer * ?updateSelectionTree: bool -> bool

    /// Defines an optimization used to merge meshes with compatible materials
    type [<AllowNullLiteral>] MergeMeshesOptimizationStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> MergeMeshesOptimization

    /// Defines a list of options used by SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimizerOptions =
        /// Defines the target frame rate to reach (60 by default)
        abstract targetFrameRate: float with get, set
        /// Defines the interval between two checkes (2000ms by default)
        abstract trackerDuration: float with get, set
        /// Gets the list of optimizations to apply
        abstract optimizations: ResizeArray<SceneOptimization> with get, set
        /// <summary>Add a new optimization</summary>
        /// <param name="optimization">defines the SceneOptimization to add to the list of active optimizations</param>
        abstract addOptimization: optimization: SceneOptimization -> SceneOptimizerOptions
        /// <summary>Add a new custom optimization</summary>
        /// <param name="onApply">defines the callback called to apply the custom optimization (true if everything that can be done was applied)</param>
        /// <param name="onGetDescription">defines the callback called to get the description attached with the optimization.</param>
        /// <param name="priority">defines the priority of this optimization (0 by default which means first in the list)</param>
        abstract addCustomOptimization: onApply: (Scene -> bool) * onGetDescription: (unit -> string) * ?priority: float -> SceneOptimizerOptions

    /// Defines a list of options used by SceneOptimizer
    type [<AllowNullLiteral>] SceneOptimizerOptionsStatic =
        /// <summary>Creates a new list of options used by SceneOptimizer</summary>
        /// <param name="targetFrameRate">defines the target frame rate to reach (60 by default)</param>
        /// <param name="trackerDuration">defines the interval between two checkes (2000ms by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?targetFrameRate: float * ?trackerDuration: float -> SceneOptimizerOptions
        /// <summary>Creates a list of pre-defined optimizations aimed to reduce the visual impact on the scene</summary>
        /// <param name="targetFrameRate">defines the target frame rate (60 by default)</param>
        abstract LowDegradationAllowed: ?targetFrameRate: float -> SceneOptimizerOptions
        /// <summary>Creates a list of pre-defined optimizations aimed to have a moderate impact on the scene visual</summary>
        /// <param name="targetFrameRate">defines the target frame rate (60 by default)</param>
        abstract ModerateDegradationAllowed: ?targetFrameRate: float -> SceneOptimizerOptions
        /// <summary>Creates a list of pre-defined optimizations aimed to have a big impact on the scene visual</summary>
        /// <param name="targetFrameRate">defines the target frame rate (60 by default)</param>
        abstract HighDegradationAllowed: ?targetFrameRate: float -> SceneOptimizerOptions

    /// Class used to run optimizations in order to reach a target frame rate
    type [<AllowNullLiteral>] SceneOptimizer =
        inherit IDisposable
        abstract _isRunning: obj with get, set
        abstract _options: obj with get, set
        abstract _scene: obj with get, set
        abstract _currentPriorityLevel: obj with get, set
        abstract _targetFrameRate: obj with get, set
        abstract _trackerDuration: obj with get, set
        abstract _currentFrameRate: obj with get, set
        abstract _sceneDisposeObserver: obj with get, set
        abstract _improvementMode: obj with get, set
        /// Defines an observable called when the optimizer reaches the target frame rate
        abstract onSuccessObservable: Observable<SceneOptimizer> with get, set
        /// Defines an observable called when the optimizer enables an optimization
        abstract onNewOptimizationAppliedObservable: Observable<SceneOptimization> with get, set
        /// Defines an observable called when the optimizer is not able to reach the target frame rate
        abstract onFailureObservable: Observable<SceneOptimizer> with get, set
        /// Gets a boolean indicating if the optimizer is in improvement mode
        abstract isInImprovementMode: bool
        /// Gets the current priority level (0 at start)
        abstract currentPriorityLevel: float
        /// Gets the current frame rate checked by the SceneOptimizer
        abstract currentFrameRate: float
        /// Gets or sets the current target frame rate (60 by default)
        /// Gets or sets the current target frame rate (60 by default)
        abstract targetFrameRate: float with get, set
        /// Gets or sets the current interval between two checks (every 2000ms by default)
        /// Gets or sets the current interval between two checks (every 2000ms by default)
        abstract trackerDuration: float with get, set
        /// Gets the list of active optimizations
        abstract optimizations: ResizeArray<SceneOptimization>
        /// Stops the current optimizer
        abstract stop: unit -> unit
        /// Reset the optimizer to initial step (current priority level = 0)
        abstract reset: unit -> unit
        /// Start the optimizer. By default it will try to reach a specific framerate
        /// but if the optimizer is set with improvementMode === true then it will run all optimiatiation while frame rate is above the target frame rate
        abstract start: unit -> unit
        abstract _checkCurrentState: unit -> unit
        /// Release all resources
        abstract dispose: unit -> unit

    /// Class used to run optimizations in order to reach a target frame rate
    type [<AllowNullLiteral>] SceneOptimizerStatic =
        /// <summary>Creates a new SceneOptimizer</summary>
        /// <param name="scene">defines the scene to work on</param>
        /// <param name="options">defines the options to use with the SceneOptimizer</param>
        /// <param name="autoGeneratePriorities">defines if priorities must be generated and not read from SceneOptimization property (true by default)</param>
        /// <param name="improvementMode">defines if the scene optimizer must run the maximum optimization while staying over a target frame instead of trying to reach the target framerate (false by default)</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?options: SceneOptimizerOptions * ?autoGeneratePriorities: bool * ?improvementMode: bool -> SceneOptimizer
        /// <summary>Helper function to create a SceneOptimizer with one single line of code</summary>
        /// <param name="scene">defines the scene to work on</param>
        /// <param name="options">defines the options to use with the SceneOptimizer</param>
        /// <param name="onSuccess">defines a callback to call on success</param>
        /// <param name="onFailure">defines a callback to call on failure</param>
        abstract OptimizeAsync: scene: Scene * ?options: SceneOptimizerOptions * ?onSuccess: (unit -> unit) * ?onFailure: (unit -> unit) -> SceneOptimizer

    type [<AllowNullLiteral>] SceneSerializer =
        interface end

    type [<AllowNullLiteral>] SceneSerializerStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SceneSerializer
        abstract ClearCache: unit -> unit
        abstract Serialize: scene: Scene -> obj option
        abstract SerializeMesh: toSerialize: obj option * ?withParents: bool * ?withChildren: bool -> obj option

    type [<AllowNullLiteral>] SmartArray<'T> =
        abstract data: Array<'T> with get, set
        abstract length: float with get, set
        abstract _id: float with get, set
        [<Emit "$0[$1]{{=$2}}">] abstract Item: index: float -> 'T with get, set
        abstract push: value: 'T -> unit
        abstract forEach: func: ('T -> unit) -> unit
        abstract sort: compareFn: ('T -> 'T -> float) -> unit
        abstract reset: unit -> unit
        abstract dispose: unit -> unit
        abstract concat: array: obj option -> unit
        abstract indexOf: value: 'T -> float
        abstract contains: value: 'T -> bool
        abstract _GlobalId: obj with get, set

    type [<AllowNullLiteral>] SmartArrayStatic =
        [<Emit "new $0($1...)">] abstract Create: capacity: float -> SmartArray<'T>

    type [<AllowNullLiteral>] SmartArrayNoDuplicate<'T> =
        inherit SmartArray<'T>
        abstract _duplicateId: obj with get, set
        [<Emit "$0[$1]{{=$2}}">] abstract Item: index: float -> 'T with get, set
        abstract push: value: 'T -> unit
        abstract pushNoDuplicate: value: 'T -> bool
        abstract reset: unit -> unit
        abstract concatWithNoDuplicate: array: obj option -> unit

    type [<AllowNullLiteral>] SmartArrayNoDuplicateStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> SmartArrayNoDuplicate<'T>

    /// This class implement a typical dictionary using a string as key and the generic type T as value.
    /// The underlying implementation relies on an associative array to ensure the best performances.
    /// The value can be anything including 'null' but except 'undefined'
    type [<AllowNullLiteral>] StringDictionary<'T> =
        /// <summary>This will clear this dictionary and copy the content from the 'source' one.
        /// If the T value is a custom object, it won't be copied/cloned, the same object will be used</summary>
        /// <param name="source">the dictionary to take the content from and copy to this dictionary</param>
        abstract copyFrom: source: StringDictionary<'T> -> unit
        /// <summary>Get a value based from its key</summary>
        /// <param name="key">the given key to get the matching value from</param>
        abstract get: key: string -> 'T option
        /// <summary>Get a value from its key or add it if it doesn't exist.
        /// This method will ensure you that a given key/data will be present in the dictionary.</summary>
        /// <param name="key">the given key to get the matching value from</param>
        /// <param name="factory">the factory that will create the value if the key is not present in the dictionary.
        /// The factory will only be invoked if there's no data for the given key.</param>
        abstract getOrAddWithFactory: key: string * factory: (string -> 'T) -> 'T
        /// <summary>Get a value from its key if present in the dictionary otherwise add it</summary>
        /// <param name="key">the key to get the value from</param>
        /// <param name="val">if there's no such key/value pair in the dictionary add it with this value</param>
        abstract getOrAdd: key: string * ``val``: 'T -> 'T
        /// <summary>Check if there's a given key in the dictionary</summary>
        /// <param name="key">the key to check for</param>
        abstract contains: key: string -> bool
        /// <summary>Add a new key and its corresponding value</summary>
        /// <param name="key">the key to add</param>
        /// <param name="value">the value corresponding to the key</param>
        abstract add: key: string * value: 'T -> bool
        abstract set: key: string * value: 'T -> bool
        /// <summary>Get the element of the given key and remove it from the dictionary</summary>
        /// <param name="key"></param>
        abstract getAndRemove: key: string -> Nullable<'T>
        /// <summary>Remove a key/value from the dictionary.</summary>
        /// <param name="key">the key to remove</param>
        abstract remove: key: string -> bool
        /// Clear the whole content of the dictionary
        abstract clear: unit -> unit
        abstract count: float
        /// <summary>Execute a callback on each key/val of the dictionary.
        /// Note that you can remove any element in this dictionary in the callback implementation</summary>
        /// <param name="callback">the callback to execute on a given key/value pair</param>
        abstract forEach: callback: (string -> 'T -> unit) -> unit
        /// <summary>Execute a callback on every occurrence of the dictionary until it returns a valid TRes object.
        /// If the callback returns null or undefined the method will iterate to the next key/value pair
        /// Note that you can remove any element in this dictionary in the callback implementation</summary>
        /// <param name="callback">the callback to execute, if it return a valid T instanced object the enumeration will stop and the object will be returned</param>
        abstract first: callback: (string -> 'T -> 'TRes) -> 'TRes option
        abstract _count: obj with get, set
        abstract _data: obj with get, set

    /// This class implement a typical dictionary using a string as key and the generic type T as value.
    /// The underlying implementation relies on an associative array to ensure the best performances.
    /// The value can be anything including 'null' but except 'undefined'
    type [<AllowNullLiteral>] StringDictionaryStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> StringDictionary<'T>

    type [<AllowNullLiteral>] Tags =
        interface end

    type [<AllowNullLiteral>] TagsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Tags
        abstract EnableFor: obj: obj option -> unit
        abstract DisableFor: obj: obj option -> unit
        abstract HasTags: obj: obj option -> bool
        abstract GetTags: obj: obj option * ?asString: bool -> obj option
        abstract AddTagsTo: obj: obj option * tagsString: string -> unit
        abstract _AddTagTo: obj: obj option * tag: string -> unit
        abstract RemoveTagsFrom: obj: obj option * tagsString: string -> unit
        abstract _RemoveTagFrom: obj: obj option * tag: string -> unit
        abstract MatchesQuery: obj: obj option * tagsQuery: string -> bool

    type [<AllowNullLiteral>] TextureTools =
        abstract _environmentBRDFBase64Texture: obj with get, set

    type [<AllowNullLiteral>] TextureToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> TextureTools
        /// <summary>Uses the GPU to create a copy texture rescaled at a given size</summary>
        /// <param name="texture">Texture to copy from</param>
        /// <param name="width">Desired width</param>
        /// <param name="height">Desired height</param>
        abstract CreateResizedCopy: texture: Texture * width: float * height: float * ?useBilinearMode: bool -> Texture
        abstract GetEnvironmentBRDFTexture: scene: Scene -> BaseTexture

    type [<AllowNullLiteral>] TGATools =
        abstract _TYPE_INDEXED: obj with get, set
        abstract _TYPE_RGB: obj with get, set
        abstract _TYPE_GREY: obj with get, set
        abstract _TYPE_RLE_INDEXED: obj with get, set
        abstract _TYPE_RLE_RGB: obj with get, set
        abstract _TYPE_RLE_GREY: obj with get, set
        abstract _ORIGIN_MASK: obj with get, set
        abstract _ORIGIN_SHIFT: obj with get, set
        abstract _ORIGIN_BL: obj with get, set
        abstract _ORIGIN_BR: obj with get, set
        abstract _ORIGIN_UL: obj with get, set
        abstract _ORIGIN_UR: obj with get, set

    type [<AllowNullLiteral>] TGAToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> TGATools
        abstract GetTGAHeader: data: Uint8Array -> obj option
        abstract UploadContent: gl: WebGLRenderingContext * data: Uint8Array -> unit
        abstract _getImageData8bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageData16bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageData24bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageData32bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageDataGrey8bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array
        abstract _getImageDataGrey16bits: header: obj option * palettes: Uint8Array * pixel_data: Uint8Array * y_start: float * y_step: float * y_end: float * x_start: float * x_step: float * x_end: float -> Uint8Array

    type [<AllowNullLiteral>] IAnimatable =
        abstract animations: Array<Animation> with get, set

    type [<AllowNullLiteral>] LoadFileError =
        inherit Error
        abstract request: XMLHttpRequest option with get, set
        abstract _setPrototypeOf: obj with get, set

    type [<AllowNullLiteral>] LoadFileErrorStatic =
        [<Emit "new $0($1...)">] abstract Create: message: string * ?request: XMLHttpRequest option -> LoadFileError

    type [<AllowNullLiteral>] RetryStrategy =
        interface end

    type [<AllowNullLiteral>] RetryStrategyStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> RetryStrategy
        abstract ExponentialBackoff: ?maxRetries: float * ?baseInterval: float -> (string -> XMLHttpRequest -> float -> float)

    type [<AllowNullLiteral>] IFileRequest =
        /// Raised when the request is complete (success or error).
        abstract onCompleteObservable: Observable<IFileRequest> with get, set
        /// Aborts the request for a file.
        abstract abort: (unit -> unit) with get, set

    type [<AllowNullLiteral>] Tools =
        abstract BaseUrl: string with get, set
        abstract DefaultRetryStrategy: (string -> XMLHttpRequest -> float -> float) with get, set
        /// Default behaviour for cors in the application.
        /// It can be a string if the expected behavior is identical in the entire app.
        /// Or a callback to be able to set it per url or on a group of them (in case of Video source for instance)
        abstract CorsBehavior: U2<string, (U2<string, ResizeArray<string>> -> string)> with get, set
        abstract UseFallbackTexture: bool with get, set
        /// Use this object to register external classes like custom textures or material
        /// to allow the laoders to instantiate them
        abstract RegisteredExternalClasses: obj with get, set
        abstract fallbackTexture: string with get, set
        abstract PreprocessUrl: (string -> string) with get, set
        abstract _NoneLogLevel: obj with get, set
        abstract _MessageLogLevel: obj with get, set
        abstract _WarningLogLevel: obj with get, set
        abstract _ErrorLogLevel: obj with get, set
        abstract _LogCache: obj with get, set
        abstract errorsCount: float with get, set
        abstract OnNewCacheEntry: (string -> unit) with get, set
        abstract NoneLogLevel: float
        abstract MessageLogLevel: float
        abstract WarningLogLevel: float
        abstract ErrorLogLevel: float
        abstract AllLogLevel: float
        abstract Log: (string -> unit) with get, set
        abstract Warn: (string -> unit) with get, set
        abstract Error: (string -> unit) with get, set
        abstract LogCache: string
        abstract LogLevels: float with get, set
        abstract _PerformanceNoneLogLevel: obj with get, set
        abstract _PerformanceUserMarkLogLevel: obj with get, set
        abstract _PerformanceConsoleLogLevel: obj with get, set
        abstract _performance: obj with get, set
        abstract PerformanceNoneLogLevel: float
        abstract PerformanceUserMarkLogLevel: float
        abstract PerformanceConsoleLogLevel: float
        abstract PerformanceLogLevel: float with get, set
        abstract StartPerformanceCounter: (string -> bool -> unit) with get, set
        abstract EndPerformanceCounter: (string -> bool -> unit) with get, set
        abstract Now: float

    type [<AllowNullLiteral>] ToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> Tools
        /// <summary>Interpolates between a and b via alpha</summary>
        /// <param name="a">The lower value (returned when alpha = 0)</param>
        /// <param name="b">The upper value (returned when alpha = 1)</param>
        /// <param name="alpha">The interpolation-factor</param>
        abstract Mix: a: float * b: float * alpha: float -> float
        abstract Instantiate: className: string -> obj option
        /// <summary>Provides a slice function that will work even on IE</summary>
        /// <param name="data">defines the array to slice</param>
        /// <param name="start">defines the start of the data (optional)</param>
        /// <param name="end">defines the end of the data (optional)</param>
        abstract Slice: data: 'T * ?start: float * ?``end``: float -> 'T
        abstract SetImmediate: action: (unit -> unit) -> unit
        abstract IsExponentOfTwo: value: float -> bool
        /// <summary>Find the next highest power of two.</summary>
        /// <param name="x">Number to start search from.</param>
        abstract CeilingPOT: x: float -> float
        /// <summary>Find the next lowest power of two.</summary>
        /// <param name="x">Number to start search from.</param>
        abstract FloorPOT: x: float -> float
        /// <summary>Find the nearest power of two.</summary>
        /// <param name="x">Number to start search from.</param>
        abstract NearestPOT: x: float -> float
        abstract GetExponentOfTwo: value: float * max: float * ?mode: float -> float
        abstract GetFilename: path: string -> string
        /// <summary>Extracts the "folder" part of a path (everything before the filename).</summary>
        /// <param name="uri">The URI to extract the info from</param>
        /// <param name="returnUnchangedIfNoSlash">Do not touch the URI if no slashes are present</param>
        abstract GetFolderPath: uri: string * ?returnUnchangedIfNoSlash: bool -> string
        abstract GetDOMTextContent: element: HTMLElement -> string
        abstract ToDegrees: angle: float -> float
        abstract ToRadians: angle: float -> float
        abstract EncodeArrayBufferTobase64: buffer: ArrayBuffer -> string
        abstract ExtractMinAndMaxIndexed: positions: FloatArray * indices: IndicesArray * indexStart: float * indexCount: float * ?bias: Nullable<Vector2> -> obj
        abstract ExtractMinAndMax: positions: FloatArray * start: float * count: float * ?bias: Nullable<Vector2> * ?stride: float -> obj
        abstract Vector2ArrayFeeder: array: U2<Array<Vector2>, Float32Array> -> (float -> Nullable<Vector2>)
        abstract ExtractMinAndMaxVector2: feeder: (float -> Vector2) * ?bias: Nullable<Vector2> -> obj
        abstract MakeArray: obj: obj option * ?allowsNullUndefined: bool -> Nullable<Array<obj option>>
        abstract GetPointerPrefix: unit -> string
        /// <param name="func">- the function to be called</param>
        /// <param name="requester">- the object that will request the next frame. Falls back to window.</param>
        abstract QueueNewFrame: func: (unit -> unit) * ?requester: obj option -> float
        abstract RequestFullscreen: element: HTMLElement -> unit
        abstract ExitFullscreen: unit -> unit
        abstract SetCorsBehavior: url: U2<string, ResizeArray<string>> * element: ToolsStaticSetCorsBehaviorElement -> unit
        abstract CleanUrl: url: string -> string
        abstract LoadImage: url: obj option * onLoad: (HTMLImageElement -> unit) * onError: (string -> obj option -> unit) * database: Nullable<Database> -> HTMLImageElement
        abstract LoadFile: url: string * onSuccess: (U2<string, ArrayBuffer> -> string -> unit) * ?onProgress: (obj option -> unit) * ?database: Database * ?useArrayBuffer: bool * ?onError: (XMLHttpRequest -> obj option -> unit) -> IFileRequest
        /// Load a script (identified by an url). When the url returns, the
        /// content of this file is added into a new script element, attached to the DOM (body element)
        abstract LoadScript: scriptUrl: string * onSuccess: (unit -> unit) * ?onError: (string -> obj option -> unit) -> unit
        abstract ReadFileAsDataURL: fileToLoad: Blob * callback: (obj option -> unit) * progressCallback: (ProgressEvent -> obj option) -> IFileRequest
        abstract ReadFile: fileToLoad: File * callback: (obj option -> unit) * ?progressCallBack: (ProgressEvent -> obj option) * ?useArrayBuffer: bool -> IFileRequest
        abstract FileAsURL: content: string -> string
        abstract Format: value: float * ?decimals: float -> string
        abstract CheckExtends: v: Vector3 * min: Vector3 * max: Vector3 -> unit
        abstract DeepCopy: source: obj option * destination: obj option * ?doNotCopyList: ResizeArray<string> * ?mustCopyList: ResizeArray<string> -> unit
        abstract IsEmpty: obj: obj option -> bool
        abstract RegisterTopRootEvents: events: ResizeArray<obj> -> unit
        abstract UnregisterTopRootEvents: events: ResizeArray<obj> -> unit
        abstract DumpFramebuffer: width: float * height: float * engine: Engine * ?successCallback: (string -> unit) * ?mimeType: string * ?fileName: string -> unit
        abstract EncodeScreenshotCanvasData: ?successCallback: (string -> unit) * ?mimeType: string * ?fileName: string -> unit
        abstract CreateScreenshot: engine: Engine * camera: Camera * size: obj option * ?successCallback: (string -> unit) * ?mimeType: string -> unit
        /// <summary>Generates an image screenshot from the specified camera.</summary>
        /// <param name="engine">The engine to use for rendering</param>
        /// <param name="camera">The camera to use for rendering</param>
        /// <param name="size">This parameter can be set to a single number or to an object with the
        /// following (optional) properties: precision, width, height. If a single number is passed,
        /// it will be used for both width and height. If an object is passed, the screenshot size
        /// will be derived from the parameters. The precision property is a multiplier allowing
        /// rendering at a higher or lower resolution.</param>
        /// <param name="successCallback">The callback receives a single parameter which contains the
        /// screenshot as a string of base64-encoded characters. This string can be assigned to the
        /// src parameter of an <img> to display it.</param>
        /// <param name="mimeType">The MIME type of the screenshot image (default: image/png).
        /// Check your browser for supported MIME types.</param>
        /// <param name="samples">Texture samples (default: 1)</param>
        /// <param name="antialiasing">Whether antialiasing should be turned on or not (default: false)</param>
        /// <param name="fileName">A name for for the downloaded file.</param>
        abstract CreateScreenshotUsingRenderTarget: engine: Engine * camera: Camera * size: obj option * ?successCallback: (string -> unit) * ?mimeType: string * ?samples: float * ?antialiasing: bool * ?fileName: string -> unit
        abstract ValidateXHRData: xhr: XMLHttpRequest * ?dataType: float -> bool
        /// Implementation from http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#answer-2117523
        /// Be aware Math.random() could cause collisions, but:
        /// "All but 6 of the 128 bits of the ID are randomly generated, which means that for any two ids, there's a 1 in 2^^122 (or 5.3x10^^36) chance they'll collide"
        abstract RandomId: unit -> string
        /// <summary>Test if the given uri is a base64 string.</summary>
        /// <param name="uri">The uri to test</param>
        abstract IsBase64: uri: string -> bool
        /// <summary>Decode the given base64 uri.</summary>
        /// <param name="uri">The uri to decode</param>
        abstract DecodeBase64: uri: string -> ArrayBuffer
        abstract _AddLogEntry: entry: obj -> unit
        abstract _FormatMessage: message: obj -> unit
        abstract _LogDisabled: message: obj -> unit
        abstract _LogEnabled: message: obj -> unit
        abstract _WarnDisabled: message: obj -> unit
        abstract _WarnEnabled: message: obj -> unit
        abstract _ErrorDisabled: message: obj -> unit
        abstract _ErrorEnabled: message: obj -> unit
        abstract ClearLogCache: unit -> unit
        abstract IsWindowObjectExist: unit -> bool
        abstract _StartPerformanceCounterDisabled: counterName: string * ?condition: bool -> unit
        abstract _EndPerformanceCounterDisabled: counterName: string * ?condition: bool -> unit
        abstract _StartUserMark: counterName: string * ?condition: bool -> unit
        abstract _EndUserMark: counterName: string * ?condition: bool -> unit
        abstract _StartPerformanceConsole: counterName: string * ?condition: bool -> unit
        abstract _EndPerformanceConsole: counterName: string * ?condition: bool -> unit
        /// <summary>This method will return the name of the class used to create the instance of the given object.
        /// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator.</summary>
        /// <param name="object">the object to get the class name from</param>
        abstract GetClassName: ``object``: obj option * ?isType: bool -> string
        abstract First: array: Array<'T> * predicate: ('T -> bool) -> Nullable<'T>
        /// <summary>This method will return the name of the full name of the class, including its owning module (if any).
        /// It will works only on Javascript basic data types (number, string, ...) and instance of class declared with the @className decorator or implementing a method getClassName():string (in which case the module won't be specified).</summary>
        /// <param name="object">the object to get the class name from</param>
        abstract getFullClassName: ``object``: obj option * ?isType: bool -> Nullable<string>
        /// <summary>This method can be used with hashCodeFromStream when your input is an array of values that are either: number, string, boolean or custom type implementing the getHashCode():number method.</summary>
        /// <param name="array"></param>
        abstract arrayOrStringFeeder: array: obj option -> (float -> float)
        /// <summary>Compute the hashCode of a stream of number
        /// To compute the HashCode on a string or an Array of data types implementing the getHashCode() method, use the arrayOrStringFeeder method.</summary>
        /// <param name="feeder">a callback that will be called until it returns null, each valid returned values will be used to compute the hash code.</param>
        abstract hashCodeFromStream: feeder: (float -> float) -> float
        /// <summary>Returns a promise that resolves after the given amount of time.</summary>
        /// <param name="delay">Number of milliseconds to delay</param>
        abstract DelayAsync: delay: float -> Promise<unit>

    type [<AllowNullLiteral>] ToolsStaticSetCorsBehaviorElement =
        abstract crossOrigin: string option with get, set

    /// This class is used to track a performance counter which is number based.
    /// The user has access to many properties which give statistics of different nature
    /// 
    /// The implementer can track two kinds of Performance Counter: time and count
    /// For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
    /// For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
    type [<AllowNullLiteral>] PerfCounter =
        abstract Enabled: bool with get, set
        /// Returns the smallest value ever
        abstract min: float
        /// Returns the biggest value ever
        abstract max: float
        /// Returns the average value since the performance counter is running
        abstract average: float
        /// Returns the average value of the last second the counter was monitored
        abstract lastSecAverage: float
        /// Returns the current value
        abstract current: float
        abstract total: float
        abstract count: float
        /// Call this method to start monitoring a new frame.
        /// This scenario is typically used when you accumulate monitoring time many times for a single frame, you call this method at the start of the frame, then beginMonitoring to start recording and endMonitoring(false) to accumulated the recorded time to the PerfCounter or addCount() to accumulate a monitored count.
        abstract fetchNewFrame: unit -> unit
        /// <summary>Call this method to monitor a count of something (e.g. mesh drawn in viewport count)</summary>
        /// <param name="newCount">the count value to add to the monitored count</param>
        /// <param name="fetchResult">true when it's the last time in the frame you add to the counter and you wish to update the statistics properties (min/max/average), false if you only want to update statistics.</param>
        abstract addCount: newCount: float * fetchResult: bool -> unit
        /// Start monitoring this performance counter
        abstract beginMonitoring: unit -> unit
        /// <summary>Compute the time lapsed since the previous beginMonitoring() call.</summary>
        /// <param name="newFrame">true by default to fetch the result and monitor a new frame, if false the time monitored will be added to the current frame counter</param>
        abstract endMonitoring: ?newFrame: bool -> unit
        abstract _fetchResult: unit -> unit
        abstract _startMonitoringTime: obj with get, set
        abstract _min: obj with get, set
        abstract _max: obj with get, set
        abstract _average: obj with get, set
        abstract _current: obj with get, set
        abstract _totalValueCount: obj with get, set
        abstract _totalAccumulated: obj with get, set
        abstract _lastSecAverage: obj with get, set
        abstract _lastSecAccumulated: obj with get, set
        abstract _lastSecTime: obj with get, set
        abstract _lastSecValueCount: obj with get, set

    /// This class is used to track a performance counter which is number based.
    /// The user has access to many properties which give statistics of different nature
    /// 
    /// The implementer can track two kinds of Performance Counter: time and count
    /// For time you can optionally call fetchNewFrame() to notify the start of a new frame to monitor, then call beginMonitoring() to start and endMonitoring() to record the lapsed time. endMonitoring takes a newFrame parameter for you to specify if the monitored time should be set for a new frame or accumulated to the current frame being monitored.
    /// For count you first have to call fetchNewFrame() to notify the start of a new frame to monitor, then call addCount() how many time required to increment the count value you monitor.
    type [<AllowNullLiteral>] PerfCounterStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PerfCounter

    /// An implementation of a loop for asynchronous functions.
    type [<AllowNullLiteral>] AsyncLoop =
        abstract iterations: float with get, set
        abstract _fn: obj with get, set
        abstract _successCallback: obj with get, set
        abstract index: float with get, set
        abstract _done: obj with get, set
        /// Execute the next iteration. Must be called after the last iteration was finished.
        abstract executeNext: unit -> unit
        /// Break the loop and run the success callback.
        abstract breakLoop: unit -> unit

    /// An implementation of a loop for asynchronous functions.
    type [<AllowNullLiteral>] AsyncLoopStatic =
        /// <summary>Constroctor.</summary>
        /// <param name="iterations">the number of iterations.</param>
        /// <param name="_fn">the function to run each iteration</param>
        /// <param name="_successCallback">the callback that will be called upon succesful execution</param>
        /// <param name="offset">starting offset.</param>
        [<Emit "new $0($1...)">] abstract Create: iterations: float * _fn: (AsyncLoop -> unit) * _successCallback: (unit -> unit) * ?offset: float -> AsyncLoop
        /// Helper function
        abstract Run: iterations: float * _fn: (AsyncLoop -> unit) * _successCallback: (unit -> unit) * ?offset: float -> AsyncLoop
        /// <summary>A for-loop that will run a given number of iterations synchronous and the rest async.</summary>
        /// <param name="iterations">total number of iterations</param>
        /// <param name="syncedIterations">number of synchronous iterations in each async iteration.</param>
        /// <param name="fn">the function to call each iteration.</param>
        /// <param name="callback">a success call back that will be called when iterating stops.</param>
        /// <param name="breakFunction">a break condition (optional)</param>
        /// <param name="timeout">timeout settings for the setTimeout function. default - 0.</param>
        abstract SyncAsyncForLoop: iterations: float * syncedIterations: float * fn: (float -> unit) * callback: (unit -> unit) * ?breakFunction: (unit -> bool) * ?timeout: float -> unit

    type [<RequireQualifiedAccess>] JoystickAxis =
        | X = 0
        | Y = 1
        | Z = 2

    type [<AllowNullLiteral>] VirtualJoystick =
        abstract reverseLeftRight: bool with get, set
        abstract reverseUpDown: bool with get, set
        abstract deltaPosition: Vector3 with get, set
        abstract pressed: bool with get, set
        abstract _globalJoystickIndex: obj with get, set
        abstract vjCanvas: obj with get, set
        abstract vjCanvasContext: obj with get, set
        abstract vjCanvasWidth: obj with get, set
        abstract vjCanvasHeight: obj with get, set
        abstract halfWidth: obj with get, set
        abstract _action: obj with get, set
        abstract _axisTargetedByLeftAndRight: obj with get, set
        abstract _axisTargetedByUpAndDown: obj with get, set
        abstract _joystickSensibility: obj with get, set
        abstract _inversedSensibility: obj with get, set
        abstract _joystickPointerID: obj with get, set
        abstract _joystickColor: obj with get, set
        abstract _joystickPointerPos: obj with get, set
        abstract _joystickPreviousPointerPos: obj with get, set
        abstract _joystickPointerStartPos: obj with get, set
        abstract _deltaJoystickVector: obj with get, set
        abstract _leftJoystick: obj with get, set
        abstract _touches: obj with get, set
        abstract _onPointerDownHandlerRef: obj with get, set
        abstract _onPointerMoveHandlerRef: obj with get, set
        abstract _onPointerUpHandlerRef: obj with get, set
        abstract _onResize: obj with get, set
        abstract setJoystickSensibility: newJoystickSensibility: float -> unit
        abstract _onPointerDown: e: obj -> unit
        abstract _onPointerMove: e: obj -> unit
        abstract _onPointerUp: e: obj -> unit
        /// <summary>Change the color of the virtual joystick</summary>
        /// <param name="newColor">a string that must be a CSS color value (like "red") or the hexa value (like "#FF0000")</param>
        abstract setJoystickColor: newColor: string -> unit
        abstract setActionOnTouch: action: (unit -> obj option) -> unit
        abstract setAxisForLeftRight: axis: JoystickAxis -> unit
        abstract setAxisForUpDown: axis: JoystickAxis -> unit
        abstract _drawVirtualJoystick: unit -> unit
        abstract releaseCanvas: unit -> unit

    type [<AllowNullLiteral>] VirtualJoystickStatic =
        [<Emit "new $0($1...)">] abstract Create: ?leftJoystick: bool -> VirtualJoystick

    /// Helper class to push actions to a pool of workers.
    type [<AllowNullLiteral>] WorkerPool =
        inherit IDisposable
        abstract _workerInfos: obj with get, set
        abstract _pendingActions: obj with get, set
        /// Terminates all workers and clears any pending actions.
        abstract dispose: unit -> unit
        /// <summary>Pushes an action to the worker pool. If all the workers are active, the action will be
        /// pended until a worker has completed its action.</summary>
        /// <param name="action">The action to perform. Call onComplete when the action is complete.</param>
        abstract push: action: (Worker -> (unit -> unit) -> unit) -> unit
        abstract _execute: workerInfo: obj * action: obj -> unit

    /// Helper class to push actions to a pool of workers.
    type [<AllowNullLiteral>] WorkerPoolStatic =
        /// <summary>Constructor</summary>
        /// <param name="workers">Array of workers to use for actions</param>
        [<Emit "new $0($1...)">] abstract Create: workers: Array<Worker> -> WorkerPool

    type [<AllowNullLiteral>] AutoRotationBehavior =
        inherit Behavior<ArcRotateCamera>
        abstract name: string
        abstract _zoomStopsAnimation: obj with get, set
        abstract _idleRotationSpeed: obj with get, set
        abstract _idleRotationWaitTime: obj with get, set
        abstract _idleRotationSpinupTime: obj with get, set
        /// Gets the flag that indicates if user zooming should stop animation.
        /// Sets the flag that indicates if user zooming should stop animation.
        abstract zoomStopsAnimation: bool with get, set
        /// Gets the default speed at which the camera rotates around the model.
        /// Sets the default speed at which the camera rotates around the model.
        abstract idleRotationSpeed: float with get, set
        /// Gets the time (milliseconds) to wait after user interaction before the camera starts rotating.
        /// Sets the time (in milliseconds) to wait after user interaction before the camera starts rotating.
        abstract idleRotationWaitTime: float with get, set
        /// Gets the time (milliseconds) to take to spin up to the full idle rotation speed.
        /// Sets the time (milliseconds) to take to spin up to the full idle rotation speed.
        abstract idleRotationSpinupTime: float with get, set
        /// Gets a value indicating if the camera is currently rotating because of this behavior
        abstract rotationInProgress: bool
        abstract _onPrePointerObservableObserver: obj with get, set
        abstract _onAfterCheckInputsObserver: obj with get, set
        abstract _attachedCamera: obj with get, set
        abstract _isPointerDown: obj with get, set
        abstract _lastFrameTime: obj with get, set
        abstract _lastInteractionTime: obj with get, set
        abstract _cameraRotationSpeed: obj with get, set
        abstract init: unit -> unit
        abstract attach: camera: ArcRotateCamera -> unit
        abstract detach: unit -> unit
        /// Returns true if user is scrolling.
        abstract _userIsZooming: unit -> unit
        abstract _lastFrameRadius: obj with get, set
        abstract _shouldAnimationStopForInteraction: unit -> unit
        /// Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
        abstract _applyUserInteraction: unit -> unit
        abstract _userIsMoving: unit -> unit

    type [<AllowNullLiteral>] AutoRotationBehaviorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> AutoRotationBehavior

    /// Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
    type [<AllowNullLiteral>] BouncingBehavior =
        inherit Behavior<ArcRotateCamera>
        abstract name: string
        /// The easing function used by animations
        abstract EasingFunction: BackEase with get, set
        /// The easing mode used by animations
        abstract EasingMode: float with get, set
        /// The duration of the animation, in milliseconds
        abstract transitionDuration: float with get, set
        /// Length of the distance animated by the transition when lower radius is reached
        abstract lowerRadiusTransitionRange: float with get, set
        /// Length of the distance animated by the transition when upper radius is reached
        abstract upperRadiusTransitionRange: float with get, set
        abstract _autoTransitionRange: obj with get, set
        /// Gets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
        /// Sets a value indicating if the lowerRadiusTransitionRange and upperRadiusTransitionRange are defined automatically
        /// Transition ranges will be set to 5% of the bounding box diagonal in world space
        abstract autoTransitionRange: bool with get, set
        abstract _attachedCamera: obj with get, set
        abstract _onAfterCheckInputsObserver: obj with get, set
        abstract _onMeshTargetChangedObserver: obj with get, set
        abstract init: unit -> unit
        abstract attach: camera: ArcRotateCamera -> unit
        abstract detach: unit -> unit
        abstract _radiusIsAnimating: obj with get, set
        abstract _radiusBounceTransition: obj with get, set
        abstract _animatables: obj with get, set
        abstract _cachedWheelPrecision: obj with get, set
        /// <summary>Checks if the camera radius is at the specified limit. Takes into account animation locks.</summary>
        /// <param name="radiusLimit">The limit to check against.</param>
        abstract _isRadiusAtLimit: radiusLimit: obj -> unit
        /// <summary>Applies an animation to the radius of the camera, extending by the radiusDelta.</summary>
        /// <param name="radiusDelta">The delta by which to animate to. Can be negative.</param>
        abstract _applyBoundRadiusAnimation: radiusDelta: obj -> unit
        /// Removes all animation locks. Allows new animations to be added to any of the camera properties.
        abstract _clearAnimationLocks: unit -> unit
        /// Stops and removes all animations that have been applied to the camera
        abstract stopAllAnimations: unit -> unit

    /// Add a bouncing effect to an ArcRotateCamera when reaching a specified minimum and maximum radius
    type [<AllowNullLiteral>] BouncingBehaviorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> BouncingBehavior

    type [<AllowNullLiteral>] FramingBehavior =
        inherit Behavior<ArcRotateCamera>
        abstract name: string
        abstract _mode: obj with get, set
        abstract _radiusScale: obj with get, set
        abstract _positionScale: obj with get, set
        abstract _defaultElevation: obj with get, set
        abstract _elevationReturnTime: obj with get, set
        abstract _elevationReturnWaitTime: obj with get, set
        abstract _zoomStopsAnimation: obj with get, set
        abstract _framingTime: obj with get, set
        /// The easing function used by animations
        abstract EasingFunction: ExponentialEase with get, set
        /// The easing mode used by animations
        abstract EasingMode: float with get, set
        /// Gets current mode used by the behavior.
        /// Sets the current mode used by the behavior
        abstract mode: float with get, set
        /// Gets the scale applied to the radius
        /// Sets the scale applied to the radius (1 by default)
        abstract radiusScale: float with get, set
        /// Gets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
        /// Sets the scale to apply on Y axis to position camera focus. 0.5 by default which means the center of the bounding box.
        abstract positionScale: float with get, set
        /// Gets the angle above/below the horizontal plane to return to when the return to default elevation idle
        /// behaviour is triggered, in radians.
        /// Sets the angle above/below the horizontal plane to return to when the return to default elevation idle
        /// behaviour is triggered, in radians.
        abstract defaultElevation: float with get, set
        /// Gets the time (in milliseconds) taken to return to the default beta position.
        /// Negative value indicates camera should not return to default.
        /// Sets the time (in milliseconds) taken to return to the default beta position.
        /// Negative value indicates camera should not return to default.
        abstract elevationReturnTime: float with get, set
        /// Gets the delay (in milliseconds) taken before the camera returns to the default beta position.
        /// Sets the delay (in milliseconds) taken before the camera returns to the default beta position.
        abstract elevationReturnWaitTime: float with get, set
        /// Gets the flag that indicates if user zooming should stop animation.
        /// Sets the flag that indicates if user zooming should stop animation.
        abstract zoomStopsAnimation: bool with get, set
        /// Gets the transition time when framing the mesh, in milliseconds
        /// Sets the transition time when framing the mesh, in milliseconds
        abstract framingTime: float with get, set
        abstract _onPrePointerObservableObserver: obj with get, set
        abstract _onAfterCheckInputsObserver: obj with get, set
        abstract _onMeshTargetChangedObserver: obj with get, set
        abstract _attachedCamera: obj with get, set
        abstract _isPointerDown: obj with get, set
        abstract _lastInteractionTime: obj with get, set
        abstract init: unit -> unit
        abstract attach: camera: ArcRotateCamera -> unit
        abstract detach: unit -> unit
        abstract _animatables: obj with get, set
        abstract _betaIsAnimating: obj with get, set
        abstract _betaTransition: obj with get, set
        abstract _radiusTransition: obj with get, set
        abstract _vectorTransition: obj with get, set
        /// <summary>Targets the given mesh and updates zoom level accordingly.</summary>
        /// <param name="mesh">The mesh to target.</param>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnMesh: mesh: AbstractMesh * ?focusOnOriginXZ: bool * ?onAnimationEnd: Nullable<(unit -> unit)> -> unit
        /// <summary>Targets the given mesh with its children and updates zoom level accordingly.</summary>
        /// <param name="mesh">The mesh to target.</param>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnMeshHierarchy: mesh: AbstractMesh * ?focusOnOriginXZ: bool * ?onAnimationEnd: Nullable<(unit -> unit)> -> unit
        /// <summary>Targets the given meshes with their children and updates zoom level accordingly.</summary>
        /// <param name="meshes">The mesh to target.</param>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnMeshesHierarchy: meshes: ResizeArray<AbstractMesh> * ?focusOnOriginXZ: bool * ?onAnimationEnd: Nullable<(unit -> unit)> -> unit
        /// <summary>Targets the given mesh and updates zoom level accordingly.</summary>
        /// <param name="focusOnOriginXZ">Determines if the camera should focus on 0 in the X and Z axis instead of the mesh</param>
        /// <param name="onAnimationEnd">Callback triggered at the end of the framing animation</param>
        abstract zoomOnBoundingInfo: minimumWorld: Vector3 * maximumWorld: Vector3 * ?focusOnOriginXZ: bool * ?onAnimationEnd: Nullable<(unit -> unit)> -> unit
        /// Calculates the lowest radius for the camera based on the bounding box of the mesh.
        abstract _calculateLowerRadiusFromModelBoundingSphere: minimumWorld: Vector3 * maximumWorld: Vector3 -> float
        /// Keeps the camera above the ground plane. If the user pulls the camera below the ground plane, the camera
        /// is automatically returned to its default position (expected to be above ground plane).
        abstract _maintainCameraAboveGround: unit -> unit
        /// Returns the frustum slope based on the canvas ratio and camera FOV
        abstract _getFrustumSlope: unit -> unit
        /// Removes all animation locks. Allows new animations to be added to any of the arcCamera properties.
        abstract _clearAnimationLocks: unit -> unit
        /// Applies any current user interaction to the camera. Takes into account maximum alpha rotation.
        abstract _applyUserInteraction: unit -> unit
        /// Stops and removes all animations that have been applied to the camera
        abstract stopAllAnimations: unit -> unit
        /// Gets a value indicating if the user is moving the camera
        abstract isUserIsMoving: bool
        /// The camera can move all the way towards the mesh.
        abstract IgnoreBoundsSizeMode: float with get, set
        /// The camera is not allowed to zoom closer to the mesh than the point at which the adjusted bounding sphere touches the frustum sides
        abstract FitFrustumSidesMode: float with get, set

    type [<AllowNullLiteral>] FramingBehaviorStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FramingBehavior

    type [<AllowNullLiteral>] ArcRotateCameraGamepadInput =
        inherit ICameraInput<ArcRotateCamera>
        abstract camera: ArcRotateCamera with get, set
        abstract gamepad: Nullable<Gamepad> with get, set
        abstract _onGamepadConnectedObserver: obj with get, set
        abstract _onGamepadDisconnectedObserver: obj with get, set
        abstract gamepadRotationSensibility: float with get, set
        abstract gamepadMoveSensibility: float with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract checkInputs: unit -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] ArcRotateCameraGamepadInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraGamepadInput

    type [<AllowNullLiteral>] ArcRotateCameraKeyboardMoveInput =
        inherit ICameraInput<ArcRotateCamera>
        abstract camera: ArcRotateCamera with get, set
        abstract _keys: obj with get, set
        abstract keysUp: ResizeArray<float> with get, set
        abstract keysDown: ResizeArray<float> with get, set
        abstract keysLeft: ResizeArray<float> with get, set
        abstract keysRight: ResizeArray<float> with get, set
        abstract keysReset: ResizeArray<float> with get, set
        abstract panningSensibility: float with get, set
        abstract zoomingSensibility: float with get, set
        abstract useAltToZoom: bool with get, set
        abstract _ctrlPressed: obj with get, set
        abstract _altPressed: obj with get, set
        abstract _onCanvasBlurObserver: obj with get, set
        abstract _onKeyboardObserver: obj with get, set
        abstract _engine: obj with get, set
        abstract _scene: obj with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract checkInputs: unit -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] ArcRotateCameraKeyboardMoveInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraKeyboardMoveInput

    type [<AllowNullLiteral>] ArcRotateCameraMouseWheelInput =
        inherit ICameraInput<ArcRotateCamera>
        abstract camera: ArcRotateCamera with get, set
        abstract _wheel: obj with get, set
        abstract _observer: obj with get, set
        abstract wheelPrecision: float with get, set
        /// wheelDeltaPercentage will be used instead of wheelPrecision if different from 0.
        /// It defines the percentage of current camera.radius to use as delta when wheel is used.
        abstract wheelDeltaPercentage: float with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] ArcRotateCameraMouseWheelInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraMouseWheelInput

    type [<AllowNullLiteral>] ArcRotateCameraPointersInput =
        inherit ICameraInput<ArcRotateCamera>
        abstract camera: ArcRotateCamera with get, set
        abstract buttons: ResizeArray<float> with get, set
        abstract angularSensibilityX: float with get, set
        abstract angularSensibilityY: float with get, set
        abstract pinchPrecision: float with get, set
        /// pinchDeltaPercentage will be used instead of pinchPrecision if different from 0.
        /// It defines the percentage of current camera.radius to use as delta when pinch zoom is used.
        abstract pinchDeltaPercentage: float with get, set
        abstract panningSensibility: float with get, set
        abstract multiTouchPanning: bool with get, set
        abstract multiTouchPanAndZoom: bool with get, set
        abstract _isPanClick: obj with get, set
        abstract pinchInwards: bool with get, set
        abstract _pointerInput: obj with get, set
        abstract _observer: obj with get, set
        abstract _onMouseMove: obj with get, set
        abstract _onGestureStart: obj with get, set
        abstract _onGesture: obj with get, set
        abstract _MSGestureHandler: obj with get, set
        abstract _onLostFocus: obj with get, set
        abstract _onContextMenu: obj with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] ArcRotateCameraPointersInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraPointersInput

    type [<AllowNullLiteral>] ArcRotateCameraVRDeviceOrientationInput =
        inherit ICameraInput<ArcRotateCamera>
        abstract camera: ArcRotateCamera with get, set
        abstract alphaCorrection: float with get, set
        abstract betaCorrection: float with get, set
        abstract gammaCorrection: float with get, set
        abstract _alpha: obj with get, set
        abstract _gamma: obj with get, set
        abstract _dirty: obj with get, set
        abstract _deviceOrientationHandler: obj with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract _onOrientationEvent: evt: DeviceOrientationEvent -> unit
        abstract checkInputs: unit -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] ArcRotateCameraVRDeviceOrientationInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> ArcRotateCameraVRDeviceOrientationInput

    /// Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
    /// Screen rotation is taken into account.
    type [<AllowNullLiteral>] FreeCameraDeviceOrientationInput =
        inherit ICameraInput<FreeCamera>
        abstract _camera: obj with get, set
        abstract _screenOrientationAngle: obj with get, set
        abstract _constantTranform: obj with get, set
        abstract _screenQuaternion: obj with get, set
        abstract _alpha: obj with get, set
        abstract _beta: obj with get, set
        abstract _gamma: obj with get, set
        abstract camera: FreeCamera with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract _orientationChanged: obj with get, set
        abstract _deviceOrientation: obj with get, set
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract checkInputs: unit -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    /// Takes information about the orientation of the device as reported by the deviceorientation event to orient the camera.
    /// Screen rotation is taken into account.
    type [<AllowNullLiteral>] FreeCameraDeviceOrientationInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraDeviceOrientationInput

    type [<AllowNullLiteral>] FreeCameraGamepadInput =
        inherit ICameraInput<FreeCamera>
        abstract camera: FreeCamera with get, set
        abstract gamepad: Nullable<Gamepad> with get, set
        abstract _onGamepadConnectedObserver: obj with get, set
        abstract _onGamepadDisconnectedObserver: obj with get, set
        abstract gamepadAngularSensibility: float with get, set
        abstract gamepadMoveSensibility: float with get, set
        abstract _cameraTransform: obj with get, set
        abstract _deltaTransform: obj with get, set
        abstract _vector3: obj with get, set
        abstract _vector2: obj with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract checkInputs: unit -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] FreeCameraGamepadInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraGamepadInput

    type [<AllowNullLiteral>] FreeCameraKeyboardMoveInput =
        inherit ICameraInput<FreeCamera>
        abstract camera: FreeCamera with get, set
        abstract _keys: obj with get, set
        abstract _onCanvasBlurObserver: obj with get, set
        abstract _onKeyboardObserver: obj with get, set
        abstract _engine: obj with get, set
        abstract _scene: obj with get, set
        abstract keysUp: ResizeArray<float> with get, set
        abstract keysDown: ResizeArray<float> with get, set
        abstract keysLeft: ResizeArray<float> with get, set
        abstract keysRight: ResizeArray<float> with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract checkInputs: unit -> unit
        abstract getClassName: unit -> string
        abstract _onLostFocus: e: FocusEvent -> unit
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] FreeCameraKeyboardMoveInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraKeyboardMoveInput

    type [<AllowNullLiteral>] FreeCameraMouseInput =
        inherit ICameraInput<FreeCamera>
        abstract touchEnabled: bool with get, set
        abstract camera: FreeCamera with get, set
        abstract buttons: ResizeArray<float> with get, set
        abstract angularSensibility: float with get, set
        abstract _pointerInput: obj with get, set
        abstract _onMouseMove: obj with get, set
        abstract _observer: obj with get, set
        abstract previousPosition: obj with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] FreeCameraMouseInputStatic =
        [<Emit "new $0($1...)">] abstract Create: ?touchEnabled: bool -> FreeCameraMouseInput

    type [<AllowNullLiteral>] FreeCameraTouchInput =
        inherit ICameraInput<FreeCamera>
        abstract camera: FreeCamera with get, set
        abstract _offsetX: obj with get, set
        abstract _offsetY: obj with get, set
        abstract _pointerPressed: obj with get, set
        abstract _pointerInput: obj with get, set
        abstract _observer: obj with get, set
        abstract _onLostFocus: obj with get, set
        abstract touchAngularSensibility: float with get, set
        abstract touchMoveSensibility: float with get, set
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract checkInputs: unit -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] FreeCameraTouchInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraTouchInput

    type [<AllowNullLiteral>] FreeCameraVirtualJoystickInput =
        inherit ICameraInput<FreeCamera>
        abstract camera: FreeCamera with get, set
        abstract _leftjoystick: obj with get, set
        abstract _rightjoystick: obj with get, set
        abstract getLeftJoystick: unit -> VirtualJoystick
        abstract getRightJoystick: unit -> VirtualJoystick
        abstract checkInputs: unit -> unit
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        abstract detachControl: element: Nullable<HTMLElement> -> unit
        abstract getClassName: unit -> string
        abstract getSimpleName: unit -> string

    type [<AllowNullLiteral>] FreeCameraVirtualJoystickInputStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> FreeCameraVirtualJoystickInput

    type [<AllowNullLiteral>] VRCameraMetrics =
        abstract hResolution: float with get, set
        abstract vResolution: float with get, set
        abstract hScreenSize: float with get, set
        abstract vScreenSize: float with get, set
        abstract vScreenCenter: float with get, set
        abstract eyeToScreenDistance: float with get, set
        abstract lensSeparationDistance: float with get, set
        abstract interpupillaryDistance: float with get, set
        abstract distortionK: ResizeArray<float> with get, set
        abstract chromaAbCorrection: ResizeArray<float> with get, set
        abstract postProcessScaleFactor: float with get, set
        abstract lensCenterOffset: float with get, set
        abstract compensateDistortion: bool with get, set
        abstract aspectRatio: float
        abstract aspectRatioFov: float
        abstract leftHMatrix: Matrix
        abstract rightHMatrix: Matrix
        abstract leftPreViewMatrix: Matrix
        abstract rightPreViewMatrix: Matrix

    type [<AllowNullLiteral>] VRCameraMetricsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> VRCameraMetrics
        abstract GetDefault: unit -> VRCameraMetrics

    type [<AllowNullLiteral>] VRDeviceOrientationFreeCamera =
        inherit DeviceOrientationCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] VRDeviceOrientationFreeCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?compensateDistortion: bool * ?vrCameraMetrics: VRCameraMetrics -> VRDeviceOrientationFreeCamera

    type [<AllowNullLiteral>] VRDeviceOrientationGamepadCamera =
        inherit VRDeviceOrientationFreeCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] VRDeviceOrientationGamepadCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?compensateDistortion: bool * ?vrCameraMetrics: VRCameraMetrics -> VRDeviceOrientationGamepadCamera

    type [<AllowNullLiteral>] VRDeviceOrientationArcRotateCamera =
        inherit ArcRotateCamera
        abstract getClassName: unit -> string

    type [<AllowNullLiteral>] VRDeviceOrientationArcRotateCameraStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * alpha: float * beta: float * radius: float * target: Vector3 * scene: Scene * ?compensateDistortion: bool * ?vrCameraMetrics: VRCameraMetrics -> VRDeviceOrientationArcRotateCamera

    /// Options to modify the vr teleportation behavior.
    type [<AllowNullLiteral>] VRTeleportationOptions =
        /// The name of the mesh which should be used as the teleportation floor. (default: null)
        abstract floorMeshName: string option with get, set
        /// A list of meshes to be used as the teleportation floor. (default: empty)
        abstract floorMeshes: ResizeArray<Mesh> option with get, set

    /// Options to modify the vr experience helper's behavior.
    type [<AllowNullLiteral>] VRExperienceHelperOptions =
        inherit WebVROptions
        /// Create a DeviceOrientationCamera to be used as your out of vr camera.
        abstract createDeviceOrientationCamera: bool option with get, set
        /// Create a VRDeviceOrientationFreeCamera to be used for VR when no external HMD is found.
        abstract createFallbackVRDeviceOrientationFreeCamera: bool option with get, set

    /// Helps to quickly add VR support to an existing scene.
    /// See http://doc.babylonjs.com/how_to/webvr_helper
    type [<AllowNullLiteral>] VRExperienceHelper =
        /// Options to modify the vr experience helper's behavior. 
        abstract webVROptions: VRExperienceHelperOptions with get, set
        abstract _scene: obj with get, set
        abstract _position: obj with get, set
        abstract _btnVR: obj with get, set
        abstract _btnVRDisplayed: obj with get, set
        abstract _webVRsupported: obj with get, set
        abstract _webVRready: obj with get, set
        abstract _webVRrequesting: obj with get, set
        abstract _webVRpresenting: obj with get, set
        abstract _fullscreenVRpresenting: obj with get, set
        abstract _canvas: obj with get, set
        abstract _webVRCamera: obj with get, set
        abstract _vrDeviceOrientationCamera: obj with get, set
        abstract _deviceOrientationCamera: obj with get, set
        abstract _existingCamera: obj with get, set
        abstract _onKeyDown: obj with get, set
        abstract _onVrDisplayPresentChange: obj with get, set
        abstract _onVRDisplayChanged: obj with get, set
        abstract _onVRRequestPresentStart: obj with get, set
        abstract _onVRRequestPresentComplete: obj with get, set
        /// Observable raised when entering VR.
        abstract onEnteringVRObservable: Observable<VRExperienceHelper> with get, set
        /// Observable raised when exiting VR.
        abstract onExitingVRObservable: Observable<VRExperienceHelper> with get, set
        /// Observable raised when controller mesh is loaded.
        abstract onControllerMeshLoadedObservable: Observable<WebVRController> with get, set
        /// Return this.onEnteringVRObservable
        /// Note: This one is for backward compatibility. Please use onEnteringVRObservable directly
        abstract onEnteringVR: Observable<VRExperienceHelper>
        /// Return this.onExitingVRObservable
        /// Note: This one is for backward compatibility. Please use onExitingVRObservable directly
        abstract onExitingVR: Observable<VRExperienceHelper>
        /// Return this.onControllerMeshLoadedObservable
        /// Note: This one is for backward compatibility. Please use onControllerMeshLoadedObservable directly
        abstract onControllerMeshLoaded: Observable<WebVRController>
        abstract _rayLength: obj with get, set
        abstract _useCustomVRButton: obj with get, set
        abstract _teleportationRequested: obj with get, set
        abstract _teleportActive: obj with get, set
        abstract _floorMeshName: obj with get, set
        abstract _floorMeshesCollection: obj with get, set
        abstract _rotationAllowed: obj with get, set
        abstract _teleportBackwardsVector: obj with get, set
        abstract _rotationRightAsked: obj with get, set
        abstract _rotationLeftAsked: obj with get, set
        abstract _teleportationTarget: obj with get, set
        abstract _isDefaultTeleportationTarget: obj with get, set
        abstract _postProcessMove: obj with get, set
        abstract _teleportationFillColor: obj with get, set
        abstract _teleportationBorderColor: obj with get, set
        abstract _rotationAngle: obj with get, set
        abstract _haloCenter: obj with get, set
        abstract _cameraGazer: obj with get, set
        abstract _padSensibilityUp: obj with get, set
        abstract _padSensibilityDown: obj with get, set
        abstract leftController: obj with get, set
        abstract rightController: obj with get, set
        /// Observable raised when a new mesh is selected based on meshSelectionPredicate
        abstract onNewMeshSelected: Observable<AbstractMesh> with get, set
        /// Observable raised when a new mesh is picked based on meshSelectionPredicate
        abstract onNewMeshPicked: Observable<PickingInfo> with get, set
        abstract _circleEase: obj with get, set
        /// Observable raised before camera teleportation
        abstract onBeforeCameraTeleport: Observable<Vector3> with get, set
        /// Observable raised after camera teleportation
        abstract onAfterCameraTeleport: Observable<Vector3> with get, set
        /// Observable raised when current selected mesh gets unselected
        abstract onSelectedMeshUnselected: Observable<AbstractMesh> with get, set
        abstract _raySelectionPredicate: obj with get, set
        /// To be optionaly changed by user to define custom ray selection
        abstract raySelectionPredicate: (AbstractMesh -> bool) with get, set
        /// To be optionaly changed by user to define custom selection logic (after ray selection)
        abstract meshSelectionPredicate: (AbstractMesh -> bool) with get, set
        /// Set teleportation enabled. If set to false camera teleportation will be disabled but camera rotation will be kept.
        abstract teleportationEnabled: bool with get, set
        abstract _defaultHeight: obj with get, set
        abstract _teleportationInitialized: obj with get, set
        abstract _interactionsEnabled: obj with get, set
        abstract _interactionsRequested: obj with get, set
        abstract _displayGaze: obj with get, set
        abstract _displayLaserPointer: obj with get, set
        /// The mesh used to display where the user is going to teleport.
        /// Sets the mesh to be used to display where the user is going to teleport.
        abstract teleportationTarget: Mesh with get, set
        /// The mesh used to display where the user is selecting,
        /// when set bakeCurrentTransformIntoVertices will be called on the mesh.
        /// See http://doc.babylonjs.com/resources/baking_transformations
        abstract gazeTrackerMesh: Mesh with get, set
        /// If the ray of the gaze should be displayed.
        /// Sets if the ray of the gaze should be displayed.
        abstract displayGaze: bool with get, set
        /// If the ray of the LaserPointer should be displayed.
        /// Sets if the ray of the LaserPointer should be displayed.
        abstract displayLaserPointer: bool with get, set
        /// The deviceOrientationCamera used as the camera when not in VR.
        abstract deviceOrientationCamera: Nullable<DeviceOrientationCamera>
        /// Based on the current WebVR support, returns the current VR camera used.
        abstract currentVRCamera: Nullable<Camera>
        /// The webVRCamera which is used when in VR.
        abstract webVRCamera: WebVRFreeCamera
        /// The deviceOrientationCamera that is used as a fallback when vr device is not connected.
        abstract vrDeviceOrientationCamera: Nullable<VRDeviceOrientationFreeCamera>
        abstract _teleportationRequestInitiated: obj
        abstract _onDefaultMeshLoaded: webVRController: obj -> unit
        abstract _onResize: obj with get, set
        abstract _onFullscreenChange: obj with get, set
        /// Gets a value indicating if we are currently in VR mode.
        abstract isInVRMode: bool
        abstract onVrDisplayPresentChange: unit -> unit
        abstract onVRDisplayChanged: eventArgs: obj -> unit
        abstract moveButtonToBottomRight: unit -> unit
        abstract displayVRButton: unit -> unit
        abstract updateButtonVisibility: unit -> unit
        /// Attempt to enter VR. If a headset is connected and ready, will request present on that.
        /// Otherwise, will use the fullscreen API.
        abstract enterVR: unit -> unit
        /// Attempt to exit VR, or fullscreen.
        abstract exitVR: unit -> unit
        /// The position of the vr experience helper.
        /// Sets the position of the vr experience helper.
        abstract position: Vector3 with get, set
        /// Enables controllers and user interactions suck as selecting and object or clicking on an object.
        abstract enableInteractions: unit -> unit
        abstract beforeRender: obj with get, set
        abstract _isTeleportationFloor: mesh: obj -> unit
        /// <summary>Adds a floor mesh to be used for teleportation.</summary>
        /// <param name="floorMesh">the mesh to be used for teleportation.</param>
        abstract addFloorMesh: floorMesh: Mesh -> unit
        /// <summary>Removes a floor mesh from being used for teleportation.</summary>
        /// <param name="floorMesh">the mesh to be removed.</param>
        abstract removeFloorMesh: floorMesh: Mesh -> unit
        /// <summary>Enables interactions and teleportation using the VR controllers and gaze.</summary>
        /// <param name="vrTeleportationOptions">options to modify teleportation behavior.</param>
        abstract enableTeleportation: ?vrTeleportationOptions: VRTeleportationOptions -> unit
        abstract _onNewGamepadConnected: obj with get, set
        abstract _tryEnableInteractionOnController: obj with get, set
        abstract _onNewGamepadDisconnected: obj with get, set
        abstract _enableInteractionOnController: controller: obj -> unit
        abstract _checkTeleportWithRay: stateObject: obj * gazer: obj -> unit
        abstract _checkRotate: stateObject: obj * gazer: obj -> unit
        abstract _checkTeleportBackwards: stateObject: obj * gazer: obj -> unit
        abstract _enableTeleportationOnController: controller: obj -> unit
        abstract _createTeleportationCircles: unit -> unit
        abstract _displayTeleportationTarget: unit -> unit
        abstract _hideTeleportationTarget: unit -> unit
        abstract _rotateCamera: right: obj -> unit
        abstract _moveTeleportationSelectorTo: hit: obj * gazer: obj -> unit
        abstract _workingVector: obj with get, set
        abstract _workingQuaternion: obj with get, set
        abstract _workingMatrix: obj with get, set
        abstract _teleportCamera: location: obj -> unit
        abstract _castRayAndSelectObject: gazer: obj -> unit
        abstract _notifySelectedMeshUnselected: mesh: obj -> unit
        /// <summary>Sets the color of the laser ray from the vr controllers.</summary>
        /// <param name="color">new color for the ray.</param>
        abstract changeLaserColor: color: Color3 -> unit
        /// <summary>Sets the color of the ray from the vr headsets gaze.</summary>
        /// <param name="color">new color for the ray.</param>
        abstract changeGazeColor: color: Color3 -> unit
        /// Exits VR and disposes of the vr experience helper
        abstract dispose: unit -> unit
        /// Gets the name of the VRExperienceHelper class
        abstract getClassName: unit -> string

    /// Helps to quickly add VR support to an existing scene.
    /// See http://doc.babylonjs.com/how_to/webvr_helper
    type [<AllowNullLiteral>] VRExperienceHelperStatic =
        /// <summary>Instantiates a VRExperienceHelper.
        /// Helps to quickly add VR support to an existing scene.</summary>
        /// <param name="scene">The scene the VRExperienceHelper belongs to.</param>
        /// <param name="webVROptions">Options to modify the vr experience helper's behavior.</param>
        [<Emit "new $0($1...)">] abstract Create: scene: Scene * ?webVROptions: VRExperienceHelperOptions -> VRExperienceHelper

    /// This is a copy of VRPose. See https://developer.mozilla.org/en-US/docs/Web/API/VRPose
    /// IMPORTANT!! The data is right-hand data.
    type [<AllowNullLiteral>] DevicePose =
        /// The position of the device, values in array are [x,y,z].
        abstract position: Nullable<Float32Array>
        /// The linearVelocity of the device, values in array are [x,y,z].
        abstract linearVelocity: Nullable<Float32Array>
        /// The linearAcceleration of the device, values in array are [x,y,z].
        abstract linearAcceleration: Nullable<Float32Array>
        /// The orientation of the device in a quaternion array, values in array are [x,y,z,w].
        abstract orientation: Nullable<Float32Array>
        /// The angularVelocity of the device, values in array are [x,y,z].
        abstract angularVelocity: Nullable<Float32Array>
        /// The angularAcceleration of the device, values in array are [x,y,z].
        abstract angularAcceleration: Nullable<Float32Array>

    /// Interface representing a pose controlled object in Babylon.
    /// A pose controlled object has both regular pose values as well as pose values
    /// from an external device such as a VR head mounted display
    type [<AllowNullLiteral>] PoseControlled =
        /// The position of the object in babylon space.
        abstract position: Vector3 with get, set
        /// The rotation quaternion of the object in babylon space.
        abstract rotationQuaternion: Quaternion with get, set
        /// The position of the device in babylon space.
        abstract devicePosition: Vector3 option with get, set
        /// The rotation quaternion of the device in babylon space.
        abstract deviceRotationQuaternion: Quaternion with get, set
        /// The raw pose coming from the device.
        abstract rawPose: Nullable<DevicePose> with get, set
        /// The scale of the device to be used when translating from device space to babylon space.
        abstract deviceScaleFactor: float with get, set
        /// <summary>Updates the poseControlled values based on the input device pose.</summary>
        /// <param name="poseData">the pose data to update the object with</param>
        abstract updateFromDevice: poseData: DevicePose -> unit

    /// Set of options to customize the webVRCamera
    type [<AllowNullLiteral>] WebVROptions =
        /// Sets if the webVR camera should be tracked to the vrDevice. (default: true)
        abstract trackPosition: bool option with get, set
        /// Sets the scale of the vrDevice in babylon space. (default: 1)
        abstract positionScale: float option with get, set
        /// If there are more than one VRDisplays, this will choose the display matching this name. (default: pick first vrDisplay)
        abstract displayName: string option with get, set
        /// Should the native controller meshes be initialized. (default: true)
        abstract controllerMeshes: bool option with get, set
        /// Creating a default HemiLight only on controllers. (default: true)
        abstract defaultLightingOnControllers: bool option with get, set
        /// If you don't want to use the default VR button of the helper. (default: false)
        abstract useCustomVRButton: bool option with get, set
        /// If you'd like to provide your own button to the VRHelper. (default: standard babylon vr button)
        abstract customVRButton: HTMLButtonElement option with get, set
        /// To change the length of the ray for gaze/controllers. Will be scaled by positionScale. (default: 100)
        abstract rayLength: float option with get, set
        /// To change the default offset from the ground to account for user's height in meters. Will be scaled by positionScale. (default: 1.7)
        abstract defaultHeight: float option with get, set

    /// This represents a WebVR camera.
    /// The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
    type [<AllowNullLiteral>] WebVRFreeCamera =
        inherit FreeCamera
        inherit PoseControlled
        abstract webVROptions: obj with get, set
        /// The vrDisplay tied to the camera. See https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay
        abstract _vrDevice: obj option with get, set
        /// The rawPose of the vrDevice.
        abstract rawPose: Nullable<DevicePose> with get, set
        abstract _onVREnabled: obj with get, set
        abstract _specsVersion: obj with get, set
        abstract _attached: obj with get, set
        abstract _frameData: obj with get, set
        abstract _descendants: Array<Node> with get, set
        abstract _deviceRoomPosition: obj with get, set
        abstract _deviceRoomRotationQuaternion: obj with get, set
        abstract _standingMatrix: obj with get, set
        /// Represents device position in babylon space.
        abstract devicePosition: Vector3 with get, set
        /// Represents device rotation in babylon space.
        abstract deviceRotationQuaternion: Quaternion with get, set
        /// The scale of the device to be used when translating from device space to babylon space.
        abstract deviceScaleFactor: float with get, set
        abstract _deviceToWorld: obj with get, set
        abstract _worldToDevice: obj with get, set
        /// References to the webVR controllers for the vrDevice.
        abstract controllers: Array<WebVRController> with get, set
        /// Emits an event when a controller is attached.
        abstract onControllersAttachedObservable: Observable<ResizeArray<WebVRController>> with get, set
        /// Emits an event when a controller's mesh has been loaded;
        abstract onControllerMeshLoadedObservable: Observable<WebVRController> with get, set
        /// If the rig cameras be used as parent instead of this camera.
        abstract rigParenting: bool with get, set
        abstract _lightOnControllers: obj with get, set
        abstract _defaultHeight: obj option with get, set
        /// Gets the device distance from the ground in meters.
        abstract deviceDistanceToRoomGround: unit -> float
        /// <summary>Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.</summary>
        /// <param name="callback">will be called when the standing matrix is set. Callback parameter is if the standing matrix is supported.</param>
        abstract useStandingMatrix: ?callback: (bool -> unit) -> unit
        /// Enables the standing matrix when supported. This can be used to position the user's view the correct height from the ground.
        abstract useStandingMatrixAsync: unit -> Promise<bool>
        /// Disposes the camera
        abstract dispose: unit -> unit
        /// <summary>Gets a vrController by name.</summary>
        /// <param name="name">The name of the controller to retreive</param>
        abstract getControllerByName: name: string -> Nullable<WebVRController>
        abstract _leftController: obj with get, set
        /// The controller corrisponding to the users left hand.
        abstract leftController: Nullable<WebVRController>
        abstract _rightController: obj with get, set
        /// The controller corrisponding to the users right hand.
        abstract rightController: Nullable<WebVRController>
        /// <summary>Casts a ray forward from the vrCamera's gaze.</summary>
        /// <param name="length">Length of the ray (default: 100)</param>
        abstract getForwardRay: ?length: float -> Ray
        /// Updates the camera based on device's frame data
        abstract _checkInputs: unit -> unit
        /// <summary>Updates the poseControlled values based on the input device pose.</summary>
        /// <param name="poseData">Pose coming from the device</param>
        abstract updateFromDevice: poseData: DevicePose -> unit
        /// <summary>WebVR's attach control will start broadcasting frames to the device.
        /// Note that in certain browsers (chrome for example) this function must be called
        /// within a user-interaction callback. Example:
        /// <pre> scene.onPointerDown = function() { camera.attachControl(canvas); }</pre></summary>
        /// <param name="element">html element to attach the vrDevice to</param>
        /// <param name="noPreventDefault">prevent the default html element operation when attaching the vrDevice</param>
        abstract attachControl: element: HTMLElement * ?noPreventDefault: bool -> unit
        /// <summary>Detaches the camera from the html element and disables VR</summary>
        /// <param name="element">html element to detach from</param>
        abstract detachControl: element: HTMLElement -> unit
        abstract getClassName: unit -> string
        /// Calls resetPose on the vrDisplay
        /// See: https://developer.mozilla.org/en-US/docs/Web/API/VRDisplay/resetPose
        abstract resetToCurrentRotation: unit -> unit
        /// Updates the rig cameras (left and right eye)
        abstract _updateRigCameras: unit -> unit
        abstract _workingVector: obj with get, set
        abstract _oneVector: obj with get, set
        abstract _workingMatrix: obj with get, set
        abstract updateCacheCalled: obj with get, set
        /// <summary>Updates the cached values of the camera</summary>
        /// <param name="ignoreParentClass">ignores updating the parent class's cache (default: false)</param>
        abstract _updateCache: ?ignoreParentClass: bool -> unit
        /// Updates the current device position and rotation in the babylon world
        abstract update: unit -> unit
        /// Gets the view matrix of this camera (Always set to identity as left and right eye cameras contain the actual view matrix)
        abstract _getViewMatrix: unit -> Matrix
        /// This function is called by the two RIG cameras.
        /// 'this' is the left or right camera (and NOT (!!!) the WebVRFreeCamera instance)
        abstract _getWebVRViewMatrix: unit -> Matrix
        abstract _getWebVRProjectionMatrix: unit -> Matrix
        abstract _onGamepadConnectedObserver: obj with get, set
        abstract _onGamepadDisconnectedObserver: obj with get, set
        /// Initializes the controllers and their meshes
        abstract initControllers: unit -> unit

    /// This represents a WebVR camera.
    /// The WebVR camera is Babylon's simple interface to interaction with Windows Mixed Reality, HTC Vive and Oculus Rift.
    type [<AllowNullLiteral>] WebVRFreeCameraStatic =
        /// <summary>Instantiates a WebVRFreeCamera.</summary>
        /// <param name="name">The name of the WebVRFreeCamera</param>
        /// <param name="position">The starting anchor position for the camera</param>
        /// <param name="scene">The scene the camera belongs to</param>
        /// <param name="webVROptions">a set of customizable options for the webVRCamera</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * position: Vector3 * scene: Scene * ?webVROptions: WebVROptions -> WebVRFreeCamera

    type [<AllowNullLiteral>] IOctreeContainer<'T> =
        abstract blocks: Array<OctreeBlock<'T>> with get, set

    type [<AllowNullLiteral>] Octree<'T> =
        abstract maxDepth: float with get, set
        abstract blocks: Array<OctreeBlock<'T>> with get, set
        abstract dynamicContent: ResizeArray<'T> with get, set
        abstract _maxBlockCapacity: obj with get, set
        abstract _selectionContent: obj with get, set
        abstract _creationFunc: obj with get, set
        abstract update: worldMin: Vector3 * worldMax: Vector3 * entries: ResizeArray<'T> -> unit
        abstract addMesh: entry: 'T -> unit
        abstract select: frustumPlanes: ResizeArray<Plane> * ?allowDuplicate: bool -> SmartArray<'T>
        abstract intersects: sphereCenter: Vector3 * sphereRadius: float * ?allowDuplicate: bool -> SmartArray<'T>
        abstract intersectsRay: ray: Ray -> SmartArray<'T>
        abstract CreationFuncForMeshes: (AbstractMesh -> OctreeBlock<AbstractMesh> -> unit) with get, set
        abstract CreationFuncForSubMeshes: (SubMesh -> OctreeBlock<SubMesh> -> unit) with get, set

    type [<AllowNullLiteral>] OctreeStatic =
        [<Emit "new $0($1...)">] abstract Create: creationFunc: ('T -> OctreeBlock<'T> -> unit) * ?maxBlockCapacity: float * ?maxDepth: float -> Octree<'T>
        abstract _CreateBlocks: worldMin: Vector3 * worldMax: Vector3 * entries: ResizeArray<'T> * maxBlockCapacity: float * currentDepth: float * maxDepth: float * target: IOctreeContainer<'T> * creationFunc: ('T -> OctreeBlock<'T> -> unit) -> unit

    type [<AllowNullLiteral>] OctreeBlock<'T> =
        abstract entries: ResizeArray<'T> with get, set
        abstract blocks: Array<OctreeBlock<'T>> with get, set
        abstract _depth: obj with get, set
        abstract _maxDepth: obj with get, set
        abstract _capacity: obj with get, set
        abstract _minPoint: obj with get, set
        abstract _maxPoint: obj with get, set
        abstract _boundingVectors: obj with get, set
        abstract _creationFunc: obj with get, set
        abstract capacity: float
        abstract minPoint: Vector3
        abstract maxPoint: Vector3
        abstract addEntry: entry: 'T -> unit
        abstract addEntries: entries: ResizeArray<'T> -> unit
        abstract select: frustumPlanes: ResizeArray<Plane> * selection: SmartArrayNoDuplicate<'T> * ?allowDuplicate: bool -> unit
        abstract intersects: sphereCenter: Vector3 * sphereRadius: float * selection: SmartArrayNoDuplicate<'T> * ?allowDuplicate: bool -> unit
        abstract intersectsRay: ray: Ray * selection: SmartArrayNoDuplicate<'T> -> unit
        abstract createInnerBlocks: unit -> unit

    type [<AllowNullLiteral>] OctreeBlockStatic =
        [<Emit "new $0($1...)">] abstract Create: minPoint: Vector3 * maxPoint: Vector3 * capacity: float * depth: float * maxDepth: float * creationFunc: ('T -> OctreeBlock<'T> -> unit) -> OctreeBlock<'T>

    /// Google Daydream controller
    type [<AllowNullLiteral>] DaydreamController =
        inherit WebVRController
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the controller model.
        abstract MODEL_FILENAME: string with get, set
        /// Gamepad Id prefix used to identify Daydream Controller.
        abstract GAMEPAD_ID_PREFIX: string
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Google Daydream controller
    type [<AllowNullLiteral>] DaydreamControllerStatic =
        /// <summary>Creates a new DaydreamController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> DaydreamController

    /// Gear VR Controller
    type [<AllowNullLiteral>] GearVRController =
        inherit WebVRController
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the controller model.
        abstract MODEL_FILENAME: string with get, set
        /// Gamepad Id prefix used to identify this controller.
        abstract GAMEPAD_ID_PREFIX: string
        abstract _buttonIndexToObservableNameMap: obj
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Gear VR Controller
    type [<AllowNullLiteral>] GearVRControllerStatic =
        /// <summary>Creates a new GearVRController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> GearVRController

    /// Generic Controller
    type [<AllowNullLiteral>] GenericController =
        inherit WebVRController
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string
        /// File name for the controller model.
        abstract MODEL_FILENAME: string
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Generic Controller
    type [<AllowNullLiteral>] GenericControllerStatic =
        /// <summary>Creates a new GenericController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> GenericController

    /// Oculus Touch Controller
    type [<AllowNullLiteral>] OculusTouchController =
        inherit WebVRController
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the left controller model.
        abstract MODEL_LEFT_FILENAME: string with get, set
        /// File name for the right controller model.
        abstract MODEL_RIGHT_FILENAME: string with get, set
        /// Fired when the secondary trigger on this controller is modified
        abstract onSecondaryTriggerStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the thumb rest on this controller is modified
        abstract onThumbRestChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// Fired when the A button on this controller is modified
        abstract onAButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the B button on this controller is modified
        abstract onBButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the X button on this controller is modified
        abstract onXButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the Y button on this controller is modified
        abstract onYButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// <summary>Called once for each button that changed state since the last frame
        /// 0) thumb stick (touch, press, value = pressed (0,1)). value is in this.leftStick
        /// 1) index trigger (touch (?), press (only when value > 0.1), value 0 to 1)
        /// 2) secondary trigger (same)
        /// 3) A (right) X (left), touch, pressed = value
        /// 4) B / Y
        /// 5) thumb rest</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Oculus Touch Controller
    type [<AllowNullLiteral>] OculusTouchControllerStatic =
        /// <summary>Creates a new OculusTouchController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> OculusTouchController

    type [<RequireQualifiedAccess>] PoseEnabledControllerType =
        | VIVE = 0
        | OCULUS = 1
        | WINDOWS = 2
        | GEAR_VR = 3
        | DAYDREAM = 4
        | GENERIC = 5

    /// Defines the MutableGamepadButton interface for the state of a gamepad button
    type [<AllowNullLiteral>] MutableGamepadButton =
        /// Value of the button/trigger
        abstract value: float with get, set
        /// If the button/trigger is currently touched
        abstract touched: bool with get, set
        /// If the button/trigger is currently pressed
        abstract pressed: bool with get, set

    /// Defines the ExtendedGamepadButton interface for a gamepad button which includes state provided by a pose controller
    type [<AllowNullLiteral>] ExtendedGamepadButton =
        inherit GamepadButton
        /// If the button/trigger is currently pressed
        abstract pressed: bool
        /// If the button/trigger is currently touched
        abstract touched: bool
        /// Value of the button/trigger
        abstract value: float

    /// Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
    type [<AllowNullLiteral>] PoseEnabledControllerHelper =
        interface end

    /// Defines the PoseEnabledControllerHelper object that is used initialize a gamepad as the controller type it is specified as (eg. windows mixed reality controller)
    type [<AllowNullLiteral>] PoseEnabledControllerHelperStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PoseEnabledControllerHelper
        /// <summary>Initializes a gamepad as the controller type it is specified as (eg. windows mixed reality controller)</summary>
        /// <param name="vrGamepad">the gamepad to initialized</param>
        abstract InitiateController: vrGamepad: obj option -> U6<OculusTouchController, WindowsMotionController, ViveController, GearVRController, DaydreamController, GenericController>

    /// Defines the PoseEnabledController object that contains state of a vr capable controller
    type [<AllowNullLiteral>] PoseEnabledController =
        inherit Gamepad
        inherit PoseControlled
        abstract _deviceRoomPosition: obj with get, set
        abstract _deviceRoomRotationQuaternion: obj with get, set
        /// The device position in babylon space
        abstract devicePosition: Vector3 with get, set
        /// The device rotation in babylon space
        abstract deviceRotationQuaternion: Quaternion with get, set
        /// The scale factor of the device in babylon space
        abstract deviceScaleFactor: float with get, set
        /// (Likely devicePosition should be used instead) The device position in its room space
        abstract position: Vector3 with get, set
        /// (Likely deviceRotationQuaternion should be used instead) The device rotation in its room space
        abstract rotationQuaternion: Quaternion with get, set
        /// The type of controller (Eg. Windows mixed reality)
        abstract controllerType: PoseEnabledControllerType with get, set
        abstract _calculatedPosition: obj with get, set
        abstract _calculatedRotation: obj with get, set
        /// The raw pose from the device
        abstract rawPose: DevicePose with get, set
        /// Internal, the mesh attached to the controller
        abstract _mesh: Nullable<AbstractMesh> with get, set
        abstract _poseControlledCamera: obj with get, set
        abstract _leftHandSystemQuaternion: obj with get, set
        /// Internal, matrix used to convert room space to babylon space
        abstract _deviceToWorld: Matrix with get, set
        /// Node to be used when casting a ray from the controller
        abstract _pointingPoseNode: Nullable<AbstractMesh> with get, set
        /// Name of the child mesh that can be used to cast a ray from the controller
        abstract POINTING_POSE: string
        abstract _workingMatrix: obj with get, set
        /// Updates the state of the pose enbaled controller and mesh based on the current position and rotation of the controller
        abstract update: unit -> unit
        /// <summary>Updates the state of the pose enbaled controller based on the raw pose data from the device</summary>
        /// <param name="poseData">raw pose fromthe device</param>
        abstract updateFromDevice: poseData: DevicePose -> unit
        /// <summary>Attaches a mesh to the controller</summary>
        /// <param name="mesh">the mesh to be attached</param>
        abstract attachToMesh: mesh: AbstractMesh -> unit
        /// <summary>Attaches the controllers mesh to a camera</summary>
        /// <param name="camera">the camera the mesh should be attached to</param>
        abstract attachToPoseControlledCamera: camera: TargetCamera -> unit
        /// Disposes of the controller
        abstract dispose: unit -> unit
        /// The mesh that is attached to the controller
        abstract mesh: Nullable<AbstractMesh>
        /// <summary>Gets the ray of the controller in the direction the controller is pointing</summary>
        /// <param name="length">the length the resulting ray should be</param>
        abstract getForwardRay: ?length: float -> Ray

    /// Defines the PoseEnabledController object that contains state of a vr capable controller
    type [<AllowNullLiteral>] PoseEnabledControllerStatic =
        /// <summary>Creates a new PoseEnabledController from a gamepad</summary>
        /// <param name="browserGamepad">the gamepad that the PoseEnabledController should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: browserGamepad: obj option -> PoseEnabledController

    /// Vive Controller
    type [<AllowNullLiteral>] ViveController =
        inherit WebVRController
        /// Base Url for the controller model.
        abstract MODEL_BASE_URL: string with get, set
        /// File name for the controller model.
        abstract MODEL_FILENAME: string with get, set
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        /// Fired when the left button on this controller is modified
        abstract onLeftButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the right button on this controller is modified
        abstract onRightButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the menu button on this controller is modified
        abstract onMenuButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// <summary>Called once for each button that changed state since the last frame
        /// Vive mapping:
        /// 0: touchpad
        /// 1: trigger
        /// 2: left AND right buttons
        /// 3: menu button</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit

    /// Vive Controller
    type [<AllowNullLiteral>] ViveControllerStatic =
        /// <summary>Creates a new ViveController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> ViveController

    /// Defines the WebVRController object that represents controllers tracked in 3D space
    type [<AllowNullLiteral>] WebVRController =
        inherit PoseEnabledController
        /// Internal, the default controller model for the controller
        abstract _defaultModel: AbstractMesh with get, set
        /// Fired when the trigger state has changed
        abstract onTriggerStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the main button state has changed
        abstract onMainButtonStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the secondary button state has changed
        abstract onSecondaryButtonStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the pad state has changed
        abstract onPadStateChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when controllers stick values have changed
        abstract onPadValuesChangedObservable: Observable<StickValues> with get, set
        /// Array of button availible on the controller
        abstract _buttons: Array<MutableGamepadButton> with get, set
        abstract _onButtonStateChange: obj with get, set
        /// <summary>Fired when a controller button's state has changed</summary>
        /// <param name="callback">the callback containing the button that was modified</param>
        abstract onButtonStateChange: callback: (float -> float -> ExtendedGamepadButton -> unit) -> unit
        /// X and Y axis corrisponding to the controllers joystick
        abstract pad: StickValues with get, set
        /// 'left' or 'right', see https://w3c.github.io/gamepad/extensions.html#gamepadhand-enum
        abstract hand: string with get, set
        /// The default controller model for the controller
        abstract defaultModel: AbstractMesh
        /// Updates the state of the controller and mesh based on the current position and rotation of the controller
        abstract update: unit -> unit
        /// Function to be called when a button is modified
        abstract _handleButtonChange: buttonIdx: float * value: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit
        /// <summary>Loads a mesh and attaches it to the controller</summary>
        /// <param name="scene">the scene the mesh should be added to</param>
        /// <param name="meshLoaded">callback for when the mesh has been loaded</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) -> unit
        abstract _setButtonValue: newState: obj * currentState: obj * buttonIndex: obj -> unit
        abstract _changes: obj with get, set
        abstract _checkChanges: newState: obj * currentState: obj -> unit
        /// Disposes of th webVRCOntroller
        abstract dispose: unit -> unit

    /// Defines the WebVRController object that represents controllers tracked in 3D space
    type [<AllowNullLiteral>] WebVRControllerStatic =
        /// <summary>Creates a new WebVRController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the WebVRController should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> WebVRController

    /// Defines the WindowsMotionController object that the state of the windows motion controller
    type [<AllowNullLiteral>] WindowsMotionController =
        inherit WebVRController
        /// The base url used to load the left and right controller models
        abstract MODEL_BASE_URL: string with get, set
        /// The name of the left controller model file
        abstract MODEL_LEFT_FILENAME: string with get, set
        /// The name of the right controller model file
        abstract MODEL_RIGHT_FILENAME: string with get, set
        /// The controller name prefix for this controller type
        abstract GAMEPAD_ID_PREFIX: string
        /// The controller id pattern for this controller type
        abstract GAMEPAD_ID_PATTERN: obj
        abstract _loadedMeshInfo: obj with get, set
        abstract _mapping: obj
        /// Fired when the trackpad on this controller is clicked
        abstract onTrackpadChangedObservable: Observable<ExtendedGamepadButton> with get, set
        /// Fired when the trackpad on this controller is modified
        abstract onTrackpadValuesChangedObservable: Observable<StickValues> with get, set
        /// The current x and y values of this controller's trackpad
        abstract trackpad: StickValues with get, set
        /// Fired when the trigger on this controller is modified
        abstract onTriggerButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the menu button on this controller is modified
        abstract onMenuButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the grip button on this controller is modified
        abstract onGripButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the thumbstick button on this controller is modified
        abstract onThumbstickButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the touchpad button on this controller is modified
        abstract onTouchpadButtonStateChangedObservable: Observable<ExtendedGamepadButton>
        /// Fired when the touchpad values on this controller are modified
        abstract onTouchpadValuesChangedObservable: Observable<StickValues>
        /// Called once per frame by the engine.
        abstract update: unit -> unit
        /// <summary>Called once for each button that changed state since the last frame</summary>
        /// <param name="buttonIdx">Which button index changed</param>
        /// <param name="state">New state of the button</param>
        /// <param name="changes">Which properties on the state changed since last frame</param>
        abstract _handleButtonChange: buttonIdx: float * state: ExtendedGamepadButton * changes: GamepadButtonChanges -> unit
        /// <summary>Moves the buttons on the controller mesh based on their current state</summary>
        /// <param name="buttonName">the name of the button to move</param>
        /// <param name="buttonValue">the value of the button which determines the buttons new position</param>
        abstract _lerpButtonTransform: buttonName: string * buttonValue: float -> unit
        /// <summary>Moves the axis on the controller mesh based on its current state</summary>
        /// <param name="axis">the index of the axis</param>
        /// <param name="axisValue">the value of the axis which determines the meshes new position</param>
        abstract _lerpAxisTransform: axis: float * axisValue: float -> unit
        /// <summary>Implements abstract method on WebVRController class, loading controller meshes and calling this.attachToMesh if successful.</summary>
        /// <param name="scene">scene in which to add meshes</param>
        /// <param name="meshLoaded">optional callback function that will be called if the mesh loads successfully.</param>
        abstract initControllerMesh: scene: Scene * ?meshLoaded: (AbstractMesh -> unit) * ?forceDefault: bool -> unit
        /// <summary>Takes a list of meshes (as loaded from the glTF file) and finds the root node, as well as nodes that
        /// can be transformed by button presses and axes values, based on this._mapping.</summary>
        /// <param name="scene">scene in which the meshes exist</param>
        /// <param name="meshes">list of meshes that make up the controller model to process</param>
        abstract processModel: scene: obj * meshes: obj -> unit
        abstract createMeshInfo: rootNode: obj -> unit
        /// <summary>Gets the ray of the controller in the direction the controller is pointing</summary>
        /// <param name="length">the length the resulting ray should be</param>
        abstract getForwardRay: ?length: float -> Ray
        /// Disposes of the controller
        abstract dispose: unit -> unit

    /// Defines the WindowsMotionController object that the state of the windows motion controller
    type [<AllowNullLiteral>] WindowsMotionControllerStatic =
        /// <summary>Creates a new WindowsMotionController from a gamepad</summary>
        /// <param name="vrGamepad">the gamepad that the controller should be created from</param>
        [<Emit "new $0($1...)">] abstract Create: vrGamepad: obj option -> WindowsMotionController

    /// Interface to implement to create a shadow generator compatible with BJS.
    type [<AllowNullLiteral>] IShadowGenerator =
        /// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
        abstract getShadowMap: unit -> Nullable<RenderTargetTexture>
        /// Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
        abstract getShadowMapForRendering: unit -> Nullable<RenderTargetTexture>
        /// <summary>Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).</summary>
        /// <param name="subMesh">The submesh we want to render in the shadow map</param>
        /// <param name="useInstances">Defines wether will draw in the map using instances</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// <summary>Prepare all the defines in a material relying on a shadow map at the specified light index.</summary>
        /// <param name="defines">Defines of the material we want to update</param>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material</param>
        abstract prepareDefines: defines: MaterialDefines * lightIndex: float -> unit
        /// <summary>Binds the shadow related information inside of an effect (information like near, far, darkness...
        /// defined in the generator but impacting the effect).
        /// It implies the unifroms available on the materials are the standard BJS ones.</summary>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material owning the effect</param>
        /// <param name="effect">The effect we are binfing the information for</param>
        abstract bindShadowLight: lightIndex: string * effect: Effect -> unit
        /// Gets the transformation matrix used to project the meshes into the map from the light point of view.
        /// (eq to shadow prjection matrix * light transform matrix)
        abstract getTransformMatrix: unit -> Matrix
        /// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
        /// Cube and 2D textures for instance.
        abstract recreateShadowMap: unit -> unit
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="onCompiled">Callback triggered at the and of the effects compilation</param>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilation: ?onCompiled: (ShadowGenerator -> unit) * ?options: obj -> unit
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilationAsync: ?options: obj -> Promise<unit>
        /// Serializes the shadow generator setup to a json object.
        abstract serialize: unit -> obj option
        /// Disposes the Shadow map and related Textures and effects.
        abstract dispose: unit -> unit

    /// Default implementation IShadowGenerator.
    /// This is the main object responsible of generating shadows in the framework.
    /// Documentation: https://doc.babylonjs.com/babylon101/shadows
    type [<AllowNullLiteral>] ShadowGenerator =
        inherit IShadowGenerator
        /// Shadow generator mode None: no filtering applied.
        abstract FILTER_NONE: float
        /// Shadow generator mode ESM: Exponential Shadow Mapping.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_EXPONENTIALSHADOWMAP: float
        /// Shadow generator mode Poisson Sampling: Percentage Closer Filtering.
        /// (Multiple Tap around evenly distributed around the pixel are used to evaluate the shadow strength)
        abstract FILTER_POISSONSAMPLING: float
        /// Shadow generator mode ESM: Blurred Exponential Shadow Mapping.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_BLUREXPONENTIALSHADOWMAP: float
        /// Shadow generator mode ESM: Exponential Shadow Mapping using the inverse of the exponential preventing
        /// edge artifacts on steep falloff.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_CLOSEEXPONENTIALSHADOWMAP: float
        /// Shadow generator mode ESM: Blurred Exponential Shadow Mapping using the inverse of the exponential preventing
        /// edge artifacts on steep falloff.
        /// (http://developer.download.nvidia.com/presentations/2008/GDC/GDC08_SoftShadowMapping.pdf)
        abstract FILTER_BLURCLOSEEXPONENTIALSHADOWMAP: float
        /// Shadow generator mode PCF: Percentage Closer Filtering
        /// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
        /// (https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch11.html)
        abstract FILTER_PCF: float
        /// Shadow generator mode PCSS: Percentage Closering Soft Shadow.
        /// benefits from Webgl 2 shadow samplers. Fallback to Poisson Sampling in Webgl 1
        /// Contact Hardening
        abstract FILTER_PCSS: float
        /// Reserved for PCF and PCSS
        /// Highest Quality.
        /// 
        /// Execute PCF on a 5*5 kernel improving a lot the shadow aliasing artifacts.
        /// 
        /// Execute PCSS with 32 taps blocker search and 64 taps PCF.
        abstract QUALITY_HIGH: float
        /// Reserved for PCF and PCSS
        /// Good tradeoff for quality/perf cross devices
        /// 
        /// Execute PCF on a 3*3 kernel.
        /// 
        /// Execute PCSS with 16 taps blocker search and 32 taps PCF.
        abstract QUALITY_MEDIUM: float
        /// Reserved for PCF and PCSS
        /// The lowest quality but the fastest.
        /// 
        /// Execute PCF on a 1*1 kernel.
        /// 
        /// Execute PCSS with 16 taps blocker search and 16 taps PCF.
        abstract QUALITY_LOW: float
        abstract _bias: obj with get, set
        /// Gets the bias: offset applied on the depth preventing acnea (in light direction).
        /// Sets the bias: offset applied on the depth preventing acnea (in light direction).
        abstract bias: float with get, set
        abstract _normalBias: obj with get, set
        /// Gets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
        /// Sets the normalBias: offset applied on the depth preventing acnea (along side the normal direction and proportinal to the light/normal angle).
        abstract normalBias: float with get, set
        abstract _blurBoxOffset: obj with get, set
        /// Gets the blur box offset: offset applied during the blur pass.
        /// Only usefull if useKernelBlur = false
        /// Sets the blur box offset: offset applied during the blur pass.
        /// Only usefull if useKernelBlur = false
        abstract blurBoxOffset: float with get, set
        abstract _blurScale: obj with get, set
        /// Gets the blur scale: scale of the blurred texture compared to the main shadow map.
        /// 2 means half of the size.
        /// Sets the blur scale: scale of the blurred texture compared to the main shadow map.
        /// 2 means half of the size.
        abstract blurScale: float with get, set
        abstract _blurKernel: obj with get, set
        /// Gets the blur kernel: kernel size of the blur pass.
        /// Only usefull if useKernelBlur = true
        /// Sets the blur kernel: kernel size of the blur pass.
        /// Only usefull if useKernelBlur = true
        abstract blurKernel: float with get, set
        abstract _useKernelBlur: obj with get, set
        /// Gets whether the blur pass is a kernel blur (if true) or box blur.
        /// Only usefull in filtered mode (useBlurExponentialShadowMap...)
        /// Sets whether the blur pass is a kernel blur (if true) or box blur.
        /// Only usefull in filtered mode (useBlurExponentialShadowMap...)
        abstract useKernelBlur: bool with get, set
        abstract _depthScale: obj with get, set
        /// Gets the depth scale used in ESM mode.
        /// Sets the depth scale used in ESM mode.
        /// This can override the scale stored on the light.
        abstract depthScale: float with get, set
        abstract _filter: obj with get, set
        /// Gets the current mode of the shadow generator (normal, PCF, ESM...).
        /// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
        /// Sets the current mode of the shadow generator (normal, PCF, ESM...).
        /// The returned value is a number equal to one of the available mode defined in ShadowMap.FILTER_x like _FILTER_NONE
        abstract filter: float with get, set
        /// Gets if the current filter is set to Poisson Sampling.
        /// Sets the current filter to Poisson Sampling.
        abstract usePoissonSampling: bool with get, set
        /// Gets if the current filter is set to VSM.
        /// DEPRECATED. Should use useExponentialShadowMap instead.
        /// Sets the current filter is to VSM.
        /// DEPRECATED. Should use useExponentialShadowMap instead.
        abstract useVarianceShadowMap: bool with get, set
        /// Gets if the current filter is set to blurred VSM.
        /// DEPRECATED. Should use useBlurExponentialShadowMap instead.
        /// Sets the current filter is to blurred VSM.
        /// DEPRECATED. Should use useBlurExponentialShadowMap instead.
        abstract useBlurVarianceShadowMap: bool with get, set
        /// Gets if the current filter is set to ESM.
        /// Sets the current filter is to ESM.
        abstract useExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to filtered ESM.
        /// Gets if the current filter is set to filtered  ESM.
        abstract useBlurExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        /// Sets the current filter to "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        abstract useCloseExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to filtered "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        /// Sets the current filter to filtered "close ESM" (using the inverse of the
        /// exponential to prevent steep falloff artifacts).
        abstract useBlurCloseExponentialShadowMap: bool with get, set
        /// Gets if the current filter is set to "PCF" (percentage closer filtering).
        /// Sets the current filter to "PCF" (percentage closer filtering).
        abstract usePercentageCloserFiltering: bool with get, set
        abstract _filteringQuality: obj with get, set
        /// Gets the PCF or PCSS Quality.
        /// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
        /// Sets the PCF or PCSS Quality.
        /// Only valid if usePercentageCloserFiltering or usePercentageCloserFiltering is true.
        abstract filteringQuality: float with get, set
        /// Gets if the current filter is set to "PCSS" (contact hardening).
        /// Sets the current filter to "PCSS" (contact hardening).
        abstract useContactHardeningShadow: bool with get, set
        abstract _contactHardeningLightSizeUVRatio: obj with get, set
        /// Gets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
        /// Using a ratio helps keeping shape stability independently of the map size.
        /// 
        /// It does not account for the light projection as it was having too much
        /// instability during the light setup or during light position changes.
        /// 
        /// Only valid if useContactHardeningShadow is true.
        /// Sets the Light Size (in shadow map uv unit) used in PCSS to determine the blocker search area and the penumbra size.
        /// Using a ratio helps keeping shape stability independently of the map size.
        /// 
        /// It does not account for the light projection as it was having too much
        /// instability during the light setup or during light position changes.
        /// 
        /// Only valid if useContactHardeningShadow is true.
        abstract contactHardeningLightSizeUVRatio: float with get, set
        abstract _darkness: obj with get, set
        /// Returns the darkness value (float). This can only decrease the actual darkness of a shadow.
        /// 0 means strongest and 1 would means no shadow.
        abstract getDarkness: unit -> float
        /// <summary>Sets the darkness value (float). This can only decrease the actual darkness of a shadow.</summary>
        /// <param name="darkness">The darkness value 0 means strongest and 1 would means no shadow.</param>
        abstract setDarkness: darkness: float -> ShadowGenerator
        abstract _transparencyShadow: obj with get, set
        /// <summary>Sets the ability to have transparent shadow (boolean).</summary>
        /// <param name="transparent">True if transparent else False</param>
        abstract setTransparencyShadow: transparent: bool -> ShadowGenerator
        abstract _shadowMap: obj with get, set
        abstract _shadowMap2: obj with get, set
        /// Gets the main RTT containing the shadow map (usually storing depth from the light point of view).
        abstract getShadowMap: unit -> Nullable<RenderTargetTexture>
        /// Gets the RTT used during rendering (can be a blurred version of the shadow map or the shadow map itself).
        abstract getShadowMapForRendering: unit -> Nullable<RenderTargetTexture>
        /// <summary>Helper function to add a mesh and its descendants to the list of shadow casters.</summary>
        /// <param name="mesh">Mesh to add</param>
        /// <param name="includeDescendants">boolean indicating if the descendants should be added. Default to true</param>
        abstract addShadowCaster: mesh: AbstractMesh * ?includeDescendants: bool -> ShadowGenerator
        /// <summary>Helper function to remove a mesh and its descendants from the list of shadow casters</summary>
        /// <param name="mesh">Mesh to remove</param>
        /// <param name="includeDescendants">boolean indicating if the descendants should be removed. Default to true</param>
        abstract removeShadowCaster: mesh: AbstractMesh * ?includeDescendants: bool -> ShadowGenerator
        /// Controls the extent to which the shadows fade out at the edge of the frustum
        /// Used only by directionals and spots
        abstract frustumEdgeFalloff: float with get, set
        abstract _light: obj with get, set
        /// Returns the associated light object.
        abstract getLight: unit -> IShadowLight
        /// If true the shadow map is generated by rendering the back face of the mesh instead of the front face.
        /// This can help with self-shadowing as the geometry making up the back of objects is slightly offset.
        /// It might on the other hand introduce peter panning.
        abstract forceBackFacesOnly: bool with get, set
        abstract _scene: obj with get, set
        abstract _lightDirection: obj with get, set
        abstract _effect: obj with get, set
        abstract _viewMatrix: obj with get, set
        abstract _projectionMatrix: obj with get, set
        abstract _transformMatrix: obj with get, set
        abstract _cachedPosition: obj with get, set
        abstract _cachedDirection: obj with get, set
        abstract _cachedDefines: obj with get, set
        abstract _currentRenderID: obj with get, set
        abstract _boxBlurPostprocess: obj with get, set
        abstract _kernelBlurXPostprocess: obj with get, set
        abstract _kernelBlurYPostprocess: obj with get, set
        abstract _blurPostProcesses: obj with get, set
        abstract _mapSize: obj with get, set
        abstract _currentFaceIndex: obj with get, set
        abstract _currentFaceIndexCache: obj with get, set
        abstract _textureType: obj with get, set
        abstract _defaultTextureMatrix: obj with get, set
        abstract _initializeGenerator: unit -> unit
        abstract _initializeShadowMap: unit -> unit
        abstract _initializeBlurRTTAndPostProcesses: unit -> unit
        abstract _renderForShadowMap: opaqueSubMeshes: obj * alphaTestSubMeshes: obj * transparentSubMeshes: obj * depthOnlySubMeshes: obj -> unit
        abstract _renderSubMeshForShadowMap: subMesh: obj -> unit
        abstract _applyFilterValues: unit -> unit
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="onCompiled">Callback triggered at the and of the effects compilation</param>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilation: ?onCompiled: (ShadowGenerator -> unit) * ?options: obj -> unit
        /// <summary>Forces all the attached effect to compile to enable rendering only once ready vs. lazyly compiling effects.</summary>
        /// <param name="options">Sets of optional options forcing the compilation with different modes</param>
        abstract forceCompilationAsync: ?options: obj -> Promise<unit>
        /// <summary>Determine wheter the shadow generator is ready or not (mainly all effects and related post processes needs to be ready).</summary>
        /// <param name="subMesh">The submesh we want to render in the shadow map</param>
        /// <param name="useInstances">Defines wether will draw in the map using instances</param>
        abstract isReady: subMesh: SubMesh * useInstances: bool -> bool
        /// <summary>Prepare all the defines in a material relying on a shadow map at the specified light index.</summary>
        /// <param name="defines">Defines of the material we want to update</param>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material</param>
        abstract prepareDefines: defines: obj option * lightIndex: float -> unit
        /// <summary>Binds the shadow related information inside of an effect (information like near, far, darkness...
        /// defined in the generator but impacting the effect).</summary>
        /// <param name="lightIndex">Index of the light in the enabled light list of the material owning the effect</param>
        /// <param name="effect">The effect we are binfing the information for</param>
        abstract bindShadowLight: lightIndex: string * effect: Effect -> unit
        /// Gets the transformation matrix used to project the meshes into the map from the light point of view.
        /// (eq to shadow prjection matrix * light transform matrix)
        abstract getTransformMatrix: unit -> Matrix
        /// Recreates the shadow map dependencies like RTT and post processes. This can be used during the switch between
        /// Cube and 2D textures for instance.
        abstract recreateShadowMap: unit -> unit
        abstract _disposeBlurPostProcesses: unit -> unit
        abstract _disposeRTTandPostProcesses: unit -> unit
        /// Disposes the ShadowGenerator.
        /// Returns nothing.
        abstract dispose: unit -> unit
        /// Serializes the shadow generator setup to a json object.
        abstract serialize: unit -> obj option

    /// Default implementation IShadowGenerator.
    /// This is the main object responsible of generating shadows in the framework.
    /// Documentation: https://doc.babylonjs.com/babylon101/shadows
    type [<AllowNullLiteral>] ShadowGeneratorStatic =
        /// <summary>Creates a ShadowGenerator object.
        /// A ShadowGenerator is the required tool to use the shadows.
        /// Each light casting shadows needs to use its own ShadowGenerator.
        /// Documentation : http://doc.babylonjs.com/tutorials/shadows</summary>
        /// <param name="mapSize">The size of the texture what stores the shadows. Example : 1024.</param>
        /// <param name="light">The light object generating the shadows.</param>
        /// <param name="useFullFloatFirst">By default the generator will try to use half float textures but if you need precision (for self shadowing for instance), you can use this option to enforce full float texture.</param>
        [<Emit "new $0($1...)">] abstract Create: mapSize: float * light: IShadowLight * ?useFullFloatFirst: bool -> ShadowGenerator
        /// <summary>Parses a serialized ShadowGenerator and returns a new ShadowGenerator.</summary>
        /// <param name="parsedShadowGenerator">The JSON object to parse</param>
        /// <param name="scene">The scene to create the shadow map for</param>
        abstract Parse: parsedShadowGenerator: obj option * scene: Scene -> ShadowGenerator

    /// Background material used to create an efficient environement around your scene.
    type [<AllowNullLiteral>] BackgroundMaterial =
        inherit PushMaterial
        /// Standard reflectance value at parallel view angle.
        abstract StandardReflectance0: float with get, set
        /// Standard reflectance value at grazing angle.
        abstract StandardReflectance90: float with get, set
        abstract _primaryColor: Color3 with get, set
        /// Key light Color (multiply against the environement texture)
        abstract primaryColor: Color3 with get, set
        abstract _perceptualColor: Nullable<Color3> with get, set
        /// Key light Color in "perceptual value" meaning the color you would like to see on screen.
        /// This acts as a helper to set the primary color to a more "human friendly" value.
        /// Conversion to linear space as well as exposure and tone mapping correction will be applied to keep the
        /// output color as close as possible from the chosen value.
        /// (This does not account for contrast color grading and color curves as they are considered post effect and not directly
        /// part of lighting setup.)
        abstract perceptualColor: Nullable<Color3> with get, set
        abstract _primaryColorShadowLevel: float with get, set
        /// Defines the level of the shadows (dark area of the reflection map) in order to help scaling the colors.
        /// The color opposite to the primary color is used at the level chosen to define what the black area would look.
        abstract primaryColorShadowLevel: float with get, set
        abstract _primaryColorHighlightLevel: float with get, set
        /// Defines the level of the highliights (highlight area of the reflection map) in order to help scaling the colors.
        /// The primary color is used at the level chosen to define what the white area would look.
        abstract primaryColorHighlightLevel: float with get, set
        abstract _reflectionTexture: Nullable<BaseTexture> with get, set
        /// Reflection Texture used in the material.
        /// Should be author in a specific way for the best result (refer to the documentation).
        abstract reflectionTexture: Nullable<BaseTexture> with get, set
        abstract _reflectionBlur: float with get, set
        /// Reflection Texture level of blur.
        /// 
        /// Can be use to reuse an existing HDR Texture and target a specific LOD to prevent authoring the
        /// texture twice.
        abstract reflectionBlur: float with get, set
        abstract _diffuseTexture: Nullable<BaseTexture> with get, set
        /// Diffuse Texture used in the material.
        /// Should be author in a specific way for the best result (refer to the documentation).
        abstract diffuseTexture: Nullable<BaseTexture> with get, set
        abstract _shadowLights: Nullable<ResizeArray<IShadowLight>> with get, set
        /// Specify the list of lights casting shadow on the material.
        /// All scene shadow lights will be included if null.
        abstract shadowLights: Nullable<ResizeArray<IShadowLight>> with get, set
        abstract _shadowLevel: float with get, set
        /// Helps adjusting the shadow to a softer level if required.
        /// 0 means black shadows and 1 means no shadows.
        abstract shadowLevel: float with get, set
        abstract _sceneCenter: Vector3 with get, set
        /// In case of opacity Fresnel or reflection falloff, this is use as a scene center.
        /// It is usually zero but might be interesting to modify according to your setup.
        abstract sceneCenter: Vector3 with get, set
        abstract _opacityFresnel: bool with get, set
        /// This helps specifying that the material is falling off to the sky box at grazing angle.
        /// This helps ensuring a nice transition when the camera goes under the ground.
        abstract opacityFresnel: bool with get, set
        abstract _reflectionFresnel: bool with get, set
        /// This helps specifying that the material is falling off from diffuse to the reflection texture at grazing angle.
        /// This helps adding a mirror texture on the ground.
        abstract reflectionFresnel: bool with get, set
        abstract _reflectionFalloffDistance: float with get, set
        /// This helps specifying the falloff radius off the reflection texture from the sceneCenter.
        /// This helps adding a nice falloff effect to the reflection if used as a mirror for instance.
        abstract reflectionFalloffDistance: float with get, set
        abstract _reflectionAmount: float with get, set
        /// This specifies the weight of the reflection against the background in case of reflection Fresnel.
        abstract reflectionAmount: float with get, set
        abstract _reflectionReflectance0: float with get, set
        /// This specifies the weight of the reflection at grazing angle.
        abstract reflectionReflectance0: float with get, set
        abstract _reflectionReflectance90: float with get, set
        /// This specifies the weight of the reflection at a perpendicular point of view.
        abstract reflectionReflectance90: float with get, set
        /// Sets the reflection reflectance fresnel values according to the default standard
        /// empirically know to work well :-)
        abstract reflectionStandardFresnelWeight: float with get, set
        abstract _useRGBColor: bool with get, set
        /// Helps to directly use the maps channels instead of their level.
        abstract useRGBColor: bool with get, set
        abstract _enableNoise: bool with get, set
        /// This helps reducing the banding effect that could occur on the background.
        abstract enableNoise: bool with get, set
        /// The current fov(field of view) multiplier, 0.0 - 2.0. Defaults to 1.0. Lower values "zoom in" and higher values "zoom out".
        /// Best used when trying to implement visual zoom effects like fish-eye or binoculars while not adjusting camera fov.
        /// Recommended to be keep at 1.0 except for special cases.
        abstract fovMultiplier: float with get, set
        abstract _fovMultiplier: obj with get, set
        /// Enable the FOV adjustment feature controlled by fovMultiplier.
        abstract useEquirectangularFOV: bool with get, set
        abstract _maxSimultaneousLights: obj with get, set
        /// Number of Simultaneous lights allowed on the material.
        abstract maxSimultaneousLights: int with get, set
        /// Default configuration related to image processing available in the Background Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Keep track of the image processing observer to allow dispose and replace.
        abstract _imageProcessingObserver: obj with get, set
        /// <summary>Attaches a new image processing configuration to the PBR Material.</summary>
        /// <param name="configuration">(if null the scene configuration will be use)</param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> -> unit
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: Nullable<ImageProcessingConfiguration> with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract cameraColorCurvesEnabled: bool with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract cameraColorGradingEnabled: bool with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract cameraToneMappingEnabled: bool with get, set
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        abstract cameraExposure: float with get, set
        /// Gets The camera contrast used on this material.
        /// Sets The camera contrast used on this material.
        abstract cameraContrast: float with get, set
        /// Gets the Color Grading 2D Lookup Texture.
        /// Sets the Color Grading 2D Lookup Texture.
        abstract cameraColorGradingTexture: Nullable<BaseTexture> with get, set
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        abstract cameraColorCurves: Nullable<ColorCurves> with get, set
        /// Due to a bug in iOS10, video tags (which are using the background material) are in BGR and not RGB.
        /// Setting this flag to true (not done automatically!) will convert it back to RGB.
        abstract switchToBGR: bool with get, set
        abstract _renderTargets: obj with get, set
        abstract _reflectionControls: obj with get, set
        abstract _white: obj with get, set
        abstract _primaryShadowColor: obj with get, set
        abstract _primaryHighlightColor: obj with get, set
        /// The entire material has been created in order to prevent overdraw.
        abstract needAlphaTesting: unit -> bool
        /// The entire material has been created in order to prevent overdraw.
        abstract needAlphaBlending: unit -> bool
        /// <summary>Checks wether the material is ready to be rendered for a given mesh.</summary>
        /// <param name="mesh">The mesh to render</param>
        /// <param name="subMesh">The submesh to check against</param>
        /// <param name="useInstances">Specify wether or not the material is used with instances</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: SubMesh * ?useInstances: bool -> bool
        /// Tone Mapping calibration (should match image processing tone mapping calibration value).
        abstract _tonemappingCalibration: obj
        /// Compute the primary color according to the chosen perceptual color.
        abstract _computePrimaryColorFromPerceptualColor: unit -> unit
        /// Compute the highlights and shadow colors according to their chosen levels.
        abstract _computePrimaryColors: unit -> unit
        /// Build the uniform buffer used in the material.
        abstract buildUniformLayout: unit -> unit
        /// Unbind the material.
        abstract unbind: unit -> unit
        /// <summary>Bind only the world matrix to the material.</summary>
        /// <param name="world">The world matrix to bind.</param>
        abstract bindOnlyWorldMatrix: world: Matrix -> unit
        /// <summary>Bind the material for a dedicated submeh (every used meshes will be considered opaque).</summary>
        /// <param name="world">The world matrix to bind.</param>
        /// <param name="subMesh">The submesh to bind for.</param>
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        /// <summary>Dispose the material.</summary>
        /// <param name="forceDisposeEffect">Force disposal of the associated effect.</param>
        /// <param name="forceDisposeTextures">Force disposal of the associated textures.</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit
        /// <summary>Clones the material.</summary>
        /// <param name="name">The cloned name.</param>
        abstract clone: name: string -> BackgroundMaterial
        /// Serializes the current material to its JSON representation.
        abstract serialize: unit -> obj option
        /// Gets the class name of the material
        abstract getClassName: unit -> string

    /// Background material used to create an efficient environement around your scene.
    type [<AllowNullLiteral>] BackgroundMaterialStatic =
        /// <summary>Instantiates a Background Material in the given scene</summary>
        /// <param name="name">The friendly name of the material</param>
        /// <param name="scene">The scene to add the material to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> BackgroundMaterial
        /// <summary>Parse a JSON input to create back a background material.</summary>
        /// <param name="source">The JSON data to parse</param>
        /// <param name="scene">The scene to create the parsed material in</param>
        /// <param name="rootUrl">The root url of the assets the material depends upon</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> BackgroundMaterial

    /// The Physically based material base class of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRBaseMaterial =
        inherit PushMaterial
        /// Intensity of the direct lights e.g. the four lights available in your scene.
        /// This impacts both the direct diffuse and specular highlights.
        abstract _directIntensity: float with get, set
        /// Intensity of the emissive part of the material.
        /// This helps controlling the emissive effect without modifying the emissive color.
        abstract _emissiveIntensity: float with get, set
        /// Intensity of the environment e.g. how much the environment will light the object
        /// either through harmonics for rough material or through the refelction for shiny ones.
        abstract _environmentIntensity: float with get, set
        /// This is a special control allowing the reduction of the specular highlights coming from the
        /// four lights of the scene. Those highlights may not be needed in full environment lighting.
        abstract _specularIntensity: float with get, set
        /// This stores the direct, emissive, environment, and specular light intensities into a Vector4.
        abstract _lightingInfos: obj with get, set
        /// Debug Control allowing disabling the bump map on this material.
        abstract _disableBumpMap: bool with get, set
        /// AKA Diffuse Texture in standard nomenclature.
        abstract _albedoTexture: BaseTexture with get, set
        /// AKA Occlusion Texture in other nomenclature.
        abstract _ambientTexture: BaseTexture with get, set
        /// AKA Occlusion Texture Intensity in other nomenclature.
        abstract _ambientTextureStrength: float with get, set
        /// Stores the alpha values in a texture.
        abstract _opacityTexture: BaseTexture with get, set
        /// Stores the reflection values in a texture.
        abstract _reflectionTexture: BaseTexture with get, set
        /// Stores the refraction values in a texture.
        abstract _refractionTexture: BaseTexture with get, set
        /// Stores the emissive values in a texture.
        abstract _emissiveTexture: BaseTexture with get, set
        /// AKA Specular texture in other nomenclature.
        abstract _reflectivityTexture: BaseTexture with get, set
        /// Used to switch from specular/glossiness to metallic/roughness workflow.
        abstract _metallicTexture: BaseTexture with get, set
        /// Specifies the metallic scalar of the metallic/roughness workflow.
        /// Can also be used to scale the metalness values of the metallic texture.
        abstract _metallic: float with get, set
        /// Specifies the roughness scalar of the metallic/roughness workflow.
        /// Can also be used to scale the roughness values of the metallic texture.
        abstract _roughness: float with get, set
        /// Used to enable roughness/glossiness fetch from a separate chanel depending on the current mode.
        /// Gray Scale represents roughness in metallic mode and glossiness in specular mode.
        abstract _microSurfaceTexture: BaseTexture with get, set
        /// Stores surface normal data used to displace a mesh in a texture.
        abstract _bumpTexture: BaseTexture with get, set
        /// Stores the pre-calculated light information of a mesh in a texture.
        abstract _lightmapTexture: BaseTexture with get, set
        /// The color of a material in ambient lighting.
        abstract _ambientColor: Color3 with get, set
        /// AKA Diffuse Color in other nomenclature.
        abstract _albedoColor: Color3 with get, set
        /// AKA Specular Color in other nomenclature.
        abstract _reflectivityColor: Color3 with get, set
        /// The color applied when light is reflected from a material.
        abstract _reflectionColor: Color3 with get, set
        /// The color applied when light is emitted from a material.
        abstract _emissiveColor: Color3 with get, set
        /// AKA Glossiness in other nomenclature.
        abstract _microSurface: float with get, set
        /// source material index of refraction (IOR)' / 'destination material IOR.
        abstract _indexOfRefraction: float with get, set
        /// Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
        abstract _invertRefractionY: bool with get, set
        /// This parameters will make the material used its opacity to control how much it is refracting aginst not.
        /// Materials half opaque for instance using refraction could benefit from this control.
        abstract _linkRefractionWithTransparency: bool with get, set
        /// Specifies that the material will use the light map as a show map.
        abstract _useLightmapAsShadowmap: bool with get, set
        /// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
        /// makes the reflect vector face the model (under horizon).
        abstract _useHorizonOcclusion: bool with get, set
        /// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
        /// too much the area relying on ambient texture to define their ambient occlusion.
        abstract _useRadianceOcclusion: bool with get, set
        /// Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
        abstract _useAlphaFromAlbedoTexture: bool with get, set
        /// Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
        abstract _useSpecularOverAlpha: bool with get, set
        /// Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
        abstract _useMicroSurfaceFromReflectivityMapAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its alpha channel.
        abstract _useRoughnessFromMetallicTextureAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its green channel.
        abstract _useRoughnessFromMetallicTextureGreen: bool with get, set
        /// Specifies if the metallic texture contains the metallness information in its blue channel.
        abstract _useMetallnessFromMetallicTextureBlue: bool with get, set
        /// Specifies if the metallic texture contains the ambient occlusion information in its red channel.
        abstract _useAmbientOcclusionFromMetallicTextureRed: bool with get, set
        /// Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
        abstract _useAmbientInGrayScale: bool with get, set
        /// In case the reflectivity map does not contain the microsurface information in its alpha channel,
        /// The material will try to infer what glossiness each pixel should be.
        abstract _useAutoMicroSurfaceFromReflectivityMap: bool with get, set
        /// BJS is using an harcoded light falloff based on a manually sets up range.
        /// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
        /// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
        abstract _usePhysicalLightFalloff: bool with get, set
        /// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
        abstract _useRadianceOverAlpha: bool with get, set
        /// Allows using an object space normal map (instead of tangent space).
        abstract _useObjectSpaceNormalMap: bool with get, set
        /// Allows using the bump map in parallax mode.
        abstract _useParallax: bool with get, set
        /// Allows using the bump map in parallax occlusion mode.
        abstract _useParallaxOcclusion: bool with get, set
        /// Controls the scale bias of the parallax mode.
        abstract _parallaxScaleBias: float with get, set
        /// If sets to true, disables all the lights affecting the material.
        abstract _disableLighting: bool with get, set
        /// Number of Simultaneous lights allowed on the material.
        abstract _maxSimultaneousLights: float with get, set
        /// If sets to true, x component of normal map value will be inverted (x = 1.0 - x).
        abstract _invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will be inverted (y = 1.0 - y).
        abstract _invertNormalMapY: bool with get, set
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract _twoSidedLighting: bool with get, set
        /// Defines the alpha limits in alpha test mode.
        abstract _alphaCutOff: float with get, set
        /// Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
        abstract _forceAlphaTest: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
        abstract _useAlphaFresnel: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
        abstract _useLinearAlphaFresnel: bool with get, set
        /// The transparency mode of the material.
        abstract _transparencyMode: Nullable<float> with get, set
        /// Specifies the environment BRDF texture used to comput the scale and offset roughness values
        /// from cos thetav and roughness:
        /// http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf
        abstract _environmentBRDFTexture: Nullable<BaseTexture> with get, set
        /// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
        abstract _forceIrradianceInFragment: bool with get, set
        /// Force normal to face away from face.
        abstract _forceNormalForward: bool with get, set
        /// Enables specular anti aliasing in the PBR shader.
        /// It will both interacts on the Geometry for analytical and IBL lighting.
        /// It also prefilter the roughness map based on the bump values.
        abstract _enableSpecularAntiAliasing: bool with get, set
        /// Default configuration related to image processing available in the PBR Material.
        abstract _imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Keep track of the image processing observer to allow dispose and replace.
        abstract _imageProcessingObserver: obj with get, set
        /// <summary>Attaches a new image processing configuration to the PBR Material.</summary>
        /// <param name="configuration"></param>
        abstract _attachImageProcessingConfiguration: configuration: Nullable<ImageProcessingConfiguration> -> unit
        /// Stores the available render targets.
        abstract _renderTargets: obj with get, set
        /// Sets the global ambient color for the material used in lighting calculations.
        abstract _globalAmbientColor: obj with get, set
        /// Enables the use of logarithmic depth buffers, which is good for wide depth buffers.
        abstract _useLogarithmicDepth: obj with get, set
        /// If set to true, no lighting calculations will be applied.
        abstract _unlit: obj with get, set
        /// Gets the name of the material class.
        abstract getClassName: unit -> string
        /// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
        /// Enabled the use of logarithmic depth buffers, which is good for wide depth buffers.
        abstract useLogarithmicDepth: bool with get, set
        /// Gets the current transparency mode.
        /// Sets the transparency mode of the material.
        abstract transparencyMode: Nullable<float> with get, set
        /// Returns true if alpha blending should be disabled.
        abstract _disableAlphaBlending: obj
        /// Specifies whether or not this material should be rendered in alpha blend mode.
        abstract needAlphaBlending: unit -> bool
        /// <summary>Specifies if the mesh will require alpha blending.</summary>
        /// <param name="mesh">- BJS mesh.</param>
        abstract needAlphaBlendingForMesh: mesh: AbstractMesh -> bool
        /// Specifies whether or not this material should be rendered in alpha test mode.
        abstract needAlphaTesting: unit -> bool
        /// Specifies whether or not the alpha value of the albedo texture should be used for alpha blending.
        abstract _shouldUseAlphaFromAlbedoTexture: unit -> bool
        /// Gets the texture used for the alpha test.
        abstract getAlphaTestTexture: unit -> BaseTexture
        /// Stores the reflectivity values based on metallic roughness workflow.
        abstract _scaledReflectivity: obj with get, set
        /// <summary>Specifies that the submesh is ready to be used.</summary>
        /// <param name="mesh">- BJS mesh.</param>
        /// <param name="subMesh">- A submesh of the BJS mesh.  Used to check if it is ready.</param>
        /// <param name="useInstances">- Specifies that instances should be used.</param>
        abstract isReadyForSubMesh: mesh: AbstractMesh * subMesh: SubMesh * ?useInstances: bool -> bool
        /// Specifies if the material uses metallic roughness workflow.
        abstract isMetallicWorkflow: unit -> bool
        abstract _prepareEffect: mesh: obj * defines: obj * ?onCompiled: obj * ?onError: obj * ?useInstances: obj * ?useClipPlane: obj -> unit
        abstract _prepareDefines: mesh: obj * defines: obj * ?useInstances: obj * ?useClipPlane: obj -> unit
        /// Force shader compilation
        abstract forceCompilation: mesh: AbstractMesh * ?onCompiled: (Material -> unit) * ?options: obj -> unit
        /// Initializes the uniform buffer layout for the shader.
        abstract buildUniformLayout: unit -> unit
        /// Unbinds the textures.
        abstract unbind: unit -> unit
        /// <summary>Binds the submesh data.</summary>
        /// <param name="world">- The world matrix.</param>
        /// <param name="mesh">- The BJS mesh.</param>
        /// <param name="subMesh">- A submesh of the BJS mesh.</param>
        abstract bindForSubMesh: world: Matrix * mesh: Mesh * subMesh: SubMesh -> unit
        /// Returns the animatable textures.
        abstract getAnimatables: unit -> ResizeArray<IAnimatable>
        /// Returns the texture used for reflections.
        abstract _getReflectionTexture: unit -> unit
        /// Returns the texture used for refraction or null if none is used.
        abstract _getRefractionTexture: unit -> unit
        /// <summary>Disposes the resources of the material.</summary>
        /// <param name="forceDisposeEffect">- Forces the disposal of effects.</param>
        /// <param name="forceDisposeTextures">- Forces the disposal of all textures.</param>
        abstract dispose: ?forceDisposeEffect: bool * ?forceDisposeTextures: bool -> unit

    /// The Physically based material base class of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRBaseMaterialStatic =
        /// <summary>Instantiates a new PBRMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRBaseMaterial

    /// The Physically based simple base material of BJS.
    /// 
    /// This enables better naming and convention enforcements on top of the pbrMaterial.
    /// It is used as the base class for both the specGloss and metalRough conventions.
    type [<AllowNullLiteral>] PBRBaseSimpleMaterial =
        inherit PBRBaseMaterial
        /// Number of Simultaneous lights allowed on the material.
        abstract maxSimultaneousLights: float with get, set
        /// If sets to true, disables all the lights affecting the material.
        abstract disableLighting: bool with get, set
        /// Environment Texture used in the material (this is use for both reflection and environment lighting).
        abstract environmentTexture: BaseTexture with get, set
        /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
        abstract invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
        abstract invertNormalMapY: bool with get, set
        /// Normal map used in the model.
        abstract normalTexture: BaseTexture with get, set
        /// Emissivie color used to self-illuminate the model.
        abstract emissiveColor: Color3 with get, set
        /// Emissivie texture used to self-illuminate the model.
        abstract emissiveTexture: BaseTexture with get, set
        /// Occlusion Channel Strenght.
        abstract occlusionStrength: float with get, set
        /// Occlusion Texture of the material (adding extra occlusion effects).
        abstract occlusionTexture: BaseTexture with get, set
        /// Defines the alpha limits in alpha test mode.
        abstract alphaCutOff: float with get, set
        /// Gets the current double sided mode.
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract doubleSided: bool with get, set
        abstract lightmapTexture: BaseTexture with get, set
        abstract useLightmapAsShadowmap: bool with get, set
        /// Return the active textures of the material.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        abstract hasTexture: texture: BaseTexture -> bool
        abstract getClassName: unit -> string

    /// The Physically based simple base material of BJS.
    /// 
    /// This enables better naming and convention enforcements on top of the pbrMaterial.
    /// It is used as the base class for both the specGloss and metalRough conventions.
    type [<AllowNullLiteral>] PBRBaseSimpleMaterialStatic =
        /// <summary>Instantiates a new PBRMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRBaseSimpleMaterial

    /// The Physically based material of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRMaterial =
        inherit PBRBaseMaterial
        abstract _PBRMATERIAL_OPAQUE: obj with get, set
        /// PBRMaterialTransparencyMode: No transparency mode, Alpha channel is not use.
        abstract PBRMATERIAL_OPAQUE: float
        /// Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
        abstract _PBRMATERIAL_ALPHATEST: obj with get, set
        /// PBRMaterialTransparencyMode: Alpha Test mode, pixel are discarded below a certain threshold defined by the alpha cutoff value.
        abstract PBRMATERIAL_ALPHATEST: float
        /// Represents the value for Alpha Blend.  Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
        abstract _PBRMATERIAL_ALPHABLEND: obj with get, set
        /// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
        abstract PBRMATERIAL_ALPHABLEND: float
        /// Represents the value for Alpha Test and Blend.  Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
        /// They are also discarded below the alpha cutoff threshold to improve performances.
        abstract _PBRMATERIAL_ALPHATESTANDBLEND: obj with get, set
        /// PBRMaterialTransparencyMode: Pixels are blended (according to the alpha mode) with the already drawn pixels in the current frame buffer.
        /// They are also discarded below the alpha cutoff threshold to improve performances.
        abstract PBRMATERIAL_ALPHATESTANDBLEND: float
        /// Intensity of the direct lights e.g. the four lights available in your scene.
        /// This impacts both the direct diffuse and specular highlights.
        abstract directIntensity: float with get, set
        /// Intensity of the emissive part of the material.
        /// This helps controlling the emissive effect without modifying the emissive color.
        abstract emissiveIntensity: float with get, set
        /// Intensity of the environment e.g. how much the environment will light the object
        /// either through harmonics for rough material or through the refelction for shiny ones.
        abstract environmentIntensity: float with get, set
        /// This is a special control allowing the reduction of the specular highlights coming from the
        /// four lights of the scene. Those highlights may not be needed in full environment lighting.
        abstract specularIntensity: float with get, set
        /// Debug Control allowing disabling the bump map on this material.
        abstract disableBumpMap: bool with get, set
        /// AKA Diffuse Texture in standard nomenclature.
        abstract albedoTexture: BaseTexture with get, set
        /// AKA Occlusion Texture in other nomenclature.
        abstract ambientTexture: BaseTexture with get, set
        /// AKA Occlusion Texture Intensity in other nomenclature.
        abstract ambientTextureStrength: float with get, set
        /// Stores the alpha values in a texture.
        abstract opacityTexture: BaseTexture with get, set
        /// Stores the reflection values in a texture.
        abstract reflectionTexture: Nullable<BaseTexture> with get, set
        /// Stores the emissive values in a texture.
        abstract emissiveTexture: BaseTexture with get, set
        /// AKA Specular texture in other nomenclature.
        abstract reflectivityTexture: BaseTexture with get, set
        /// Used to switch from specular/glossiness to metallic/roughness workflow.
        abstract metallicTexture: BaseTexture with get, set
        /// Specifies the metallic scalar of the metallic/roughness workflow.
        /// Can also be used to scale the metalness values of the metallic texture.
        abstract metallic: float with get, set
        /// Specifies the roughness scalar of the metallic/roughness workflow.
        /// Can also be used to scale the roughness values of the metallic texture.
        abstract roughness: float with get, set
        /// Used to enable roughness/glossiness fetch from a separate chanel depending on the current mode.
        /// Gray Scale represents roughness in metallic mode and glossiness in specular mode.
        abstract microSurfaceTexture: BaseTexture with get, set
        /// Stores surface normal data used to displace a mesh in a texture.
        abstract bumpTexture: BaseTexture with get, set
        /// Stores the pre-calculated light information of a mesh in a texture.
        abstract lightmapTexture: BaseTexture with get, set
        /// Stores the refracted light information in a texture.
        abstract refractionTexture: BaseTexture with get, set
        /// The color of a material in ambient lighting.
        abstract ambientColor: Color3 with get, set
        /// AKA Diffuse Color in other nomenclature.
        abstract albedoColor: Color3 with get, set
        /// AKA Specular Color in other nomenclature.
        abstract reflectivityColor: Color3 with get, set
        /// The color reflected from the material.
        abstract reflectionColor: Color3 with get, set
        /// The color emitted from the material.
        abstract emissiveColor: Color3 with get, set
        /// AKA Glossiness in other nomenclature.
        abstract microSurface: float with get, set
        /// source material index of refraction (IOR)' / 'destination material IOR.
        abstract indexOfRefraction: float with get, set
        /// Controls if refraction needs to be inverted on Y. This could be usefull for procedural texture.
        abstract invertRefractionY: bool with get, set
        /// This parameters will make the material used its opacity to control how much it is refracting aginst not.
        /// Materials half opaque for instance using refraction could benefit from this control.
        abstract linkRefractionWithTransparency: bool with get, set
        abstract useLightmapAsShadowmap: bool with get, set
        /// Specifies that the alpha is coming form the albedo channel alpha channel for alpha blending.
        abstract useAlphaFromAlbedoTexture: bool with get, set
        /// Enforces alpha test in opaque or blend mode in order to improve the performances of some situations.
        abstract forceAlphaTest: bool with get, set
        /// Defines the alpha limits in alpha test mode.
        abstract alphaCutOff: float with get, set
        /// Specifies that the material will keeps the specular highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When sun reflects on it you can not see what is behind.
        abstract useSpecularOverAlpha: bool with get, set
        /// Specifies if the reflectivity texture contains the glossiness information in its alpha channel.
        abstract useMicroSurfaceFromReflectivityMapAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its alpha channel.
        abstract useRoughnessFromMetallicTextureAlpha: bool with get, set
        /// Specifies if the metallic texture contains the roughness information in its green channel.
        abstract useRoughnessFromMetallicTextureGreen: bool with get, set
        /// Specifies if the metallic texture contains the metallness information in its blue channel.
        abstract useMetallnessFromMetallicTextureBlue: bool with get, set
        /// Specifies if the metallic texture contains the ambient occlusion information in its red channel.
        abstract useAmbientOcclusionFromMetallicTextureRed: bool with get, set
        /// Specifies if the ambient texture contains the ambient occlusion information in its red channel only.
        abstract useAmbientInGrayScale: bool with get, set
        /// In case the reflectivity map does not contain the microsurface information in its alpha channel,
        /// The material will try to infer what glossiness each pixel should be.
        abstract useAutoMicroSurfaceFromReflectivityMap: bool with get, set
        /// BJS is using an harcoded light falloff based on a manually sets up range.
        /// In PBR, one way to represents the fallof is to use the inverse squared root algorythm.
        /// This parameter can help you switch back to the BJS mode in order to create scenes using both materials.
        abstract usePhysicalLightFalloff: bool with get, set
        /// Specifies that the material will keeps the reflection highlights over a transparent surface (only the most limunous ones).
        /// A car glass is a good exemple of that. When the street lights reflects on it you can not see what is behind.
        abstract useRadianceOverAlpha: bool with get, set
        /// Allows using an object space normal map (instead of tangent space).
        abstract useObjectSpaceNormalMap: bool with get, set
        /// Allows using the bump map in parallax mode.
        abstract useParallax: bool with get, set
        /// Allows using the bump map in parallax occlusion mode.
        abstract useParallaxOcclusion: bool with get, set
        /// Controls the scale bias of the parallax mode.
        abstract parallaxScaleBias: float with get, set
        /// If sets to true, disables all the lights affecting the material.
        abstract disableLighting: bool with get, set
        /// Force the shader to compute irradiance in the fragment shader in order to take bump in account.
        abstract forceIrradianceInFragment: bool with get, set
        /// Number of Simultaneous lights allowed on the material.
        abstract maxSimultaneousLights: float with get, set
        /// If sets to true, x component of normal map value will invert (x = 1.0 - x).
        abstract invertNormalMapX: bool with get, set
        /// If sets to true, y component of normal map value will invert (y = 1.0 - y).
        abstract invertNormalMapY: bool with get, set
        /// If sets to true and backfaceCulling is false, normals will be flipped on the backside.
        abstract twoSidedLighting: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha is converted to gamma to compute the fresnel)
        abstract useAlphaFresnel: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part. (alpha stays linear to compute the fresnel)
        abstract useLinearAlphaFresnel: bool with get, set
        /// A fresnel is applied to the alpha of the model to ensure grazing angles edges are not alpha tested.
        /// And/Or occlude the blended part.
        abstract environmentBRDFTexture: Nullable<BaseTexture> with get, set
        /// Force normal to face away from face.
        abstract forceNormalForward: bool with get, set
        /// Enables specular anti aliasing in the PBR shader.
        /// It will both interacts on the Geometry for analytical and IBL lighting.
        /// It also prefilter the roughness map based on the bump values.
        abstract enableSpecularAntiAliasing: bool with get, set
        /// This parameters will enable/disable Horizon occlusion to prevent normal maps to look shiny when the normal
        /// makes the reflect vector face the model (under horizon).
        abstract useHorizonOcclusion: bool with get, set
        /// This parameters will enable/disable radiance occlusion by preventing the radiance to lit
        /// too much the area relying on ambient texture to define their ambient occlusion.
        abstract useRadianceOcclusion: bool with get, set
        /// If set to true, no lighting calculations will be applied.
        abstract unlit: bool with get, set
        /// Gets the image processing configuration used either in this material.
        /// Sets the Default image processing configuration used either in the this material.
        /// 
        /// If sets to null, the scene one is in use.
        abstract imageProcessingConfiguration: ImageProcessingConfiguration with get, set
        /// Gets wether the color curves effect is enabled.
        /// Sets wether the color curves effect is enabled.
        abstract cameraColorCurvesEnabled: bool with get, set
        /// Gets wether the color grading effect is enabled.
        /// Gets wether the color grading effect is enabled.
        abstract cameraColorGradingEnabled: bool with get, set
        /// Gets wether tonemapping is enabled or not.
        /// Sets wether tonemapping is enabled or not
        abstract cameraToneMappingEnabled: bool with get, set
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        /// The camera exposure used on this material.
        /// This property is here and not in the camera to allow controlling exposure without full screen post process.
        /// This corresponds to a photographic exposure.
        abstract cameraExposure: float with get, set
        /// Gets The camera contrast used on this material.
        /// Sets The camera contrast used on this material.
        abstract cameraContrast: float with get, set
        /// Gets the Color Grading 2D Lookup Texture.
        /// Sets the Color Grading 2D Lookup Texture.
        abstract cameraColorGradingTexture: Nullable<BaseTexture> with get, set
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        /// The color grading curves provide additional color adjustmnent that is applied after any color grading transform (3D LUT).
        /// They allow basic adjustment of saturation and small exposure adjustments, along with color filter tinting to provide white balance adjustment or more stylistic effects.
        /// These are similar to controls found in many professional imaging or colorist software. The global controls are applied to the entire image. For advanced tuning, extra controls are provided to adjust the shadow, midtone and highlight areas of the image;
        /// corresponding to low luminance, medium luminance, and high luminance areas respectively.
        abstract cameraColorCurves: Nullable<ColorCurves> with get, set
        /// Returns the name of this material class.
        abstract getClassName: unit -> string
        /// Returns an array of the actively used textures.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Checks to see if a texture is used in the material.</summary>
        /// <param name="texture">- Base texture to use.</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the current material.</summary>
        /// <param name="name">- name to use for the new material.</param>
        abstract clone: name: string -> PBRMaterial
        /// Serializes this PBR Material.
        abstract serialize: unit -> obj option

    /// The Physically based material of BJS.
    /// 
    /// This offers the main features of a standard PBR material.
    /// For more information, please refer to the documentation :
    /// http://doc.babylonjs.com/extensions/Physically_Based_Rendering
    type [<AllowNullLiteral>] PBRMaterialStatic =
        /// <summary>Instantiates a new PBRMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRMaterial
        /// <summary>Parses a PBR Material from a serialized object.</summary>
        /// <param name="source">- Serialized object.</param>
        /// <param name="scene">- BJS scene instance.</param>
        /// <param name="rootUrl">- url for the scene object</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> PBRMaterial

    /// The PBR material of BJS following the metal roughness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
    type [<AllowNullLiteral>] PBRMetallicRoughnessMaterial =
        inherit PBRBaseSimpleMaterial
        /// The base color has two different interpretations depending on the value of metalness.
        /// When the material is a metal, the base color is the specific measured reflectance value
        /// at normal incidence (F0). For a non-metal the base color represents the reflected diffuse color
        /// of the material.
        abstract baseColor: Color3 with get, set
        /// Base texture of the metallic workflow. It contains both the baseColor information in RGB as
        /// well as opacity information in the alpha channel.
        abstract baseTexture: BaseTexture with get, set
        /// Specifies the metallic scalar value of the material.
        /// Can also be used to scale the metalness values of the metallic texture.
        abstract metallic: float with get, set
        /// Specifies the roughness scalar value of the material.
        /// Can also be used to scale the roughness values of the metallic texture.
        abstract roughness: float with get, set
        /// Texture containing both the metallic value in the B channel and the
        /// roughness value in the G channel to keep better precision.
        abstract metallicRoughnessTexture: BaseTexture with get, set
        /// Return the currrent class name of the material.
        abstract getClassName: unit -> string
        /// Return the active textures of the material.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Checks to see if a texture is used in the material.</summary>
        /// <param name="texture">- Base texture to use.</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the current material.</summary>
        /// <param name="name">- name to use for the new material.</param>
        abstract clone: name: string -> PBRMetallicRoughnessMaterial
        /// Serialize the material to a parsable JSON object.
        abstract serialize: unit -> obj option

    /// The PBR material of BJS following the metal roughness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/specification/2.0
    type [<AllowNullLiteral>] PBRMetallicRoughnessMaterialStatic =
        /// <summary>Instantiates a new PBRMetalRoughnessMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRMetallicRoughnessMaterial
        /// Parses a JSON object correponding to the serialize function.
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> PBRMetallicRoughnessMaterial

    /// The PBR material of BJS following the specular glossiness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
    type [<AllowNullLiteral>] PBRSpecularGlossinessMaterial =
        inherit PBRBaseSimpleMaterial
        /// Specifies the diffuse color of the material.
        abstract diffuseColor: Color3 with get, set
        /// Specifies the diffuse texture of the material. This can also contains the opcity value in its alpha
        /// channel.
        abstract diffuseTexture: BaseTexture with get, set
        /// Specifies the specular color of the material. This indicates how reflective is the material (none to mirror).
        abstract specularColor: Color3 with get, set
        /// Specifies the glossiness of the material. This indicates "how sharp is the reflection".
        abstract glossiness: float with get, set
        /// Specifies both the specular color RGB and the glossiness A of the material per pixels.
        abstract specularGlossinessTexture: BaseTexture with get, set
        /// Return the currrent class name of the material.
        abstract getClassName: unit -> string
        /// Return the active textures of the material.
        abstract getActiveTextures: unit -> ResizeArray<BaseTexture>
        /// <summary>Checks to see if a texture is used in the material.</summary>
        /// <param name="texture">- Base texture to use.</param>
        abstract hasTexture: texture: BaseTexture -> bool
        /// <summary>Makes a duplicate of the current material.</summary>
        /// <param name="name">- name to use for the new material.</param>
        abstract clone: name: string -> PBRSpecularGlossinessMaterial
        /// Serialize the material to a parsable JSON object.
        abstract serialize: unit -> obj option

    /// The PBR material of BJS following the specular glossiness convention.
    /// 
    /// This fits to the PBR convention in the GLTF definition:
    /// https://github.com/KhronosGroup/glTF/tree/2.0/extensions/Khronos/KHR_materials_pbrSpecularGlossiness
    type [<AllowNullLiteral>] PBRSpecularGlossinessMaterialStatic =
        /// <summary>Instantiates a new PBRSpecularGlossinessMaterial instance.</summary>
        /// <param name="name">The material name</param>
        /// <param name="scene">The scene the material will be use in.</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene -> PBRSpecularGlossinessMaterial
        /// Parses a JSON object correponding to the serialize function.
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> PBRSpecularGlossinessMaterial

    type [<AllowNullLiteral>] BaseTexture =
        abstract DEFAULT_ANISOTROPIC_FILTERING_LEVEL: float with get, set
        abstract name: string with get, set
        abstract _hasAlpha: obj with get, set
        abstract hasAlpha: bool with get, set
        abstract getAlphaFromRGB: bool with get, set
        abstract level: float with get, set
        abstract coordinatesIndex: float with get, set
        abstract _coordinatesMode: obj with get, set
        /// How a texture is mapped.
        /// 
        /// | Value | Type                                | Description |
        /// | ----- | ----------------------------------- | ----------- |
        /// | 0     | EXPLICIT_MODE                       |             |
        /// | 1     | SPHERICAL_MODE                      |             |
        /// | 2     | PLANAR_MODE                         |             |
        /// | 3     | CUBIC_MODE                          |             |
        /// | 4     | PROJECTION_MODE                     |             |
        /// | 5     | SKYBOX_MODE                         |             |
        /// | 6     | INVCUBIC_MODE                       |             |
        /// | 7     | EQUIRECTANGULAR_MODE                |             |
        /// | 8     | FIXED_EQUIRECTANGULAR_MODE          |             |
        /// | 9     | FIXED_EQUIRECTANGULAR_MIRRORED_MODE |             |
        abstract coordinatesMode: float with get, set
        /// | Value | Type               | Description |
        /// | ----- | ------------------ | ----------- |
        /// | 0     | CLAMP_ADDRESSMODE  |             |
        /// | 1     | WRAP_ADDRESSMODE   |             |
        /// | 2     | MIRROR_ADDRESSMODE |             |
        abstract wrapU: float with get, set
        /// | Value | Type               | Description |
        /// | ----- | ------------------ | ----------- |
        /// | 0     | CLAMP_ADDRESSMODE  |             |
        /// | 1     | WRAP_ADDRESSMODE   |             |
        /// | 2     | MIRROR_ADDRESSMODE |             |
        abstract wrapV: float with get, set
        /// | Value | Type               | Description |
        /// | ----- | ------------------ | ----------- |
        /// | 0     | CLAMP_ADDRESSMODE  |             |
        /// | 1     | WRAP_ADDRESSMODE   |             |
        /// | 2     | MIRROR_ADDRESSMODE |             |
        abstract wrapR: float with get, set
        abstract anisotropicFilteringLevel: float with get, set
        abstract isCube: bool with get, set
        abstract is3D: bool with get, set
        abstract gammaSpace: bool with get, set
        abstract invertZ: bool with get, set
        abstract lodLevelInAlpha: bool with get, set
        abstract lodGenerationOffset: float with get, set
        abstract lodGenerationScale: float with get, set
        abstract isRenderTarget: bool with get, set
        abstract uid: string
        abstract toString: unit -> string
        abstract getClassName: unit -> string
        abstract animations: ResizeArray<Animation> with get, set
        /// An event triggered when the texture is disposed.
        abstract onDisposeObservable: Observable<BaseTexture> with get, set
        abstract _onDisposeObserver: obj with get, set
        abstract onDispose: (unit -> unit) with get, set
        abstract delayLoadState: float with get, set
        abstract _scene: obj with get, set
        abstract _texture: Nullable<InternalTexture> with get, set
        abstract _uid: obj with get, set
        abstract isBlocking: bool
        abstract getScene: unit -> Nullable<Scene>
        abstract getTextureMatrix: unit -> Matrix
        abstract getReflectionTextureMatrix: unit -> Matrix
        abstract getInternalTexture: unit -> Nullable<InternalTexture>
        abstract isReadyOrNotBlocking: unit -> bool
        abstract isReady: unit -> bool
        abstract getSize: unit -> ISize
        abstract getBaseSize: unit -> ISize
        abstract scale: ratio: float -> unit
        abstract canRescale: bool
        abstract _getFromCache: url: Nullable<string> * noMipmap: bool * ?sampling: float -> Nullable<InternalTexture>
        abstract _rebuild: unit -> unit
        abstract delayLoad: unit -> unit
        abstract clone: unit -> Nullable<BaseTexture>
        abstract textureType: float
        abstract textureFormat: float
        abstract readPixels: ?faceIndex: float -> Nullable<ArrayBufferView>
        abstract releaseInternalTexture: unit -> unit
        abstract sphericalPolynomial: Nullable<SphericalPolynomial> with get, set
        abstract _lodTextureHigh: Nullable<BaseTexture>
        abstract _lodTextureMid: Nullable<BaseTexture>
        abstract _lodTextureLow: Nullable<BaseTexture>
        abstract dispose: unit -> unit
        abstract serialize: unit -> obj option

    type [<AllowNullLiteral>] BaseTextureStatic =
        [<Emit "new $0($1...)">] abstract Create: scene: Nullable<Scene> -> BaseTexture
        abstract WhenAllReady: textures: ResizeArray<BaseTexture> * callback: (unit -> unit) -> unit

    /// This represents a color grading texture. This acts as a lookup table LUT, useful during post process
    /// It can help converting any input color in a desired output one. This can then be used to create effects
    /// from sepia, black and white to sixties or futuristic rendering...
    /// 
    /// The only supported format is currently 3dl.
    /// More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table/
    type [<AllowNullLiteral>] ColorGradingTexture =
        inherit BaseTexture
        /// The current texture matrix. (will always be identity in color grading texture)
        abstract _textureMatrix: obj with get, set
        /// The texture URL.
        abstract url: string with get, set
        /// Empty line regex stored for GC.
        abstract _noneEmptyLineRegex: obj with get, set
        abstract _engine: obj with get, set
        /// Returns the texture matrix used in most of the material.
        /// This is not used in color grading but keep for troubleshooting purpose (easily swap diffuse by colorgrading to look in).
        abstract getTextureMatrix: unit -> Matrix
        /// Occurs when the file being loaded is a .3dl LUT file.
        abstract load3dlTexture: unit -> unit
        /// Starts the loading process of the texture.
        abstract loadTexture: unit -> unit
        /// Clones the color gradind texture.
        abstract clone: unit -> ColorGradingTexture
        /// Called during delayed load for textures.
        abstract delayLoad: unit -> unit
        /// Serializes the LUT texture to json format.
        abstract serialize: unit -> obj option

    /// This represents a color grading texture. This acts as a lookup table LUT, useful during post process
    /// It can help converting any input color in a desired output one. This can then be used to create effects
    /// from sepia, black and white to sixties or futuristic rendering...
    /// 
    /// The only supported format is currently 3dl.
    /// More information on LUT: https://en.wikipedia.org/wiki/3D_lookup_table/
    type [<AllowNullLiteral>] ColorGradingTextureStatic =
        /// <summary>Instantiates a ColorGradingTexture from the following parameters.</summary>
        /// <param name="url">The location of the color gradind data (currently only supporting 3dl)</param>
        /// <param name="scene">The scene the texture will be used in</param>
        [<Emit "new $0($1...)">] abstract Create: url: string * scene: Scene -> ColorGradingTexture
        /// <summary>Parses a color grading texture serialized by Babylon.</summary>
        /// <param name="parsedTexture">The texture information being parsedTexture</param>
        /// <param name="scene">The scene to load the texture in</param>
        /// <param name="rootUrl">The root url of the data assets to load</param>
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> Nullable<ColorGradingTexture>

    type [<AllowNullLiteral>] CubeTexture =
        inherit BaseTexture
        abstract url: string with get, set
        abstract coordinatesMode: float with get, set
        /// Gets or sets the center of the bounding box associated with the cube texture
        /// It must define where the camera used to render the texture was set
        abstract boundingBoxPosition: Vector3 with get, set
        abstract _boundingBoxSize: obj with get, set
        /// Gets or sets the size of the bounding box associated with the cube texture
        /// When defined, the cubemap will switch to local mode
        abstract boundingBoxSize: Vector3 with get, set
        abstract _rotationY: float with get, set
        /// Gets texture matrix rotation angle around Y axis radians.
        /// Sets texture matrix rotation angle around Y axis in radians.
        abstract rotationY: float with get, set
        abstract _noMipmap: obj with get, set
        abstract _files: obj with get, set
        abstract _extensions: obj with get, set
        abstract _textureMatrix: obj with get, set
        abstract _format: obj with get, set
        abstract _prefiltered: obj with get, set
        abstract delayLoad: unit -> unit
        abstract getReflectionTextureMatrix: unit -> Matrix
        abstract setReflectionTextureMatrix: value: Matrix -> unit
        abstract clone: unit -> CubeTexture

    type [<AllowNullLiteral>] CubeTextureStatic =
        abstract CreateFromImages: files: ResizeArray<string> * scene: Scene * ?noMipmap: bool -> CubeTexture
        abstract CreateFromPrefilteredData: url: string * scene: Scene * ?forcedExtension: obj option -> CubeTexture
        [<Emit "new $0($1...)">] abstract Create: rootUrl: string * scene: Scene * ?extensions: Nullable<ResizeArray<string>> * ?noMipmap: bool * ?files: Nullable<ResizeArray<string>> * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?format: float * ?prefiltered: bool * ?forcedExtension: obj option -> CubeTexture
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> CubeTexture

    /// A class extending {BABYLON.Texture} allowing drawing on a texture
    type [<AllowNullLiteral>] DynamicTexture =
        inherit Texture
        abstract _generateMipMaps: obj with get, set
        abstract _canvas: obj with get, set
        abstract _context: obj with get, set
        abstract _engine: obj with get, set
        /// Gets the current state of canRescale
        abstract canRescale: bool
        abstract _recreate: textureSize: obj -> unit
        /// <summary>Scales the texture</summary>
        /// <param name="ratio">the scale factor to apply to both width and height</param>
        abstract scale: ratio: float -> unit
        /// <summary>Resizes the texture</summary>
        /// <param name="width">the new width</param>
        /// <param name="height">the new height</param>
        abstract scaleTo: width: float * height: float -> unit
        /// Gets the context of the canvas used by the texture
        abstract getContext: unit -> CanvasRenderingContext2D
        /// Clears the texture
        abstract clear: unit -> unit
        /// <summary>Updates the texture</summary>
        /// <param name="invertY">defines the direction for the Y axis (default is true - y increases downwards)</param>
        abstract update: ?invertY: bool -> unit
        /// <summary>Draws text onto the texture</summary>
        /// <param name="text">defines the text to be drawn</param>
        /// <param name="x">defines the placement of the text from the left</param>
        /// <param name="y">defines the placement of the text from the top when invertY is true and from the bottom when false</param>
        /// <param name="font">defines the font to be used with font-style, font-size, font-name</param>
        /// <param name="color">defines the color used for the text</param>
        /// <param name="clearColor">defines the color for the canvas, use null to not overwrite canvas</param>
        /// <param name="invertY">defines the direction for the Y axis (default is true - y increases downwards)</param>
        /// <param name="update">defines whether texture is immediately update (default is true)</param>
        abstract drawText: text: string * x: float * y: float * font: string * color: string * clearColor: string * ?invertY: bool * ?update: bool -> unit
        /// Clones the texture
        abstract clone: unit -> DynamicTexture
        abstract _rebuild: unit -> unit

    /// A class extending {BABYLON.Texture} allowing drawing on a texture
    type [<AllowNullLiteral>] DynamicTextureStatic =
        /// <summary>Creates a {BABYLON.DynamicTexture}</summary>
        /// <param name="name">defines the name of the texture</param>
        /// <param name="options">provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height</param>
        /// <param name="scene">defines the scene where you want the texture</param>
        /// <param name="generateMipMaps">defines the use of MinMaps or not (default is false)</param>
        /// <param name="samplingMode">defines the sampling mode to use (default is BABYLON.Texture.TRILINEAR_SAMPLINGMODE)</param>
        /// <param name="format">defines the texture format to use (default is BABYLON.Engine.TEXTUREFORMAT_RGBA)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * options: obj option * scene: Scene option * generateMipMaps: bool * ?samplingMode: float * ?format: float -> DynamicTexture

    /// This represents a texture coming from an HDR input.
    /// 
    /// The only supported format is currently panorama picture stored in RGBE format.
    /// Example of such files can be found on HDRLib: http://hdrlib.com/
    type [<AllowNullLiteral>] HDRCubeTexture =
        inherit BaseTexture
        abstract _facesMapping: obj with get, set
        abstract _useInGammaSpace: obj with get, set
        abstract _generateHarmonics: obj with get, set
        abstract _noMipmap: obj with get, set
        abstract _textureMatrix: obj with get, set
        abstract _size: obj with get, set
        abstract _usePMREMGenerator: obj with get, set
        abstract _isBABYLONPreprocessed: obj with get, set
        abstract _onLoad: obj with get, set
        abstract _onError: obj with get, set
        /// The texture URL.
        abstract url: string with get, set
        /// The texture coordinates mode. As this texture is stored in a cube format, please modify carefully.
        abstract coordinatesMode: float with get, set
        /// Specifies wether the texture has been generated through the PMREMGenerator tool.
        /// This is usefull at run time to apply the good shader.
        abstract isPMREM: bool with get, set
        abstract _isBlocking: bool with get, set
        /// Gets wether or not the texture is blocking during loading.
        /// Sets wether or not the texture is blocking during loading.
        abstract isBlocking: bool with get, set
        abstract _rotationY: float with get, set
        /// Gets texture matrix rotation angle around Y axis radians.
        /// Sets texture matrix rotation angle around Y axis in radians.
        abstract rotationY: float with get, set
        /// Gets or sets the center of the bounding box associated with the cube texture
        /// It must define where the camera used to render the texture was set
        abstract boundingBoxPosition: Vector3 with get, set
        abstract _boundingBoxSize: obj with get, set
        /// Gets or sets the size of the bounding box associated with the cube texture
        /// When defined, the cubemap will switch to local mode
        abstract boundingBoxSize: Vector3 with get, set
        /// Occurs when the file is a preprocessed .babylon.hdr file.
        abstract loadBabylonTexture: unit -> unit
        /// Occurs when the file is raw .hdr file.
        abstract loadHDRTexture: unit -> unit
        /// Starts the loading process of the texture.
        abstract loadTexture: unit -> unit
        abstract clone: unit -> HDRCubeTexture
        abstract delayLoad: unit -> unit
        abstract getReflectionTextureMatrix: unit -> Matrix
        abstract setReflectionTextureMatrix: value: Matrix -> unit
        abstract serialize: unit -> obj option

    /// This represents a texture coming from an HDR input.
    /// 
    /// The only supported format is currently panorama picture stored in RGBE format.
    /// Example of such files can be found on HDRLib: http://hdrlib.com/
    type [<AllowNullLiteral>] HDRCubeTextureStatic =
        /// <summary>Instantiates an HDRTexture from the following parameters.</summary>
        /// <param name="url">The location of the HDR raw data (Panorama stored in RGBE format)</param>
        /// <param name="scene">The scene the texture will be used in</param>
        /// <param name="size">The cubemap desired size (the more it increases the longer the generation will be) If the size is omitted this implies you are using a preprocessed cubemap.</param>
        /// <param name="noMipmap">Forces to not generate the mipmap if true</param>
        /// <param name="generateHarmonics">Specifies whether you want to extract the polynomial harmonics during the generation process</param>
        /// <param name="useInGammaSpace">Specifies if the texture will be use in gamma or linear space (the PBR material requires those texture in linear space, but the standard material would require them in Gamma space)</param>
        /// <param name="usePMREMGenerator">Specifies whether or not to generate the CubeMap through CubeMapGen to avoid seams issue at run time.</param>
        [<Emit "new $0($1...)">] abstract Create: url: string * scene: Scene * ?size: float * ?noMipmap: bool * ?generateHarmonics: bool * ?useInGammaSpace: bool * ?usePMREMGenerator: bool * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> -> HDRCubeTexture
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> Nullable<HDRCubeTexture>
        /// <summary>Saves as a file the data contained in the texture in a binary format.
        /// This can be used to prevent the long loading tie associated with creating the seamless texture as well
        /// as the spherical used in the lighting.</summary>
        /// <param name="url">The HDR file url.</param>
        /// <param name="size">The size of the texture data to generate (one of the cubemap face desired width).</param>
        /// <param name="onError">Method called if any error happens during download.</param>
        abstract generateBabylonHDROnDisk: url: string * size: float * ?onError: Nullable<(unit -> unit)> -> unit
        /// <summary>Serializes the data contained in the texture in a binary format.
        /// This can be used to prevent the long loading tie associated with creating the seamless texture as well
        /// as the spherical used in the lighting.</summary>
        /// <param name="url">The HDR file url.</param>
        /// <param name="size">The size of the texture data to generate (one of the cubemap face desired width).</param>
        /// <param name="onError">Method called if any error happens during download.</param>
        abstract generateBabylonHDR: url: string * size: float * callback: (ArrayBuffer -> unit) * ?onError: Nullable<(unit -> unit)> -> unit

    /// Class used to store data associated with WebGL texture data for the engine
    /// This class should not be used directly
    type [<AllowNullLiteral>] InternalTexture =
        inherit IInternalTextureTracker
        /// The source of the texture data is unknown
        abstract DATASOURCE_UNKNOWN: float with get, set
        /// Texture data comes from an URL
        abstract DATASOURCE_URL: float with get, set
        /// Texture data is only used for temporary storage
        abstract DATASOURCE_TEMP: float with get, set
        /// Texture data comes from raw data (ArrayBuffer)
        abstract DATASOURCE_RAW: float with get, set
        /// Texture content is dynamic (video or dynamic texture)
        abstract DATASOURCE_DYNAMIC: float with get, set
        /// Texture content is generated by rendering to it
        abstract DATASOURCE_RENDERTARGET: float with get, set
        /// Texture content is part of a multi render target process
        abstract DATASOURCE_MULTIRENDERTARGET: float with get, set
        /// Texture data comes from a cube data file
        abstract DATASOURCE_CUBE: float with get, set
        /// Texture data comes from a raw cube data
        abstract DATASOURCE_CUBERAW: float with get, set
        /// Texture data come from a prefiltered cube data file
        abstract DATASOURCE_CUBEPREFILTERED: float with get, set
        /// Texture content is raw 3D data
        abstract DATASOURCE_RAW3D: float with get, set
        /// Texture content is a depth texture
        abstract DATASOURCE_DEPTHTEXTURE: float with get, set
        /// Defines if the texture is ready
        abstract isReady: bool with get, set
        /// Defines if the texture is a cube texture
        abstract isCube: bool with get, set
        /// Defines if the texture contains 3D data
        abstract is3D: bool with get, set
        /// Gets the URL used to load this texture
        abstract url: string with get, set
        /// Gets the sampling mode of the texture
        abstract samplingMode: float with get, set
        /// Gets a boolean indicating if the texture needs mipmaps generation
        abstract generateMipMaps: bool with get, set
        /// Gets the number of samples used by the texture (WebGL2+ only)
        abstract samples: float with get, set
        /// Gets the type of the texture
        abstract ``type``: float with get, set
        /// Gets the format of the texture
        abstract format: float with get, set
        /// Observable called when the texture is loaded
        abstract onLoadedObservable: Observable<InternalTexture> with get, set
        /// Gets the width of the texture
        abstract width: float with get, set
        /// Gets the height of the texture
        abstract height: float with get, set
        /// Gets the depth of the texture
        abstract depth: float with get, set
        /// Gets the initial width of the texture (It could be rescaled if the current system does not support non power of two textures)
        abstract baseWidth: float with get, set
        /// Gets the initial height of the texture (It could be rescaled if the current system does not support non power of two textures)
        abstract baseHeight: float with get, set
        /// Gets the initial depth of the texture (It could be rescaled if the current system does not support non power of two textures)
        abstract baseDepth: float with get, set
        /// Gets a boolean indicating if the texture is inverted on Y axis
        abstract invertY: bool with get, set
        /// Gets or set the previous tracker in the list
        abstract previous: Nullable<IInternalTextureTracker> with get, set
        /// Gets or set the next tracker in the list
        abstract next: Nullable<IInternalTextureTracker> with get, set
        abstract _initialSlot: float with get, set
        abstract _designatedSlot: float with get, set
        abstract _dataSource: float with get, set
        abstract _buffer: Nullable<U2<ArrayBuffer, HTMLImageElement>> with get, set
        abstract _bufferView: Nullable<ArrayBufferView> with get, set
        abstract _bufferViewArray: Nullable<ResizeArray<ArrayBufferView>> with get, set
        abstract _size: float with get, set
        abstract _extension: string with get, set
        abstract _files: Nullable<ResizeArray<string>> with get, set
        abstract _workingCanvas: HTMLCanvasElement with get, set
        abstract _workingContext: CanvasRenderingContext2D with get, set
        abstract _framebuffer: Nullable<WebGLFramebuffer> with get, set
        abstract _depthStencilBuffer: Nullable<WebGLRenderbuffer> with get, set
        abstract _MSAAFramebuffer: Nullable<WebGLFramebuffer> with get, set
        abstract _MSAARenderBuffer: Nullable<WebGLRenderbuffer> with get, set
        abstract _attachments: Nullable<ResizeArray<float>> with get, set
        abstract _cachedCoordinatesMode: Nullable<float> with get, set
        abstract _cachedWrapU: Nullable<float> with get, set
        abstract _cachedWrapV: Nullable<float> with get, set
        abstract _cachedWrapR: Nullable<float> with get, set
        abstract _cachedAnisotropicFilteringLevel: Nullable<float> with get, set
        abstract _isDisabled: bool with get, set
        abstract _compression: Nullable<string> with get, set
        abstract _generateStencilBuffer: bool with get, set
        abstract _generateDepthBuffer: bool with get, set
        abstract _comparisonFunction: float with get, set
        abstract _sphericalPolynomial: Nullable<SphericalPolynomial> with get, set
        abstract _lodGenerationScale: float with get, set
        abstract _lodGenerationOffset: float with get, set
        abstract _lodTextureHigh: BaseTexture with get, set
        abstract _lodTextureMid: BaseTexture with get, set
        abstract _lodTextureLow: BaseTexture with get, set
        abstract _webGLTexture: Nullable<WebGLTexture> with get, set
        abstract _references: float with get, set
        abstract _engine: obj with get, set
        /// Gets the data source type of the texture (can be one of the BABYLON.InternalTexture.DATASOURCE_XXXX)
        abstract dataSource: float
        /// Increments the number of references (ie. the number of {BABYLON.Texture} that point to it)
        abstract incrementReferences: unit -> unit
        /// <summary>Change the size of the texture (not the size of the content)</summary>
        /// <param name="width">defines the new width</param>
        /// <param name="height">defines the new height</param>
        /// <param name="depth">defines the new depth (1 by default)</param>
        abstract updateSize: width: int * height: int * ?depth: int -> unit
        abstract _rebuild: unit -> unit
        abstract _swapAndDie: target: obj -> unit
        /// Dispose the current allocated resources
        abstract dispose: unit -> unit

    /// Class used to store data associated with WebGL texture data for the engine
    /// This class should not be used directly
    type [<AllowNullLiteral>] InternalTextureStatic =
        /// <summary>Creates a new InternalTexture</summary>
        /// <param name="engine">defines the engine to use</param>
        /// <param name="dataSource">defines the type of data that will be used</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * dataSource: float -> InternalTexture

    /// Internal interface used to track {BABYLON.InternalTexture} already bound to the GL context
    type [<AllowNullLiteral>] IInternalTextureTracker =
        /// Gets or set the previous tracker in the list
        abstract previous: Nullable<IInternalTextureTracker> with get, set
        /// Gets or set the next tracker in the list
        abstract next: Nullable<IInternalTextureTracker> with get, set

    /// Internal class used by the engine to get list of {BABYLON.InternalTexture} already bound to the GL context
    type [<AllowNullLiteral>] DummyInternalTextureTracker =
        /// Gets or set the previous tracker in the list
        abstract previous: Nullable<IInternalTextureTracker> with get, set
        /// Gets or set the next tracker in the list
        abstract next: Nullable<IInternalTextureTracker> with get, set

    /// Internal class used by the engine to get list of {BABYLON.InternalTexture} already bound to the GL context
    type [<AllowNullLiteral>] DummyInternalTextureTrackerStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> DummyInternalTextureTracker

    type [<AllowNullLiteral>] MirrorTexture =
        inherit RenderTargetTexture
        abstract scene: obj with get, set
        abstract mirrorPlane: Plane with get, set
        abstract _transformMatrix: obj with get, set
        abstract _mirrorMatrix: obj with get, set
        abstract _savedViewMatrix: obj with get, set
        abstract _blurX: obj with get, set
        abstract _blurY: obj with get, set
        abstract _adaptiveBlurKernel: obj with get, set
        abstract _blurKernelX: obj with get, set
        abstract _blurKernelY: obj with get, set
        abstract _blurRatio: obj with get, set
        abstract blurRatio: float with get, set
        abstract adaptiveBlurKernel: float with get, set
        abstract blurKernel: float with get, set
        abstract blurKernelX: float with get, set
        abstract blurKernelY: float with get, set
        abstract _autoComputeBlurKernel: unit -> unit
        abstract _onRatioRescale: unit -> unit
        abstract _updateGammaSpace: unit -> unit
        abstract _imageProcessingConfigChangeObserver: obj with get, set
        abstract _preparePostProcesses: unit -> unit
        abstract clone: unit -> MirrorTexture
        abstract serialize: unit -> obj option
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] MirrorTextureStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * size: U3<float, obj, obj> * scene: Scene * ?generateMipMaps: bool * ?``type``: float * ?samplingMode: float * ?generateDepthBuffer: bool -> MirrorTexture

    type [<AllowNullLiteral>] IMultiRenderTargetOptions =
        abstract generateMipMaps: bool option with get, set
        abstract types: ResizeArray<float> option with get, set
        abstract samplingModes: ResizeArray<float> option with get, set
        abstract generateDepthBuffer: bool option with get, set
        abstract generateStencilBuffer: bool option with get, set
        abstract generateDepthTexture: bool option with get, set
        abstract textureCount: float option with get, set
        abstract doNotChangeAspectRatio: bool option with get, set
        abstract defaultType: float option with get, set

    type [<AllowNullLiteral>] MultiRenderTarget =
        inherit RenderTargetTexture
        abstract _internalTextures: obj with get, set
        abstract _textures: obj with get, set
        abstract isSupported: bool
        abstract _multiRenderTargetOptions: obj with get, set
        abstract textures: ResizeArray<Texture>
        abstract depthTexture: Texture
        abstract wrapU: float with get, set
        abstract wrapV: float with get, set
        abstract _rebuild: unit -> unit
        abstract _createInternalTextures: unit -> unit
        abstract _createTextures: unit -> unit
        abstract samples: float with get, set
        abstract resize: size: obj option -> unit
        abstract unbindFrameBuffer: engine: Engine * faceIndex: float -> unit
        abstract dispose: unit -> unit
        abstract releaseInternalTextures: unit -> unit

    type [<AllowNullLiteral>] MultiRenderTargetStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * size: obj option * count: float * scene: Scene * ?options: IMultiRenderTargetOptions -> MultiRenderTarget

    type [<AllowNullLiteral>] RawTexture =
        inherit Texture
        abstract format: float with get, set
        abstract _engine: obj with get, set
        abstract update: data: ArrayBufferView -> unit

    type [<AllowNullLiteral>] RawTextureStatic =
        [<Emit "new $0($1...)">] abstract Create: data: ArrayBufferView * width: float * height: float * format: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?``type``: float -> RawTexture
        abstract CreateLuminanceTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float -> RawTexture
        abstract CreateLuminanceAlphaTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float -> RawTexture
        abstract CreateAlphaTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float -> RawTexture
        abstract CreateRGBTexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?``type``: float -> RawTexture
        abstract CreateRGBATexture: data: ArrayBufferView * width: float * height: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?``type``: float -> RawTexture

    /// Class used to store 3D textures containing user data
    type [<AllowNullLiteral>] RawTexture3D =
        inherit Texture
        /// Gets or sets the texture format to use
        abstract format: float with get, set
        abstract _engine: obj with get, set
        /// <summary>Update the texture with new data</summary>
        /// <param name="data">defines the data to store in the texture</param>
        abstract update: data: ArrayBufferView -> unit

    /// Class used to store 3D textures containing user data
    type [<AllowNullLiteral>] RawTexture3DStatic =
        /// <summary>Create a new RawTexture3D</summary>
        /// <param name="data">defines the data of the texture</param>
        /// <param name="width">defines the width of the texture</param>
        /// <param name="height">defines the height of the texture</param>
        /// <param name="depth">defines the depth of the texture</param>
        /// <param name="format">defines the texture format to use</param>
        /// <param name="scene">defines the hosting scene</param>
        /// <param name="generateMipMaps">defines a boolean indicating if mip levels should be generated (true by default)</param>
        /// <param name="invertY">defines if texture must be stored with Y axis inverted</param>
        /// <param name="samplingMode">defines the sampling mode to use (BABYLON.Texture.TRILINEAR_SAMPLINGMODE by default)</param>
        [<Emit "new $0($1...)">] abstract Create: data: ArrayBufferView * width: float * height: float * depth: float * format: float * scene: Scene * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float -> RawTexture3D

    /// Creates a refraction texture used by refraction channel of the standard material.
    type [<AllowNullLiteral>] RefractionTexture =
        inherit RenderTargetTexture
        abstract refractionPlane: Plane with get, set
        abstract depth: float with get, set
        abstract clone: unit -> RefractionTexture
        abstract serialize: unit -> obj option

    /// Creates a refraction texture used by refraction channel of the standard material.
    type [<AllowNullLiteral>] RefractionTextureStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * size: float * scene: Scene * ?generateMipMaps: bool -> RefractionTexture

    type [<AllowNullLiteral>] RenderTargetTexture =
        inherit Texture
        abstract isCube: bool with get, set
        abstract _REFRESHRATE_RENDER_ONCE: float with get, set
        abstract _REFRESHRATE_RENDER_ONEVERYFRAME: float with get, set
        abstract _REFRESHRATE_RENDER_ONEVERYTWOFRAMES: float with get, set
        abstract REFRESHRATE_RENDER_ONCE: float
        abstract REFRESHRATE_RENDER_ONEVERYFRAME: float
        abstract REFRESHRATE_RENDER_ONEVERYTWOFRAMES: float
        /// Use this predicate to dynamically define the list of mesh you want to render.
        /// If set, the renderList property will be overwritten.
        abstract renderListPredicate: (AbstractMesh -> bool) with get, set
        /// Use this list to define the list of mesh you want to render.
        abstract renderList: Nullable<Array<AbstractMesh>> with get, set
        abstract renderParticles: bool with get, set
        abstract renderSprites: bool with get, set
        abstract coordinatesMode: float with get, set
        abstract activeCamera: Nullable<Camera> with get, set
        abstract customRenderFunction: (SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> SmartArray<SubMesh> -> (unit -> unit) -> unit) with get, set
        abstract useCameraPostProcesses: bool with get, set
        abstract ignoreCameraViewport: bool with get, set
        abstract _postProcessManager: obj with get, set
        abstract _postProcesses: obj with get, set
        abstract _resizeObserver: obj with get, set
        /// An event triggered when the texture is unbind.
        abstract onBeforeBindObservable: Observable<RenderTargetTexture> with get, set
        /// An event triggered when the texture is unbind.
        abstract onAfterUnbindObservable: Observable<RenderTargetTexture> with get, set
        abstract _onAfterUnbindObserver: obj with get, set
        abstract onAfterUnbind: (unit -> unit) with get, set
        /// An event triggered before rendering the texture
        abstract onBeforeRenderObservable: Observable<float> with get, set
        abstract _onBeforeRenderObserver: obj with get, set
        abstract onBeforeRender: (float -> unit) with get, set
        /// An event triggered after rendering the texture
        abstract onAfterRenderObservable: Observable<float> with get, set
        abstract _onAfterRenderObserver: obj with get, set
        abstract onAfterRender: (float -> unit) with get, set
        /// An event triggered after the texture clear
        abstract onClearObservable: Observable<Engine> with get, set
        abstract _onClearObserver: obj with get, set
        abstract onClear: (Engine -> unit) with get, set
        abstract clearColor: Color4 with get, set
        abstract _size: U2<float, obj> with get, set
        abstract _initialSizeParameter: U3<float, obj, obj> with get, set
        abstract _sizeRatio: Nullable<float> with get, set
        abstract _generateMipMaps: bool with get, set
        abstract _renderingManager: RenderingManager with get, set
        abstract _waitingRenderList: ResizeArray<string> with get, set
        abstract _doNotChangeAspectRatio: bool with get, set
        abstract _currentRefreshId: float with get, set
        abstract _refreshRate: float with get, set
        abstract _textureMatrix: Matrix with get, set
        abstract _samples: float with get, set
        abstract _renderTargetOptions: RenderTargetCreationOptions with get, set
        abstract renderTargetOptions: RenderTargetCreationOptions
        abstract _engine: Engine with get, set
        abstract _onRatioRescale: unit -> unit
        /// Gets or sets the center of the bounding box associated with the texture (when in cube mode)
        /// It must define where the camera used to render the texture is set
        abstract boundingBoxPosition: Vector3 with get, set
        abstract _boundingBoxSize: obj with get, set
        /// Gets or sets the size of the bounding box associated with the texture (when in cube mode)
        /// When defined, the cubemap will switch to local mode
        abstract boundingBoxSize: Vector3 with get, set
        /// In case the RTT has been created with a depth texture, get the associated
        /// depth texture.
        /// Otherwise, return null.
        abstract depthStencilTexture: Nullable<InternalTexture> with get, set
        /// <summary>Creates a depth stencil texture.
        /// This is only available in WebGL 2 or with the depth texture extension available.</summary>
        /// <param name="comparisonFunction">Specifies the comparison function to set on the texture. If 0 or undefined, the texture is not in comparison mode</param>
        /// <param name="bilinearFiltering">Specifies whether or not bilinear filtering is enable on the texture</param>
        /// <param name="generateStencil">Specifies whether or not a stencil should be allocated in the texture</param>
        abstract createDepthStencilTexture: ?comparisonFunction: float * ?bilinearFiltering: bool * ?generateStencil: bool -> unit
        abstract _processSizeParameter: size: obj -> unit
        abstract samples: float with get, set
        abstract resetRefreshCounter: unit -> unit
        abstract refreshRate: float with get, set
        abstract addPostProcess: postProcess: PostProcess -> unit
        abstract clearPostProcesses: ?dispose: bool -> unit
        abstract removePostProcess: postProcess: PostProcess -> unit
        abstract _shouldRender: unit -> bool
        abstract getRenderSize: unit -> float
        abstract getRenderWidth: unit -> float
        abstract getRenderHeight: unit -> float
        abstract canRescale: bool
        abstract scale: ratio: float -> unit
        abstract getReflectionTextureMatrix: unit -> Matrix
        abstract resize: size: U3<float, obj, obj> -> unit
        abstract render: ?useCameraPostProcess: bool * ?dumpForDebug: bool -> unit
        abstract _bestReflectionRenderTargetDimension: renderDimension: obj * scale: obj -> unit
        abstract unbindFrameBuffer: engine: Engine * faceIndex: float -> unit
        abstract renderToTarget: faceIndex: obj * currentRenderList: obj * currentRenderListLength: obj * useCameraPostProcess: obj * dumpForDebug: obj -> unit
        /// <summary>Overrides the default sort function applied in the renderging group to prepare the meshes.
        /// This allowed control for front to back rendering or reversly depending of the special needs.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="opaqueSortCompareFn">The opaque queue comparison function use to sort.</param>
        /// <param name="alphaTestSortCompareFn">The alpha test queue comparison function use to sort.</param>
        /// <param name="transparentSortCompareFn">The transparent queue comparison function use to sort.</param>
        abstract setRenderingOrder: renderingGroupId: float * ?opaqueSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?alphaTestSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> * ?transparentSortCompareFn: Nullable<(SubMesh -> SubMesh -> float)> -> unit
        /// <summary>Specifies whether or not the stencil and depth buffer are cleared between two rendering groups.</summary>
        /// <param name="renderingGroupId">The rendering group id corresponding to its index</param>
        /// <param name="autoClearDepthStencil">Automatically clears depth and stencil between groups if true.</param>
        abstract setRenderingAutoClearDepthStencil: renderingGroupId: float * autoClearDepthStencil: bool -> unit
        abstract clone: unit -> RenderTargetTexture
        abstract serialize: unit -> obj option
        abstract disposeFramebufferObjects: unit -> unit
        abstract dispose: unit -> unit
        abstract _rebuild: unit -> unit
        /// Clear the info related to rendering groups preventing retention point in material dispose.
        abstract freeRenderingGroups: unit -> unit

    type [<AllowNullLiteral>] RenderTargetTextureStatic =
        /// <summary>Instantiate a render target texture. This is mainly to render of screen the scene to for instance apply post processse
        /// or used a shadow, depth texture...</summary>
        /// <param name="name">The friendly name of the texture</param>
        /// <param name="size">The size of the RTT (number if square, or {with: number, height:number} or {ratio:} to define a ratio from the main scene)</param>
        /// <param name="scene">The scene the RTT belongs to. The latest created scene will be used if not precised.</param>
        /// <param name="generateMipMaps">True if mip maps need to be generated after render.</param>
        /// <param name="doNotChangeAspectRatio">True to not change the aspect ratio of the scene in the RTT</param>
        /// <param name="type">The type of the buffer in the RTT (int, half float, float...)</param>
        /// <param name="isCube">True if a cube texture needs to be created</param>
        /// <param name="samplingMode">The sampling mode to be usedwith the render target (Linear, Nearest...)</param>
        /// <param name="generateDepthBuffer">True to generate a depth buffer</param>
        /// <param name="generateStencilBuffer">True to generate a stencil buffer</param>
        /// <param name="isMulti">True if multiple textures need to be created (Draw Buffers)</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * size: U3<float, obj, obj> * scene: Nullable<Scene> * ?generateMipMaps: bool * ?doNotChangeAspectRatio: bool * ?``type``: float * ?isCube: bool * ?samplingMode: float * ?generateDepthBuffer: bool * ?generateStencilBuffer: bool * ?isMulti: bool -> RenderTargetTexture

    type [<AllowNullLiteral>] Texture =
        inherit BaseTexture
        abstract NEAREST_SAMPLINGMODE: float with get, set
        abstract NEAREST_NEAREST_MIPLINEAR: float with get, set
        abstract BILINEAR_SAMPLINGMODE: float with get, set
        abstract LINEAR_LINEAR_MIPNEAREST: float with get, set
        abstract TRILINEAR_SAMPLINGMODE: float with get, set
        abstract LINEAR_LINEAR_MIPLINEAR: float with get, set
        abstract NEAREST_NEAREST_MIPNEAREST: float with get, set
        abstract NEAREST_LINEAR_MIPNEAREST: float with get, set
        abstract NEAREST_LINEAR_MIPLINEAR: float with get, set
        abstract NEAREST_LINEAR: float with get, set
        abstract NEAREST_NEAREST: float with get, set
        abstract LINEAR_NEAREST_MIPNEAREST: float with get, set
        abstract LINEAR_NEAREST_MIPLINEAR: float with get, set
        abstract LINEAR_LINEAR: float with get, set
        abstract LINEAR_NEAREST: float with get, set
        abstract EXPLICIT_MODE: float with get, set
        abstract SPHERICAL_MODE: float with get, set
        abstract PLANAR_MODE: float with get, set
        abstract CUBIC_MODE: float with get, set
        abstract PROJECTION_MODE: float with get, set
        abstract SKYBOX_MODE: float with get, set
        abstract INVCUBIC_MODE: float with get, set
        abstract EQUIRECTANGULAR_MODE: float with get, set
        abstract FIXED_EQUIRECTANGULAR_MODE: float with get, set
        abstract FIXED_EQUIRECTANGULAR_MIRRORED_MODE: float with get, set
        abstract CLAMP_ADDRESSMODE: float with get, set
        abstract WRAP_ADDRESSMODE: float with get, set
        abstract MIRROR_ADDRESSMODE: float with get, set
        /// Gets or sets a boolean which defines if the texture url must be build from the serialized URL instead of just using the name and loading them side by side with the scene file
        abstract UseSerializedUrlIfAny: bool with get, set
        abstract url: Nullable<string> with get, set
        abstract uOffset: float with get, set
        abstract vOffset: float with get, set
        abstract uScale: float with get, set
        abstract vScale: float with get, set
        abstract uAng: float with get, set
        abstract vAng: float with get, set
        abstract wAng: float with get, set
        abstract noMipmap: bool
        abstract _noMipmap: obj with get, set
        abstract _invertY: bool with get, set
        abstract _rowGenerationMatrix: obj with get, set
        abstract _cachedTextureMatrix: obj with get, set
        abstract _projectionModeMatrix: obj with get, set
        abstract _t0: obj with get, set
        abstract _t1: obj with get, set
        abstract _t2: obj with get, set
        abstract _cachedUOffset: obj with get, set
        abstract _cachedVOffset: obj with get, set
        abstract _cachedUScale: obj with get, set
        abstract _cachedVScale: obj with get, set
        abstract _cachedUAng: obj with get, set
        abstract _cachedVAng: obj with get, set
        abstract _cachedWAng: obj with get, set
        abstract _cachedProjectionMatrixId: obj with get, set
        abstract _cachedCoordinatesMode: obj with get, set
        abstract _samplingMode: float with get, set
        abstract _buffer: obj with get, set
        abstract _deleteBuffer: obj with get, set
        abstract _format: Nullable<float> with get, set
        abstract _delayedOnLoad: obj with get, set
        abstract _delayedOnError: obj with get, set
        abstract _onLoadObservable: Nullable<Observable<Texture>> with get, set
        abstract _isBlocking: bool with get, set
        abstract isBlocking: bool with get, set
        abstract samplingMode: float
        abstract updateURL: url: string -> unit
        abstract delayLoad: unit -> unit
        abstract updateSamplingMode: samplingMode: float -> unit
        abstract _prepareRowForTextureGeneration: x: obj * y: obj * z: obj * t: obj -> unit
        abstract getTextureMatrix: unit -> Matrix
        abstract getReflectionTextureMatrix: unit -> Matrix
        abstract clone: unit -> Texture
        abstract onLoadObservable: Observable<Texture>
        abstract serialize: unit -> obj option
        abstract getClassName: unit -> string
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] TextureStatic =
        [<Emit "new $0($1...)">] abstract Create: url: Nullable<string> * scene: Nullable<Scene> * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?buffer: obj option * ?deleteBuffer: bool * ?format: float -> Texture
        abstract CreateFromBase64String: data: string * name: string * scene: Scene * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(unit -> unit)> * ?format: float -> Texture
        abstract Parse: parsedTexture: obj option * scene: Scene * rootUrl: string -> Nullable<BaseTexture>
        abstract LoadFromDataString: name: string * buffer: obj option * scene: Scene * ?deleteBuffer: bool * ?noMipmap: bool * ?invertY: bool * ?samplingMode: float * ?onLoad: Nullable<(unit -> unit)> * ?onError: Nullable<(string -> obj option -> unit)> * ?format: float -> Texture

    /// Settings for finer control over video usage
    type [<AllowNullLiteral>] VideoTextureSettings =
        /// Applies `autoplay` to video, if specified
        abstract autoPlay: bool option with get, set
        /// Applies `loop` to video, if specified
        abstract loop: bool option with get, set
        /// Automatically updates internal texture from video at every frame in the render loop
        abstract autoUpdateTexture: bool with get, set

    type [<AllowNullLiteral>] VideoTexture =
        inherit Texture
        /// Tells whether textures will be updated automatically or user is required to call `updateTexture` manually
        abstract autoUpdateTexture: bool
        /// The video instance used by the texture internally
        abstract video: HTMLVideoElement
        abstract _generateMipMaps: obj with get, set
        abstract _engine: obj with get, set
        abstract _getName: src: obj -> unit
        abstract _getVideo: src: obj -> unit
        abstract _createInternalTexture: obj with get, set
        abstract reset: obj with get, set
        /// Internal method to initiate `update`.
        abstract _rebuild: unit -> unit
        /// Update Texture in the `auto` mode. Does not do anything if `settings.autoUpdateTexture` is false.
        abstract update: unit -> unit
        /// <summary>Update Texture in `manual` mode. Does not do anything if not visible or paused.</summary>
        /// <param name="isVisible">Visibility state, detected by user using `scene.getActiveMeshes()` or othervise.</param>
        abstract updateTexture: isVisible: bool -> unit
        abstract _updateInternalTexture: (Event option -> unit) with get, set
        /// <summary>Change video content. Changing video instance or setting multiple urls (as in constructor) is not supported.</summary>
        /// <param name="url">New url.</param>
        abstract updateURL: url: string -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] VideoTextureStatic =
        /// <summary>Creates a video texture.
        /// Sample : https://doc.babylonjs.com/how_to/video_texture</summary>
        /// <param name="name">optional name, will detect from video source, if not defined</param>
        /// <param name="src">can be used to provide an url, array of urls or an already setup HTML video element.</param>
        /// <param name="scene">is obviously the current scene.</param>
        /// <param name="generateMipMaps">can be used to turn on mipmaps (Can be expensive for videoTextures because they are often updated).</param>
        /// <param name="invertY">is false by default but can be used to invert video on Y axis</param>
        /// <param name="samplingMode">controls the sampling method and is set to TRILINEAR_SAMPLINGMODE by default</param>
        /// <param name="settings">allows finer control over video usage</param>
        [<Emit "new $0($1...)">] abstract Create: name: Nullable<string> * src: U3<string, ResizeArray<string>, HTMLVideoElement> * scene: Nullable<Scene> * ?generateMipMaps: bool * ?invertY: bool * ?samplingMode: float * ?settings: VideoTextureSettings -> VideoTexture
        abstract CreateFromWebCam: scene: Scene * onReady: (VideoTexture -> unit) * constraints: VideoTextureStaticCreateFromWebCamConstraints -> unit

    type [<AllowNullLiteral>] VideoTextureStaticCreateFromWebCamConstraints =
        abstract minWidth: float with get, set
        abstract maxWidth: float with get, set
        abstract minHeight: float with get, set
        abstract maxHeight: float with get, set
        abstract deviceId: string with get, set

    /// Particle emitter emitting particles from the inside of a box.
    /// It emits the particles randomly between 2 given directions.
    type [<AllowNullLiteral>] BoxParticleEmitter =
        inherit IParticleEmitterType
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        abstract direction1: Vector3 with get, set
        /// Random direction of each particle after it has been emitted, between direction1 and direction2 vectors.
        abstract direction2: Vector3 with get, set
        /// Minimum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        abstract minEmitBox: Vector3 with get, set
        /// Maximum box point around our emitter. Our emitter is the center of particles source, but if you want your particles to emit from more than one point, then you can tell it to do so.
        abstract maxEmitBox: Vector3 with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="emitPower">is the power of the particle (speed)</param>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: emitPower: float * worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> BoxParticleEmitter
        /// <summary>Called by the {BABYLON.GPUParticleSystem} to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "BoxEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a box.
    /// It emits the particles randomly between 2 given directions.
    type [<AllowNullLiteral>] BoxParticleEmitterStatic =
        /// Creates a new instance BoxParticleEmitter
        [<Emit "new $0($1...)">] abstract Create: unit -> BoxParticleEmitter

    /// Particle emitter emitting particles from the inside of a cone.
    /// It emits the particles alongside the cone volume from the base to the particle.
    /// The emission direction might be randomized.
    type [<AllowNullLiteral>] ConeParticleEmitter =
        inherit IParticleEmitterType
        /// The radius of the emission cone.
        abstract angle: float with get, set
        /// The cone base angle.
        abstract directionRandomizer: float with get, set
        abstract _radius: obj with get, set
        abstract _height: obj with get, set
        /// Gets the radius of the emission cone.
        /// Sets the radius of the emission cone.
        abstract radius: float with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="emitPower">is the power of the particle (speed)</param>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: emitPower: float * worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> ConeParticleEmitter
        /// <summary>Called by the {BABYLON.GPUParticleSystem} to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "BoxEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a cone.
    /// It emits the particles alongside the cone volume from the base to the particle.
    /// The emission direction might be randomized.
    type [<AllowNullLiteral>] ConeParticleEmitterStatic =
        /// <summary>Creates a new instance ConeParticleEmitter</summary>
        /// <param name="radius">the radius of the emission cone (1 by default)</param>
        /// <param name="directionRandomizer">defines how much to randomize the particle direction [0-1]</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?angle: float * ?directionRandomizer: float -> ConeParticleEmitter

    /// Particle emitter represents a volume emitting particles.
    /// This is the responsibility of the implementation to define the volume shape like cone/sphere/box.
    type [<AllowNullLiteral>] IParticleEmitterType =
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="emitPower">is the power of the particle (speed)</param>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: emitPower: float * worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> IParticleEmitterType
        /// <summary>Called by the {BABYLON.GPUParticleSystem} to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns a string representing the class name
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles alongside the sphere radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] SphereParticleEmitter =
        inherit IParticleEmitterType
        /// The radius of the emission sphere.
        abstract radius: float with get, set
        /// How much to randomize the particle direction [0-1].
        abstract directionRandomizer: float with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="emitPower">is the power of the particle (speed)</param>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: emitPower: float * worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// <summary>Called by the particle System when the position is computed for the created particle.</summary>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="positionToUpdate">is the position vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the position for</param>
        abstract startPositionFunction: worldMatrix: Matrix * positionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> SphereParticleEmitter
        /// <summary>Called by the {BABYLON.GPUParticleSystem} to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "SphereParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles alongside the sphere radius. The emission direction might be randomized.
    type [<AllowNullLiteral>] SphereParticleEmitterStatic =
        /// <summary>Creates a new instance SphereParticleEmitter</summary>
        /// <param name="radius">the radius of the emission sphere (1 by default)</param>
        /// <param name="directionRandomizer">defines how much to randomize the particle direction [0-1]</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?directionRandomizer: float -> SphereParticleEmitter

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles randomly between two vectors.
    type [<AllowNullLiteral>] SphereDirectedParticleEmitter =
        inherit SphereParticleEmitter
        /// The min limit of the emission direction.
        abstract direction1: Vector3 with get, set
        /// The max limit of the emission direction.
        abstract direction2: Vector3 with get, set
        /// <summary>Called by the particle System when the direction is computed for the created particle.</summary>
        /// <param name="emitPower">is the power of the particle (speed)</param>
        /// <param name="worldMatrix">is the world matrix of the particle system</param>
        /// <param name="directionToUpdate">is the direction vector to update with the result</param>
        /// <param name="particle">is the particle we are computed the direction for</param>
        abstract startDirectionFunction: emitPower: float * worldMatrix: Matrix * directionToUpdate: Vector3 * particle: Particle -> unit
        /// Clones the current emitter and returns a copy of it
        abstract clone: unit -> SphereDirectedParticleEmitter
        /// <summary>Called by the {BABYLON.GPUParticleSystem} to setup the update shader</summary>
        /// <param name="effect">defines the update shader</param>
        abstract applyToShader: effect: Effect -> unit
        /// Returns a string to use to update the GPU particles update shader
        abstract getEffectDefines: unit -> string
        /// Returns the string "SphereDirectedParticleEmitter"
        abstract getClassName: unit -> string
        /// Serializes the particle system to a JSON object.
        abstract serialize: unit -> obj option
        /// <summary>Parse properties from a JSON object</summary>
        /// <param name="serializationObject">defines the JSON object</param>
        abstract parse: serializationObject: obj option -> unit

    /// Particle emitter emitting particles from the inside of a sphere.
    /// It emits the particles randomly between two vectors.
    type [<AllowNullLiteral>] SphereDirectedParticleEmitterStatic =
        /// <summary>Creates a new instance SphereDirectedParticleEmitter</summary>
        /// <param name="radius">the radius of the emission sphere (1 by default)</param>
        /// <param name="direction1">the min limit of the emission direction (up vector by default)</param>
        /// <param name="direction2">the max limit of the emission direction (up vector by default)</param>
        [<Emit "new $0($1...)">] abstract Create: ?radius: float * ?direction1: Vector3 * ?direction2: Vector3 -> SphereDirectedParticleEmitter

    type [<AllowNullLiteral>] CannonJSPlugin =
        inherit IPhysicsEnginePlugin
        abstract _useDeltaForWorldStep: obj with get, set
        abstract world: obj option with get, set
        abstract name: string with get, set
        abstract _physicsMaterials: obj with get, set
        abstract _fixedTimeStep: obj with get, set
        abstract BJSCANNON: obj option with get, set
        abstract setGravity: gravity: Vector3 -> unit
        abstract setTimeStep: timeStep: float -> unit
        abstract getTimeStep: unit -> float
        abstract executeStep: delta: float * impostors: Array<PhysicsImpostor> -> unit
        abstract applyImpulse: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract applyForce: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract generatePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract _processChildMeshes: mainImpostor: obj -> unit
        abstract removePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract generateJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract removeJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract _addMaterial: name: obj * friction: obj * restitution: obj -> unit
        abstract _checkWithEpsilon: value: obj -> unit
        abstract _createShape: impostor: obj -> unit
        abstract _createHeightmap: ``object``: obj * ?pointDepth: obj -> unit
        abstract _minus90X: obj with get, set
        abstract _plus90X: obj with get, set
        abstract _tmpPosition: obj with get, set
        abstract _tmpDeltaPosition: obj with get, set
        abstract _tmpUnityRotation: obj with get, set
        abstract _updatePhysicsBodyTransformation: impostor: obj -> unit
        abstract setTransformationFromPhysicsBody: impostor: PhysicsImpostor -> unit
        abstract setPhysicsBodyTransformation: impostor: PhysicsImpostor * newPosition: Vector3 * newRotation: Quaternion -> unit
        abstract isSupported: unit -> bool
        abstract setLinearVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract setAngularVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract getLinearVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract getAngularVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract setBodyMass: impostor: PhysicsImpostor * mass: float -> unit
        abstract getBodyMass: impostor: PhysicsImpostor -> float
        abstract getBodyFriction: impostor: PhysicsImpostor -> float
        abstract setBodyFriction: impostor: PhysicsImpostor * friction: float -> unit
        abstract getBodyRestitution: impostor: PhysicsImpostor -> float
        abstract setBodyRestitution: impostor: PhysicsImpostor * restitution: float -> unit
        abstract sleepBody: impostor: PhysicsImpostor -> unit
        abstract wakeUpBody: impostor: PhysicsImpostor -> unit
        abstract updateDistanceJoint: joint: PhysicsJoint * maxDistance: float * ?minDistance: float -> unit
        abstract setMotor: joint: IMotorEnabledJoint * ?speed: float * ?maxForce: float * ?motorIndex: float -> unit
        abstract setLimit: joint: IMotorEnabledJoint * upperLimit: float * ?lowerLimit: float -> unit
        abstract syncMeshWithImpostor: mesh: AbstractMesh * impostor: PhysicsImpostor -> unit
        abstract getRadius: impostor: PhysicsImpostor -> float
        abstract getBoxSizeToRef: impostor: PhysicsImpostor * result: Vector3 -> unit
        abstract dispose: unit -> unit
        abstract _extendNamespace: unit -> unit

    type [<AllowNullLiteral>] CannonJSPluginStatic =
        [<Emit "new $0($1...)">] abstract Create: ?_useDeltaForWorldStep: bool * ?iterations: float -> CannonJSPlugin

    type [<AllowNullLiteral>] OimoJSPlugin =
        inherit IPhysicsEnginePlugin
        abstract world: obj option with get, set
        abstract name: string with get, set
        abstract BJSOIMO: obj option with get, set
        abstract setGravity: gravity: Vector3 -> unit
        abstract setTimeStep: timeStep: float -> unit
        abstract getTimeStep: unit -> float
        abstract _tmpImpostorsArray: obj with get, set
        abstract executeStep: delta: float * impostors: Array<PhysicsImpostor> -> unit
        abstract applyImpulse: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract applyForce: impostor: PhysicsImpostor * force: Vector3 * contactPoint: Vector3 -> unit
        abstract generatePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract _tmpPositionVector: obj with get, set
        abstract removePhysicsBody: impostor: PhysicsImpostor -> unit
        abstract generateJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract removeJoint: impostorJoint: PhysicsImpostorJoint -> unit
        abstract isSupported: unit -> bool
        abstract setTransformationFromPhysicsBody: impostor: PhysicsImpostor -> unit
        abstract setPhysicsBodyTransformation: impostor: PhysicsImpostor * newPosition: Vector3 * newRotation: Quaternion -> unit
        abstract setLinearVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract setAngularVelocity: impostor: PhysicsImpostor * velocity: Vector3 -> unit
        abstract getLinearVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract getAngularVelocity: impostor: PhysicsImpostor -> Nullable<Vector3>
        abstract setBodyMass: impostor: PhysicsImpostor * mass: float -> unit
        abstract getBodyMass: impostor: PhysicsImpostor -> float
        abstract getBodyFriction: impostor: PhysicsImpostor -> float
        abstract setBodyFriction: impostor: PhysicsImpostor * friction: float -> unit
        abstract getBodyRestitution: impostor: PhysicsImpostor -> float
        abstract setBodyRestitution: impostor: PhysicsImpostor * restitution: float -> unit
        abstract sleepBody: impostor: PhysicsImpostor -> unit
        abstract wakeUpBody: impostor: PhysicsImpostor -> unit
        abstract updateDistanceJoint: joint: PhysicsJoint * maxDistance: float * ?minDistance: float -> unit
        abstract setMotor: joint: IMotorEnabledJoint * speed: float * ?maxForce: float * ?motorIndex: float -> unit
        abstract setLimit: joint: IMotorEnabledJoint * upperLimit: float * ?lowerLimit: float * ?motorIndex: float -> unit
        abstract syncMeshWithImpostor: mesh: AbstractMesh * impostor: PhysicsImpostor -> unit
        abstract getRadius: impostor: PhysicsImpostor -> float
        abstract getBoxSizeToRef: impostor: PhysicsImpostor * result: Vector3 -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] OimoJSPluginStatic =
        [<Emit "new $0($1...)">] abstract Create: ?iterations: float -> OimoJSPlugin

    /// Configuration for Draco compression
    type [<AllowNullLiteral>] IDracoCompressionConfiguration =
        /// Configuration for the decoder.
        abstract decoder: obj option with get, set

    /// Draco compression (https://google.github.io/draco/)
    type [<AllowNullLiteral>] DracoCompression =
        inherit IDisposable
        abstract _DecoderModulePromise: obj with get, set
        /// The configuration.
        abstract Configuration: IDracoCompressionConfiguration with get, set
        /// Returns true if the decoder is available.
        abstract DecoderAvailable: bool
        /// Stop all async operations and release resources.
        abstract dispose: unit -> unit
        /// <summary>Decode Draco compressed mesh data to vertex data.</summary>
        /// <param name="data">The array buffer view for the Draco compression data</param>
        /// <param name="attributes">A map of attributes from vertex buffer kinds to Draco unique ids</param>
        abstract decodeMeshAsync: data: ArrayBufferView * attributes: DracoCompressionDecodeMeshAsyncAttributes -> Promise<VertexData>

    type [<AllowNullLiteral>] DracoCompressionDecodeMeshAsyncAttributes =
        [<Emit "$0[$1]{{=$2}}">] abstract Item: kind: string -> float with get, set

    /// Draco compression (https://google.github.io/draco/)
    type [<AllowNullLiteral>] DracoCompressionStatic =
        /// Constructor
        [<Emit "new $0($1...)">] abstract Create: unit -> DracoCompression
        abstract _GetDecoderModule: unit -> unit
        abstract _LoadScriptAsync: url: obj -> unit
        abstract _LoadFileAsync: url: obj -> unit

    /// This represents a set of one or more post processes in Babylon.
    /// A post process can be used to apply a shader to a texture after it is rendered.
    type [<AllowNullLiteral>] PostProcessRenderEffect =
        abstract _postProcesses: obj with get, set
        abstract _getPostProcesses: obj with get, set
        abstract _singleInstance: obj with get, set
        abstract _cameras: obj with get, set
        abstract _indicesForCamera: obj with get, set
        /// Name of the effect
        abstract _name: string with get, set
        /// Checks if all the post processes in the effect are supported.
        abstract isSupported: bool
        /// Updates the current state of the effect
        abstract _update: unit -> unit
        /// <summary>Attaches the effect on cameras</summary>
        /// <param name="cameras">The camera to attach to.</param>
        abstract _attachCameras: cameras: Camera -> unit
        /// <summary>Attaches the effect on cameras</summary>
        /// <param name="cameras">The camera to attach to.</param>
        abstract _attachCameras: cameras: ResizeArray<Camera> -> unit
        /// <summary>Detatches the effect on cameras</summary>
        /// <param name="cameras">The camera to detatch from.</param>
        abstract _detachCameras: cameras: Camera -> unit
        /// <summary>Detatches the effect on cameras</summary>
        /// <param name="cameras">The camera to detatch from.</param>
        abstract _detachCameras: cameras: ResizeArray<Camera> -> unit
        /// <summary>Enables the effect on given cameras</summary>
        /// <param name="cameras">The camera to enable.</param>
        abstract _enable: cameras: Camera -> unit
        /// <summary>Enables the effect on given cameras</summary>
        /// <param name="cameras">The camera to enable.</param>
        abstract _enable: cameras: Nullable<ResizeArray<Camera>> -> unit
        /// <summary>Disables the effect on the given cameras</summary>
        /// <param name="cameras">The camera to disable.</param>
        abstract _disable: cameras: Camera -> unit
        /// <summary>Disables the effect on the given cameras</summary>
        /// <param name="cameras">The camera to disable.</param>
        abstract _disable: cameras: Nullable<ResizeArray<Camera>> -> unit
        /// <summary>Gets a list of the post processes contained in the effect.</summary>
        /// <param name="camera">The camera to get the post processes on.</param>
        abstract getPostProcesses: ?camera: Camera -> Nullable<Array<PostProcess>>

    /// This represents a set of one or more post processes in Babylon.
    /// A post process can be used to apply a shader to a texture after it is rendered.
    type [<AllowNullLiteral>] PostProcessRenderEffectStatic =
        /// <summary>Instantiates a post process render effect.
        /// A post process can be used to apply a shader to a texture after it is rendered.</summary>
        /// <param name="engine">The engine the effect is tied to</param>
        /// <param name="name">The name of the effect</param>
        /// <param name="getPostProcesses">A function that returns a set of post processes which the effect will run in order to be run.</param>
        /// <param name="singleInstance">False if this post process can be run on multiple cameras. (default: true)</param>
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * name: string * getPostProcesses: (unit -> Nullable<U2<PostProcess, Array<PostProcess>>>) * ?singleInstance: bool -> PostProcessRenderEffect

    type [<AllowNullLiteral>] PostProcessRenderPipeline =
        abstract engine: obj with get, set
        abstract _renderEffects: obj with get, set
        abstract _renderEffectsForIsolatedPass: obj with get, set
        abstract _cameras: ResizeArray<Camera> with get, set
        abstract _name: string with get, set
        abstract getClassName: unit -> string
        abstract isSupported: bool
        abstract addEffect: renderEffect: PostProcessRenderEffect -> unit
        abstract _rebuild: unit -> unit
        abstract _enableEffect: renderEffectName: string * cameras: Camera -> unit
        abstract _enableEffect: renderEffectName: string * cameras: ResizeArray<Camera> -> unit
        abstract _disableEffect: renderEffectName: string * cameras: Nullable<ResizeArray<Camera>> -> unit
        abstract _attachCameras: cameras: Camera * unique: bool -> unit
        abstract _attachCameras: cameras: ResizeArray<Camera> * unique: bool -> unit
        abstract _detachCameras: cameras: Camera -> unit
        abstract _detachCameras: cameras: Nullable<ResizeArray<Camera>> -> unit
        abstract _update: unit -> unit
        abstract _reset: unit -> unit
        abstract _enableMSAAOnFirstPostProcess: sampleCount: float -> bool
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] PostProcessRenderPipelineStatic =
        [<Emit "new $0($1...)">] abstract Create: engine: Engine * name: string -> PostProcessRenderPipeline

    type [<AllowNullLiteral>] PostProcessRenderPipelineManager =
        abstract _renderPipelines: obj with get, set
        abstract addPipeline: renderPipeline: PostProcessRenderPipeline -> unit
        abstract attachCamerasToRenderPipeline: renderPipelineName: string * cameras: Camera * ?unique: bool -> unit
        abstract attachCamerasToRenderPipeline: renderPipelineName: string * cameras: ResizeArray<Camera> * ?unique: bool -> unit
        abstract detachCamerasFromRenderPipeline: renderPipelineName: string * cameras: Camera -> unit
        abstract detachCamerasFromRenderPipeline: renderPipelineName: string * cameras: ResizeArray<Camera> -> unit
        abstract enableEffectInPipeline: renderPipelineName: string * renderEffectName: string * cameras: Camera -> unit
        abstract enableEffectInPipeline: renderPipelineName: string * renderEffectName: string * cameras: ResizeArray<Camera> -> unit
        abstract disableEffectInPipeline: renderPipelineName: string * renderEffectName: string * cameras: Camera -> unit
        abstract disableEffectInPipeline: renderPipelineName: string * renderEffectName: string * cameras: ResizeArray<Camera> -> unit
        abstract update: unit -> unit
        abstract _rebuild: unit -> unit
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] PostProcessRenderPipelineManagerStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PostProcessRenderPipelineManager

    /// Helper class dealing with the extraction of spherical polynomial dataArray
    /// from a cube map.
    type [<AllowNullLiteral>] CubeMapToSphericalPolynomialTools =
        abstract FileFaces: obj with get, set

    /// Helper class dealing with the extraction of spherical polynomial dataArray
    /// from a cube map.
    type [<AllowNullLiteral>] CubeMapToSphericalPolynomialToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> CubeMapToSphericalPolynomialTools
        /// <summary>Converts a texture to the according Spherical Polynomial data.
        /// This extracts the first 3 orders only as they are the only one used in the lighting.</summary>
        /// <param name="texture">The texture to extract the information from.</param>
        abstract ConvertCubeMapTextureToSphericalPolynomial: texture: BaseTexture -> Nullable<SphericalPolynomial>
        /// <summary>Converts a cubemap to the according Spherical Polynomial data.
        /// This extracts the first 3 orders only as they are the only one used in the lighting.</summary>
        /// <param name="cubeInfo">The Cube map to extract the information from.</param>
        abstract ConvertCubeMapToSphericalPolynomial: cubeInfo: CubeMapInfo -> SphericalPolynomial

    /// Header information of HDR texture files.
    type [<AllowNullLiteral>] HDRInfo =
        /// The height of the texture in pixels.
        abstract height: float with get, set
        /// The width of the texture in pixels.
        abstract width: float with get, set
        /// The index of the beginning of the data in the binary file.
        abstract dataPosition: float with get, set

    /// This groups tools to convert HDR texture to native colors array.
    type [<AllowNullLiteral>] HDRTools =
        interface end

    /// This groups tools to convert HDR texture to native colors array.
    type [<AllowNullLiteral>] HDRToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> HDRTools
        abstract Ldexp: mantissa: obj * exponent: obj -> unit
        abstract Rgbe2float: float32array: obj * red: obj * green: obj * blue: obj * exponent: obj * index: obj -> unit
        abstract readStringLine: uint8array: obj * startIndex: obj -> unit
        /// <summary>Reads header information from an RGBE texture stored in a native array.
        /// More information on this format are available here:
        /// https://en.wikipedia.org/wiki/RGBE_image_format</summary>
        /// <param name="uint8array">The binary file stored in  native array.</param>
        abstract RGBE_ReadHeader: uint8array: Uint8Array -> HDRInfo
        /// <summary>Returns the cubemap information (each faces texture data) extracted from an RGBE texture.
        /// This RGBE texture needs to store the information as a panorama.
        /// 
        /// More information on this format are available here:
        /// https://en.wikipedia.org/wiki/RGBE_image_format</summary>
        /// <param name="buffer">The binary file stored in an array buffer.</param>
        /// <param name="size">The expected size of the extracted cubemap.</param>
        abstract GetCubeMapTextureData: buffer: ArrayBuffer * size: float -> CubeMapInfo
        /// <summary>Returns the pixels data extracted from an RGBE texture.
        /// This pixels will be stored left to right up to down in the R G B order in one array.
        /// 
        /// More information on this format are available here:
        /// https://en.wikipedia.org/wiki/RGBE_image_format</summary>
        /// <param name="uint8array">The binary file stored in an array buffer.</param>
        /// <param name="hdrInfo">The header information of the file.</param>
        abstract RGBE_ReadPixels: uint8array: Uint8Array * hdrInfo: HDRInfo -> Float32Array
        abstract RGBE_ReadPixels_RLE: uint8array: obj * hdrInfo: obj -> unit

    /// CubeMap information grouping all the data for each faces as well as the cubemap size.
    type [<AllowNullLiteral>] CubeMapInfo =
        /// The pixel array for the front face.
        /// This is stored in format, left to right, up to down format.
        abstract front: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the back face.
        /// This is stored in format, left to right, up to down format.
        abstract back: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the left face.
        /// This is stored in format, left to right, up to down format.
        abstract left: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the right face.
        /// This is stored in format, left to right, up to down format.
        abstract right: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the up face.
        /// This is stored in format, left to right, up to down format.
        abstract up: Nullable<ArrayBufferView> with get, set
        /// The pixel array for the down face.
        /// This is stored in format, left to right, up to down format.
        abstract down: Nullable<ArrayBufferView> with get, set
        /// The size of the cubemap stored.
        /// 
        /// Each faces will be size * size pixels.
        abstract size: float with get, set
        /// The format of the texture.
        /// 
        /// RGBA, RGB.
        abstract format: float with get, set
        /// The type of the texture data.
        /// 
        /// UNSIGNED_INT, FLOAT.
        abstract ``type``: float with get, set
        /// Specifies whether the texture is in gamma space.
        abstract gammaSpace: bool with get, set

    /// Helper class usefull to convert panorama picture to their cubemap representation in 6 faces.
    type [<AllowNullLiteral>] PanoramaToCubeMapTools =
        abstract FACE_FRONT: obj with get, set
        abstract FACE_BACK: obj with get, set
        abstract FACE_RIGHT: obj with get, set
        abstract FACE_LEFT: obj with get, set
        abstract FACE_DOWN: obj with get, set
        abstract FACE_UP: obj with get, set

    /// Helper class usefull to convert panorama picture to their cubemap representation in 6 faces.
    type [<AllowNullLiteral>] PanoramaToCubeMapToolsStatic =
        [<Emit "new $0($1...)">] abstract Create: unit -> PanoramaToCubeMapTools
        /// <summary>Converts a panorma stored in RGB right to left up to down format into a cubemap (6 faces).</summary>
        /// <param name="float32Array">The source data.</param>
        /// <param name="inputWidth">The width of the input panorama.</param>
        /// <param name="size">The willing size of the generated cubemap (each faces will be size * size pixels)</param>
        abstract ConvertPanoramaToCubemap: float32Array: Float32Array * inputWidth: float * inputHeight: float * size: float -> CubeMapInfo
        abstract CreateCubemapTexture: texSize: obj * faceData: obj * float32Array: obj * inputWidth: obj * inputHeight: obj -> unit
        abstract CalcProjectionSpherical: vDir: obj * float32Array: obj * inputWidth: obj * inputHeight: obj -> unit

    type [<AllowNullLiteral>] CustomProceduralTexture =
        inherit ProceduralTexture
        abstract _animate: obj with get, set
        abstract _time: obj with get, set
        abstract _config: obj with get, set
        abstract _texturePath: obj with get, set
        abstract loadJson: jsonUrl: obj -> unit
        abstract isReady: unit -> bool
        abstract render: ?useCameraPostProcess: bool -> unit
        abstract updateTextures: unit -> unit
        abstract updateShaderUniforms: unit -> unit
        abstract animate: bool with get, set

    type [<AllowNullLiteral>] CustomProceduralTextureStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * texturePath: obj option * size: float * scene: Scene * ?fallbackTexture: Texture * ?generateMipMaps: bool -> CustomProceduralTexture

    type [<AllowNullLiteral>] ProceduralTexture =
        inherit Texture
        abstract isCube: bool with get, set
        abstract _size: obj with get, set
        abstract _generateMipMaps: bool with get, set
        abstract isEnabled: bool with get, set
        abstract _currentRefreshId: obj with get, set
        abstract _refreshRate: obj with get, set
        abstract onGenerated: (unit -> unit) with get, set
        abstract _vertexBuffers: obj with get, set
        abstract _indexBuffer: obj with get, set
        abstract _effect: obj with get, set
        abstract _uniforms: obj with get, set
        abstract _samplers: obj with get, set
        abstract _fragment: obj with get, set
        abstract _textures: obj with get, set
        abstract _floats: obj with get, set
        abstract _floatsArrays: obj with get, set
        abstract _colors3: obj with get, set
        abstract _colors4: obj with get, set
        abstract _vectors2: obj with get, set
        abstract _vectors3: obj with get, set
        abstract _matrices: obj with get, set
        abstract _fallbackTexture: obj with get, set
        abstract _fallbackTextureUsed: obj with get, set
        abstract _engine: obj with get, set
        abstract _createIndexBuffer: unit -> unit
        abstract _rebuild: unit -> unit
        abstract reset: unit -> unit
        abstract isReady: unit -> bool
        abstract resetRefreshCounter: unit -> unit
        abstract setFragment: fragment: obj option -> unit
        abstract refreshRate: float with get, set
        abstract _shouldRender: unit -> bool
        abstract getRenderSize: unit -> float
        abstract resize: size: float * generateMipMaps: bool -> unit
        abstract _checkUniform: uniformName: obj -> unit
        abstract setTexture: name: string * texture: Texture -> ProceduralTexture
        abstract setFloat: name: string * value: float -> ProceduralTexture
        abstract setFloats: name: string * value: ResizeArray<float> -> ProceduralTexture
        abstract setColor3: name: string * value: Color3 -> ProceduralTexture
        abstract setColor4: name: string * value: Color4 -> ProceduralTexture
        abstract setVector2: name: string * value: Vector2 -> ProceduralTexture
        abstract setVector3: name: string * value: Vector3 -> ProceduralTexture
        abstract setMatrix: name: string * value: Matrix -> ProceduralTexture
        abstract render: ?useCameraPostProcess: bool -> unit
        abstract clone: unit -> ProceduralTexture
        abstract dispose: unit -> unit

    type [<AllowNullLiteral>] ProceduralTextureStatic =
        [<Emit "new $0($1...)">] abstract Create: name: string * size: obj option * fragment: obj option * scene: Scene * ?fallbackTexture: Nullable<Texture> * ?generateMipMaps: bool * ?isCube: bool -> ProceduralTexture

    /// The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
    /// See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
    type [<AllowNullLiteral>] DefaultRenderingPipeline =
        inherit PostProcessRenderPipeline
        inherit IDisposable
        inherit IAnimatable
        abstract _scene: obj with get, set
        abstract _originalCameras: obj with get, set
        /// ID of the sharpen post process,
        abstract SharpenPostProcessId: obj
        /// ID of the image processing post process;
        abstract ImageProcessingPostProcessId: string
        /// ID of the Fast Approximate Anti-Aliasing post process;
        abstract FxaaPostProcessId: string
        /// ID of the chromatic aberration post process,
        abstract ChromaticAberrationPostProcessId: obj
        /// ID of the grain post process
        abstract GrainPostProcessId: obj
        /// Sharpen post process which will apply a sharpen convolution to enhance edges
        abstract sharpen: SharpenPostProcess with get, set
        abstract _sharpenEffect: obj with get, set
        abstract bloom: obj with get, set
        /// Depth of field effect, applies a blur based on how far away objects are from the focus distance.
        abstract depthOfField: DepthOfFieldEffect with get, set
        /// The Fast Approximate Anti-Aliasing post process which attemps to remove aliasing from an image.
        abstract fxaa: FxaaPostProcess with get, set
        /// Image post processing pass used to perform operations such as tone mapping or color grading.
        abstract imageProcessing: ImageProcessingPostProcess with get, set
        /// Chromatic aberration post process which will shift rgb colors in the image
        abstract chromaticAberration: ChromaticAberrationPostProcess with get, set
        abstract _chromaticAberrationEffect: obj with get, set
        /// Grain post process which add noise to the image
        abstract grain: GrainPostProcess with get, set
        abstract _grainEffect: obj with get, set
        /// Animations which can be used to tweak settings over a period of time
        abstract animations: ResizeArray<Animation> with get, set
        abstract _imageProcessingConfigurationObserver: obj with get, set
        abstract _sharpenEnabled: obj with get, set
        abstract _bloomEnabled: obj with get, set
        abstract _depthOfFieldEnabled: obj with get, set
        abstract _depthOfFieldBlurLevel: obj with get, set
        abstract _fxaaEnabled: obj with get, set
        abstract _imageProcessingEnabled: obj with get, set
        abstract _defaultPipelineTextureType: obj with get, set
        abstract _bloomScale: obj with get, set
        abstract _chromaticAberrationEnabled: obj with get, set
        abstract _grainEnabled: obj with get, set
        abstract _buildAllowed: obj with get, set
        /// Enable or disable the sharpen process from the pipeline
        abstract sharpenEnabled: bool with get, set
        abstract _resizeObserver: obj with get, set
        abstract _hardwareScaleLevel: obj with get, set
        abstract _bloomKernel: obj with get, set
        /// Specifies the size of the bloom blur kernel, relative to the final output size
        abstract bloomKernel: float with get, set
        /// Specifies the weight of the bloom in the final rendering
        abstract _bloomWeight: obj with get, set
        /// Specifies the luma threshold for the area that will be blurred by the bloom
        abstract _bloomThreshold: obj with get, set
        abstract _hdr: obj with get, set
        /// The strength of the bloom.
        abstract bloomWeight: float with get, set
        /// The strength of the bloom.
        abstract bloomThreshold: float with get, set
        /// The scale of the bloom, lower value will provide better performance.
        abstract bloomScale: float with get, set
        /// Enable or disable the bloom from the pipeline
        abstract bloomEnabled: bool with get, set
        abstract _rebuildBloom: unit -> unit
        /// If the depth of field is enabled.
        abstract depthOfFieldEnabled: bool with get, set
        /// Blur level of the depth of field effect. (Higher blur will effect performance)
        abstract depthOfFieldBlurLevel: DepthOfFieldEffectBlurLevel with get, set
        /// If the anti aliasing is enabled.
        abstract fxaaEnabled: bool with get, set
        abstract _samples: obj with get, set
        /// MSAA sample count, setting this to 4 will provide 4x anti aliasing. (default: 1)
        abstract samples: float with get, set
        /// If image processing is enabled.
        abstract imageProcessingEnabled: bool with get, set
        /// Enable or disable the chromaticAberration process from the pipeline
        abstract chromaticAberrationEnabled: bool with get, set
        /// Enable or disable the grain process from the pipeline
        abstract grainEnabled: bool with get, set
        /// Force the compilation of the entire pipeline.
        abstract prepare: unit -> unit
        abstract _hasCleared: obj with get, set
        abstract _prevPostProcess: obj with get, set
        abstract _prevPrevPostProcess: obj with get, set
        abstract _setAutoClearAndTextureSharing: postProcess: obj * ?skipTextureSharing: obj -> unit
        abstract _buildPipeline: unit -> unit
        abstract _disposePostProcesses: ?disposeNonRecreated: obj -> unit
        /// Dispose of the pipeline and stop all post processes
        abstract dispose: unit -> unit
        /// Serialize the rendering pipeline (Used when exporting)
        abstract serialize: unit -> obj option

    /// The default rendering pipeline can be added to a scene to apply common post processing effects such as anti-aliasing or depth of field.
    /// See https://doc.babylonjs.com/how_to/using_default_rendering_pipeline
    type [<AllowNullLiteral>] DefaultRenderingPipelineStatic =
        /// <param name="name">- The rendering pipeline name</param>
        /// <param name="scene">- The scene linked to this pipeline</param>
        /// <param name="cameras">- The array of cameras that the rendering pipeline will be attached to</param>
        /// <param name="automaticBuild">- if false, you will have to manually call prepare() to update the pipeline</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * hdr: bool * scene: Scene * ?cameras: ResizeArray<Camera> * ?automaticBuild: bool -> DefaultRenderingPipeline
        /// <summary>Parse the serialized pipeline</summary>
        /// <param name="source">Source pipeline.</param>
        /// <param name="scene">The scene to load the pipeline to.</param>
        /// <param name="rootUrl">The URL of the serialized pipeline.</param>
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> DefaultRenderingPipeline

    type [<AllowNullLiteral>] LensRenderingPipeline =
        inherit PostProcessRenderPipeline
        /// The chromatic aberration PostProcess id in the pipeline
        abstract LensChromaticAberrationEffect: string with get, set
        /// The highlights enhancing PostProcess id in the pipeline
        abstract HighlightsEnhancingEffect: string with get, set
        /// The depth-of-field PostProcess id in the pipeline
        abstract LensDepthOfFieldEffect: string with get, set
        abstract _scene: obj with get, set
        abstract _depthTexture: obj with get, set
        abstract _grainTexture: obj with get, set
        abstract _chromaticAberrationPostProcess: obj with get, set
        abstract _highlightsPostProcess: obj with get, set
        abstract _depthOfFieldPostProcess: obj with get, set
        abstract _edgeBlur: obj with get, set
        abstract _grainAmount: obj with get, set
        abstract _chromaticAberration: obj with get, set
        abstract _distortion: obj with get, set
        abstract _highlightsGain: obj with get, set
        abstract _highlightsThreshold: obj with get, set
        abstract _dofDistance: obj with get, set
        abstract _dofAperture: obj with get, set
        abstract _dofDarken: obj with get, set
        abstract _dofPentagon: obj with get, set
        abstract _blurNoise: obj with get, set
        abstract setEdgeBlur: amount: float -> unit
        abstract disableEdgeBlur: unit -> unit
        abstract setGrainAmount: amount: float -> unit
        abstract disableGrain: unit -> unit
        abstract setChromaticAberration: amount: float -> unit
        abstract disableChromaticAberration: unit -> unit
        abstract setEdgeDistortion: amount: float -> unit
        abstract disableEdgeDistortion: unit -> unit
        abstract setFocusDistance: amount: float -> unit
        abstract disableDepthOfField: unit -> unit
        abstract setAperture: amount: float -> unit
        abstract setDarkenOutOfFocus: amount: float -> unit
        abstract enablePentagonBokeh: unit -> unit
        abstract disablePentagonBokeh: unit -> unit
        abstract enableNoiseBlur: unit -> unit
        abstract disableNoiseBlur: unit -> unit
        abstract setHighlightsGain: amount: float -> unit
        abstract setHighlightsThreshold: amount: float -> unit
        abstract disableHighlights: unit -> unit
        /// Removes the internal pipeline assets and detaches the pipeline from the scene cameras
        abstract dispose: ?disableDepthRender: bool -> unit
        abstract _createChromaticAberrationPostProcess: ratio: obj -> unit
        abstract _createHighlightsPostProcess: ratio: obj -> unit
        abstract _createDepthOfFieldPostProcess: ratio: obj -> unit
        abstract _createGrainTexture: unit -> unit

    type [<AllowNullLiteral>] LensRenderingPipelineStatic =
        /// <param name="name">- The rendering pipeline name</param>
        /// <param name="parameters">- An object containing all parameters (see above)</param>
        /// <param name="scene">- The scene linked to this pipeline</param>
        /// <param name="ratio">- The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)</param>
        /// <param name="cameras">- The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * parameters: obj option * scene: Scene * ?ratio: float * ?cameras: ResizeArray<Camera> -> LensRenderingPipeline

    type [<AllowNullLiteral>] SSAO2RenderingPipeline =
        inherit PostProcessRenderPipeline
        /// The PassPostProcess id in the pipeline that contains the original scene color
        abstract SSAOOriginalSceneColorEffect: string with get, set
        /// The SSAO PostProcess id in the pipeline
        abstract SSAORenderEffect: string with get, set
        /// The horizontal blur PostProcess id in the pipeline
        abstract SSAOBlurHRenderEffect: string with get, set
        /// The vertical blur PostProcess id in the pipeline
        abstract SSAOBlurVRenderEffect: string with get, set
        /// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        abstract SSAOCombineRenderEffect: string with get, set
        /// The output strength of the SSAO post-process. Default value is 1.0.
        abstract totalStrength: float with get, set
        /// Maximum depth value to still render AO. A smooth falloff makes the dimming more natural, so there will be no abrupt shading change.
        abstract maxZ: float with get, set
        /// In order to save performances, SSAO radius is clamped on close geometry. This ratio changes by how much
        abstract minZAspect: float with get, set
        /// Number of samples used for the SSAO calculations. Default value is 8
        abstract _samples: obj with get, set
        /// Dynamically generated sphere sampler.
        abstract _sampleSphere: obj with get, set
        /// Blur filter offsets
        abstract _samplerOffsets: obj with get, set
        abstract samples: float with get, set
        /// Are we using bilateral blur ?
        abstract _expensiveBlur: obj with get, set
        abstract expensiveBlur: bool with get, set
        /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 2.0
        abstract radius: float with get, set
        /// The base color of the SSAO post-process
        /// The final result is "base + ssao" between [0, 1]
        abstract ``base``: float with get, set
        /// Support test.
        abstract IsSupported: bool
        abstract _scene: obj with get, set
        abstract _depthTexture: obj with get, set
        abstract _normalTexture: obj with get, set
        abstract _randomTexture: obj with get, set
        abstract _originalColorPostProcess: obj with get, set
        abstract _ssaoPostProcess: obj with get, set
        abstract _blurHPostProcess: obj with get, set
        abstract _blurVPostProcess: obj with get, set
        abstract _ssaoCombinePostProcess: obj with get, set
        abstract _firstUpdate: obj with get, set
        /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
        abstract dispose: ?disableGeometryBufferRenderer: bool -> unit
        abstract _createBlurPostProcess: ssaoRatio: obj * blurRatio: obj -> unit
        abstract _rebuild: unit -> unit
        abstract _generateHemisphere: unit -> unit
        abstract _createSSAOPostProcess: ratio: obj -> unit
        abstract _createSSAOCombinePostProcess: ratio: obj -> unit
        abstract _createRandomTexture: unit -> unit

    type [<AllowNullLiteral>] SSAO2RenderingPipelineStatic =
        /// <param name="name">- The rendering pipeline name</param>
        /// <param name="scene">- The scene linked to this pipeline</param>
        /// <param name="ratio">- The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, blurRatio: 1.0 }</param>
        /// <param name="cameras">- The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ratio: obj option * ?cameras: ResizeArray<Camera> -> SSAO2RenderingPipeline

    type [<AllowNullLiteral>] SSAORenderingPipeline =
        inherit PostProcessRenderPipeline
        /// The PassPostProcess id in the pipeline that contains the original scene color
        abstract SSAOOriginalSceneColorEffect: string with get, set
        /// The SSAO PostProcess id in the pipeline
        abstract SSAORenderEffect: string with get, set
        /// The horizontal blur PostProcess id in the pipeline
        abstract SSAOBlurHRenderEffect: string with get, set
        /// The vertical blur PostProcess id in the pipeline
        abstract SSAOBlurVRenderEffect: string with get, set
        /// The PostProcess id in the pipeline that combines the SSAO-Blur output with the original scene color (SSAOOriginalSceneColorEffect)
        abstract SSAOCombineRenderEffect: string with get, set
        /// The output strength of the SSAO post-process. Default value is 1.0.
        abstract totalStrength: float with get, set
        /// The radius around the analyzed pixel used by the SSAO post-process. Default value is 0.0006
        abstract radius: float with get, set
        /// Related to fallOff, used to interpolate SSAO samples (first interpolate function input) based on the occlusion difference of each pixel
        /// Must not be equal to fallOff and superior to fallOff.
        /// Default value is 0.975
        abstract area: float with get, set
        /// Related to area, used to interpolate SSAO samples (second interpolate function input) based on the occlusion difference of each pixel
        /// Must not be equal to area and inferior to area.
        /// Default value is 0.0
        abstract fallOff: float with get, set
        /// The base color of the SSAO post-process
        /// The final result is "base + ssao" between [0, 1]
        abstract ``base``: float with get, set
        abstract _scene: obj with get, set
        abstract _depthTexture: obj with get, set
        abstract _randomTexture: obj with get, set
        abstract _originalColorPostProcess: obj with get, set
        abstract _ssaoPostProcess: obj with get, set
        abstract _blurHPostProcess: obj with get, set
        abstract _blurVPostProcess: obj with get, set
        abstract _ssaoCombinePostProcess: obj with get, set
        abstract _firstUpdate: obj with get, set
        /// Removes the internal pipeline assets and detatches the pipeline from the scene cameras
        abstract dispose: ?disableDepthRender: bool -> unit
        abstract _createBlurPostProcess: ratio: obj -> unit
        abstract _rebuild: unit -> unit
        abstract _createSSAOPostProcess: ratio: obj -> unit
        abstract _createSSAOCombinePostProcess: ratio: obj -> unit
        abstract _createRandomTexture: unit -> unit

    type [<AllowNullLiteral>] SSAORenderingPipelineStatic =
        /// <param name="name">- The rendering pipeline name</param>
        /// <param name="scene">- The scene linked to this pipeline</param>
        /// <param name="ratio">- The size of the postprocesses. Can be a number shared between passes or an object for more precision: { ssaoRatio: 0.5, combineRatio: 1.0 }</param>
        /// <param name="cameras">- The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ratio: obj option * ?cameras: ResizeArray<Camera> -> SSAORenderingPipeline

    type [<AllowNullLiteral>] StandardRenderingPipeline =
        inherit PostProcessRenderPipeline
        inherit IDisposable
        inherit IAnimatable
        /// Public members
        abstract originalPostProcess: Nullable<PostProcess> with get, set
        abstract downSampleX4PostProcess: Nullable<PostProcess> with get, set
        abstract brightPassPostProcess: Nullable<PostProcess> with get, set
        abstract blurHPostProcesses: ResizeArray<PostProcess> with get, set
        abstract blurVPostProcesses: ResizeArray<PostProcess> with get, set
        abstract textureAdderPostProcess: Nullable<PostProcess> with get, set
        abstract volumetricLightPostProcess: Nullable<PostProcess> with get, set
        abstract volumetricLightSmoothXPostProcess: Nullable<BlurPostProcess> with get, set
        abstract volumetricLightSmoothYPostProcess: Nullable<BlurPostProcess> with get, set
        abstract volumetricLightMergePostProces: Nullable<PostProcess> with get, set
        abstract volumetricLightFinalPostProcess: Nullable<PostProcess> with get, set
        abstract luminancePostProcess: Nullable<PostProcess> with get, set
        abstract luminanceDownSamplePostProcesses: ResizeArray<PostProcess> with get, set
        abstract hdrPostProcess: Nullable<PostProcess> with get, set
        abstract textureAdderFinalPostProcess: Nullable<PostProcess> with get, set
        abstract lensFlareFinalPostProcess: Nullable<PostProcess> with get, set
        abstract hdrFinalPostProcess: Nullable<PostProcess> with get, set
        abstract lensFlarePostProcess: Nullable<PostProcess> with get, set
        abstract lensFlareComposePostProcess: Nullable<PostProcess> with get, set
        abstract motionBlurPostProcess: Nullable<PostProcess> with get, set
        abstract depthOfFieldPostProcess: Nullable<PostProcess> with get, set
        abstract brightThreshold: float with get, set
        abstract blurWidth: float with get, set
        abstract horizontalBlur: bool with get, set
        abstract exposure: float with get, set
        abstract lensTexture: Nullable<Texture> with get, set
        abstract volumetricLightCoefficient: float with get, set
        abstract volumetricLightPower: float with get, set
        abstract volumetricLightBlurScale: float with get, set
        abstract sourceLight: Nullable<U2<SpotLight, DirectionalLight>> with get, set
        abstract hdrMinimumLuminance: float with get, set
        abstract hdrDecreaseRate: float with get, set
        abstract hdrIncreaseRate: float with get, set
        abstract lensColorTexture: Nullable<Texture> with get, set
        abstract lensFlareStrength: float with get, set
        abstract lensFlareGhostDispersal: float with get, set
        abstract lensFlareHaloWidth: float with get, set
        abstract lensFlareDistortionStrength: float with get, set
        abstract lensStarTexture: Nullable<Texture> with get, set
        abstract lensFlareDirtTexture: Nullable<Texture> with get, set
        abstract depthOfFieldDistance: float with get, set
        abstract depthOfFieldBlurWidth: float with get, set
        abstract motionStrength: float with get, set
        abstract animations: ResizeArray<Animation> with get, set
        /// Private members
        abstract _scene: obj with get, set
        abstract _currentDepthOfFieldSource: obj with get, set
        abstract _basePostProcess: obj with get, set
        abstract _hdrCurrentLuminance: obj with get, set
        abstract _floatTextureType: obj with get, set
        abstract _ratio: obj with get, set
        abstract _bloomEnabled: obj with get, set
        abstract _depthOfFieldEnabled: obj with get, set
        abstract _vlsEnabled: obj with get, set
        abstract _lensFlareEnabled: obj with get, set
        abstract _hdrEnabled: obj with get, set
        abstract _motionBlurEnabled: obj with get, set
        abstract _motionBlurSamples: obj with get, set
        abstract _volumetricLightStepsCount: obj with get, set
        abstract BloomEnabled: bool with get, set
        abstract DepthOfFieldEnabled: bool with get, set
        abstract LensFlareEnabled: bool with get, set
        abstract HDREnabled: bool with get, set
        abstract VLSEnabled: bool with get, set
        abstract MotionBlurEnabled: bool with get, set
        abstract volumetricLightStepsCount: float with get, set
        abstract motionBlurSamples: float with get, set
        abstract _buildPipeline: unit -> unit
        abstract _createDownSampleX4PostProcess: scene: obj * ratio: obj -> unit
        abstract _createBrightPassPostProcess: scene: obj * ratio: obj -> unit
        abstract _createBlurPostProcesses: scene: obj * ratio: obj * indice: obj * ?blurWidthKey: obj -> unit
        abstract _createTextureAdderPostProcess: scene: obj * ratio: obj -> unit
        abstract _createVolumetricLightPostProcess: scene: obj * ratio: obj -> unit
        abstract _createLuminancePostProcesses: scene: obj * textureType: obj -> unit
        abstract _createHdrPostProcess: scene: obj * ratio: obj -> unit
        abstract _createLensFlarePostProcess: scene: obj * ratio: obj -> unit
        abstract _createDepthOfFieldPostProcess: scene: obj * ratio: obj -> unit
        abstract _createMotionBlurPostProcess: scene: obj * ratio: obj -> unit
        abstract _getDepthTexture: unit -> unit
        abstract _disposePostProcesses: unit -> unit
        abstract dispose: unit -> unit
        abstract serialize: unit -> obj option
        abstract LuminanceSteps: float with get, set

    type [<AllowNullLiteral>] StandardRenderingPipelineStatic =
        /// <param name="name">- The rendering pipeline name</param>
        /// <param name="scene">- The scene linked to this pipeline</param>
        /// <param name="ratio">- The size of the postprocesses (0.5 means that your postprocess will have a width = canvas.width 0.5 and a height = canvas.height 0.5)</param>
        /// <param name="originalPostProcess">- the custom original color post-process. Must be "reusable". Can be null.</param>
        /// <param name="cameras">- The array of cameras that the rendering pipeline will be attached to</param>
        [<Emit "new $0($1...)">] abstract Create: name: string * scene: Scene * ratio: float * ?originalPostProcess: Nullable<PostProcess> * ?cameras: ResizeArray<Camera> -> StandardRenderingPipeline
        /// Static members
        abstract Parse: source: obj option * scene: Scene * rootUrl: string -> StandardRenderingPipeline

type [<AllowNullLiteral>] Window =
    abstract mozIndexedDB: IDBFactory with get, set
    abstract webkitIndexedDB: IDBFactory with get, set
    abstract msIndexedDB: IDBFactory with get, set
    abstract webkitURL: obj with get, set
    abstract mozRequestAnimationFrame: callback: FrameRequestCallback -> float
    abstract oRequestAnimationFrame: callback: FrameRequestCallback -> float
    abstract WebGLRenderingContext: WebGLRenderingContext with get, set
    abstract MSGesture: MSGesture with get, set
    abstract CANNON: obj option with get, set
    abstract AudioContext: AudioContext with get, set
    abstract webkitAudioContext: AudioContext with get, set
    abstract PointerEvent: obj option with get, set
    abstract Math: Math with get, set
    abstract Uint8Array: Uint8ArrayConstructor with get, set
    abstract Float32Array: Float32ArrayConstructor with get, set
    abstract mozURL: obj with get, set
    abstract msURL: obj with get, set
    abstract VRFrameData: obj option with get, set
    abstract DracoDecoderModule: obj option with get, set
    abstract onvrdisplayconnected: (Window -> Event -> obj option) option with get, set
    abstract onvrdisplaydisconnected: (Window -> Event -> obj option) option with get, set
    abstract onvrdisplaypresentchange: (Window -> Event -> obj option) option with get, set
    [<Emit "$0.addEventListener('vrdisplayconnected',$1,$2)">] abstract addEventListener_vrdisplayconnected: listener: (Event -> obj option) * ?useCapture: bool -> unit
    [<Emit "$0.addEventListener('vrdisplaydisconnected',$1,$2)">] abstract addEventListener_vrdisplaydisconnected: listener: (Event -> obj option) * ?useCapture: bool -> unit
    [<Emit "$0.addEventListener('vrdisplaypresentchange',$1,$2)">] abstract addEventListener_vrdisplaypresentchange: listener: (Event -> obj option) * ?useCapture: bool -> unit

type [<AllowNullLiteral>] WebGLRenderingContext =
    abstract drawArraysInstanced: mode: float * first: float * count: float * primcount: float -> unit
    abstract drawElementsInstanced: mode: float * count: float * ``type``: float * offset: float * primcount: float -> unit
    abstract vertexAttribDivisor: index: float * divisor: float -> unit
    abstract createVertexArray: unit -> obj option
    abstract bindVertexArray: ?vao: WebGLVertexArrayObject option -> unit
    abstract deleteVertexArray: vao: WebGLVertexArrayObject -> unit
    abstract blitFramebuffer: srcX0: float * srcY0: float * srcX1: float * srcY1: float * dstX0: float * dstY0: float * dstX1: float * dstY1: float * mask: float * filter: float -> unit
    abstract renderbufferStorageMultisample: target: float * samples: float * internalformat: float * width: float * height: float -> unit
    abstract bindBufferBase: target: float * index: float * buffer: WebGLBuffer option -> unit
    abstract getUniformBlockIndex: program: WebGLProgram * uniformBlockName: string -> float
    abstract uniformBlockBinding: program: WebGLProgram * uniformBlockIndex: float * uniformBlockBinding: float -> unit
    abstract createQuery: unit -> WebGLQuery
    abstract deleteQuery: query: WebGLQuery -> unit
    abstract beginQuery: target: float * query: WebGLQuery -> unit
    abstract endQuery: target: float -> unit
    abstract getQueryParameter: query: WebGLQuery * pname: float -> obj option
    abstract getQuery: target: float * pname: float -> obj option
    abstract MAX_SAMPLES: float with get, set
    abstract RGBA8: float with get, set
    abstract READ_FRAMEBUFFER: float with get, set
    abstract DRAW_FRAMEBUFFER: float with get, set
    abstract UNIFORM_BUFFER: float with get, set
    abstract HALF_FLOAT_OES: float with get, set
    abstract RGBA16F: float with get, set
    abstract RGBA32F: float with get, set
    abstract R32F: float with get, set
    abstract RG32F: float with get, set
    abstract RGB32F: float with get, set
    abstract RED: float with get, set
    abstract RG: float with get, set
    abstract UNSIGNED_INT_24_8: float with get, set
    abstract DEPTH24_STENCIL8: float with get, set
    abstract drawBuffers: buffers: ResizeArray<float> -> unit
    abstract readBuffer: src: float -> unit
    abstract COLOR_ATTACHMENT0: float
    abstract COLOR_ATTACHMENT1: float
    abstract COLOR_ATTACHMENT2: float
    abstract COLOR_ATTACHMENT3: float
    abstract ANY_SAMPLES_PASSED_CONSERVATIVE: float with get, set
    abstract ANY_SAMPLES_PASSED: float with get, set
    abstract QUERY_RESULT_AVAILABLE: float with get, set
    abstract QUERY_RESULT: float with get, set
    abstract RASTERIZER_DISCARD: float
    abstract DEPTH_COMPONENT24: float
    abstract TEXTURE_3D: float
    abstract TEXTURE_2D_ARRAY: float
    abstract TEXTURE_COMPARE_FUNC: float
    abstract TEXTURE_COMPARE_MODE: float
    abstract COMPARE_REF_TO_TEXTURE: float
    abstract TEXTURE_WRAP_R: float
    abstract texImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * format: float * ``type``: float * pixels: ArrayBufferView option -> unit
    abstract texImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * format: float * ``type``: float * pixels: ArrayBufferView * offset: float -> unit
    abstract texImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * format: float * ``type``: float * pixels: U5<ImageBitmap, ImageData, HTMLVideoElement, HTMLImageElement, HTMLCanvasElement> -> unit
    abstract compressedTexImage3D: target: float * level: float * internalformat: float * width: float * height: float * depth: float * border: float * data: ArrayBufferView * ?offset: float * ?length: float -> unit
    abstract TRANSFORM_FEEDBACK: float
    abstract INTERLEAVED_ATTRIBS: float
    abstract TRANSFORM_FEEDBACK_BUFFER: float
    abstract createTransformFeedback: unit -> WebGLTransformFeedback
    abstract deleteTransformFeedback: transformFeedbac: WebGLTransformFeedback -> unit
    abstract bindTransformFeedback: target: float * transformFeedback: WebGLTransformFeedback option -> unit
    abstract beginTransformFeedback: primitiveMode: float -> unit
    abstract endTransformFeedback: unit -> unit
    abstract transformFeedbackVaryings: program: WebGLProgram * varyings: ResizeArray<string> * bufferMode: float -> unit

type [<AllowNullLiteral>] Document =
    abstract mozCancelFullScreen: unit -> unit
    abstract msCancelFullScreen: unit -> unit
    abstract mozFullScreen: bool with get, set
    abstract msIsFullScreen: bool with get, set
    abstract fullscreen: bool with get, set
    abstract mozPointerLockElement: HTMLElement with get, set
    abstract msPointerLockElement: HTMLElement with get, set
    abstract webkitPointerLockElement: HTMLElement with get, set

type [<AllowNullLiteral>] HTMLCanvasElement =
    abstract msRequestPointerLock: unit -> unit
    abstract mozRequestPointerLock: unit -> unit
    abstract webkitRequestPointerLock: unit -> unit

type [<AllowNullLiteral>] CanvasRenderingContext2D =
    abstract msImageSmoothingEnabled: bool with get, set

type [<AllowNullLiteral>] WebGLBuffer =
    abstract references: float with get, set
    abstract capacity: float with get, set
    abstract is32Bits: bool with get, set

type [<AllowNullLiteral>] WebGLProgram =
    abstract transformFeedback: WebGLTransformFeedback option with get, set
    abstract __SPECTOR_rebuildProgram: (string -> string -> (WebGLProgram -> unit) -> (string -> unit) -> unit) option with get, set

type [<AllowNullLiteral>] MouseEvent =
    abstract mozMovementX: float with get, set
    abstract mozMovementY: float with get, set
    abstract webkitMovementX: float with get, set
    abstract webkitMovementY: float with get, set
    abstract msMovementX: float with get, set
    abstract msMovementY: float with get, set

type [<AllowNullLiteral>] Navigator =
    abstract mozGetVRDevices: (obj option -> obj option) with get, set
    abstract webkitGetUserMedia: constraints: MediaStreamConstraints * successCallback: NavigatorUserMediaSuccessCallback * errorCallback: NavigatorUserMediaErrorCallback -> unit
    abstract mozGetUserMedia: constraints: MediaStreamConstraints * successCallback: NavigatorUserMediaSuccessCallback * errorCallback: NavigatorUserMediaErrorCallback -> unit
    abstract msGetUserMedia: constraints: MediaStreamConstraints * successCallback: NavigatorUserMediaSuccessCallback * errorCallback: NavigatorUserMediaErrorCallback -> unit
    abstract webkitGetGamepads: unit -> ResizeArray<Gamepad>
    abstract msGetGamepads: unit -> ResizeArray<Gamepad>
    abstract webkitGamepads: unit -> ResizeArray<Gamepad>
    abstract getVRDisplays: unit -> Promise<ResizeArray<VRDisplay>>
    abstract activeVRDisplays: ReadonlyArray<VRDisplay>

type [<AllowNullLiteral>] HTMLVideoElement =
    abstract mozSrcObject: obj option with get, set

type [<AllowNullLiteral>] Screen =
    abstract orientation: string with get, set
    abstract mozOrientation: string with get, set

/// An intrinsic object that provides basic mathematics functionality and constants. 
type [<AllowNullLiteral>] Math =
    abstract fround: x: float -> float
    abstract imul: a: float * b: float -> float

type [<AllowNullLiteral>] EXT_disjoint_timer_query =
    abstract QUERY_COUNTER_BITS_EXT: float with get, set
    abstract TIME_ELAPSED_EXT: float with get, set
    abstract TIMESTAMP_EXT: float with get, set
    abstract GPU_DISJOINT_EXT: float with get, set
    abstract QUERY_RESULT_EXT: float with get, set
    abstract QUERY_RESULT_AVAILABLE_EXT: float with get, set
    abstract queryCounterEXT: query: WebGLQuery * target: float -> unit
    abstract createQueryEXT: unit -> WebGLQuery
    abstract beginQueryEXT: target: float * query: WebGLQuery -> unit
    abstract endQueryEXT: target: float -> unit
    abstract getQueryObjectEXT: query: WebGLQuery * target: float -> obj option
    abstract deleteQueryEXT: query: WebGLQuery -> unit

type [<AllowNullLiteral>] WebGLUniformLocation =
    abstract _currentState: obj option with get, set

type [<AllowNullLiteral>] VRDisplay =
    inherit EventTarget
    /// Dictionary of capabilities describing the VRDisplay.
    abstract capabilities: VRDisplayCapabilities
    /// z-depth defining the far plane of the eye view frustum
    /// enables mapping of values in the render target depth
    /// attachment to scene coordinates. Initially set to 10000.0.
    abstract depthFar: float with get, set
    /// z-depth defining the near plane of the eye view frustum
    /// enables mapping of values in the render target depth
    /// attachment to scene coordinates. Initially set to 0.01.
    abstract depthNear: float with get, set
    /// An identifier for this distinct VRDisplay. Used as an
    /// association point in the Gamepad API.
    abstract displayId: float
    /// A display name, a user-readable name identifying it.
    abstract displayName: string
    abstract isConnected: bool
    abstract isPresenting: bool
    /// If this VRDisplay supports room-scale experiences, the optional
    /// stage attribute contains details on the room-scale parameters.
    abstract stageParameters: VRStageParameters option
    /// Passing the value returned by `requestAnimationFrame` to
    /// `cancelAnimationFrame` will unregister the callback.
    abstract cancelAnimationFrame: handle: float -> unit
    /// Stops presenting to the VRDisplay.
    abstract exitPresent: unit -> Promise<unit>
    abstract getEyeParameters: whichEye: string -> VREyeParameters
    /// Populates the passed VRFrameData with the information required to render
    /// the current frame.
    abstract getFrameData: frameData: VRFrameData -> bool
    /// Get the layers currently being presented.
    abstract getLayers: unit -> ResizeArray<VRLayer>
    /// Return a VRPose containing the future predicted pose of the VRDisplay
    /// when the current frame will be presented. The value returned will not
    /// change until JavaScript has returned control to the browser.
    /// 
    /// The VRPose will contain the position, orientation, velocity,
    /// and acceleration of each of these properties.
    abstract getPose: unit -> VRPose
    /// Return the current instantaneous pose of the VRDisplay, with no
    /// prediction applied.
    abstract getImmediatePose: unit -> VRPose
    /// The callback passed to `requestAnimationFrame` will be called
    /// any time a new frame should be rendered. When the VRDisplay is
    /// presenting the callback will be called at the native refresh
    /// rate of the HMD. When not presenting this function acts
    /// identically to how window.requestAnimationFrame acts. Content should
    /// make no assumptions of frame rate or vsync behavior as the HMD runs
    /// asynchronously from other displays and at differing refresh rates.
    abstract requestAnimationFrame: callback: FrameRequestCallback -> float
    /// Begin presenting to the VRDisplay. Must be called in response to a user gesture.
    /// Repeat calls while already presenting will update the VRLayers being displayed.
    abstract requestPresent: layers: ResizeArray<VRLayer> -> Promise<unit>
    /// Reset the pose for this display, treating its current position and
    /// orientation as the "origin/zero" values. VRPose.position,
    /// VRPose.orientation, and VRStageParameters.sittingToStandingTransform may be
    /// updated when calling resetPose(). This should be called in only
    /// sitting-space experiences.
    abstract resetPose: unit -> unit
    /// The VRLayer provided to the VRDisplay will be captured and presented
    /// in the HMD. Calling this function has the same effect on the source
    /// canvas as any other operation that uses its source image, and canvases
    /// created without preserveDrawingBuffer set to true will be cleared.
    abstract submitFrame: ?pose: VRPose -> unit

type [<AllowNullLiteral>] VRLayer =
    abstract leftBounds: ResizeArray<float> option with get, set
    abstract rightBounds: ResizeArray<float> option with get, set
    abstract source: HTMLCanvasElement option with get, set

type [<AllowNullLiteral>] VRDisplayCapabilities =
    abstract canPresent: bool
    abstract hasExternalDisplay: bool
    abstract hasOrientation: bool
    abstract hasPosition: bool
    abstract maxLayers: float

type [<AllowNullLiteral>] VREyeParameters =
    abstract fieldOfView: VRFieldOfView
    abstract offset: Float32Array
    abstract renderHeight: float
    abstract renderWidth: float

type [<AllowNullLiteral>] VRFieldOfView =
    abstract downDegrees: float
    abstract leftDegrees: float
    abstract rightDegrees: float
    abstract upDegrees: float

type [<AllowNullLiteral>] VRFrameData =
    abstract leftProjectionMatrix: Float32Array
    abstract leftViewMatrix: Float32Array
    abstract pose: VRPose
    abstract rightProjectionMatrix: Float32Array
    abstract rightViewMatrix: Float32Array
    abstract timestamp: float

type [<AllowNullLiteral>] VRPose =
    abstract angularAcceleration: Float32Array option
    abstract angularVelocity: Float32Array option
    abstract linearAcceleration: Float32Array option
    abstract linearVelocity: Float32Array option
    abstract orientation: Float32Array option
    abstract position: Float32Array option
    abstract timestamp: float

type [<AllowNullLiteral>] VRStageParameters =
    abstract sittingToStandingTransform: Float32Array option with get, set
    abstract sizeX: float option with get, set
    abstract sizeY: float option with get, set

type [<AllowNullLiteral>] Gamepad =
    abstract displayId: float

type [<AllowNullLiteral>] ImageBitmap =
    abstract width: float
    abstract height: float
    abstract close: unit -> unit

type [<AllowNullLiteral>] WebGLQuery =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLSampler =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLSync =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLTransformFeedback =
    inherit WebGLObject

type [<AllowNullLiteral>] WebGLVertexArrayObject =
    inherit WebGLObject
